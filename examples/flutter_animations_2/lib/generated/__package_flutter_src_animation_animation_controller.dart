// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/animation/animation_controller.dart';
import 'dart:ui' show lerpDouble;
import 'package:flutter/foundation.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/animation/curves.dart';
import 'package:flutter/src/animation/listener_helpers.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/animation/animation_controller.dart',
  {
    'AnimationController.': _AnimationController__$,
    'AnimationController.unbounded': _AnimationController_unbounded_$,
  },
  {},
  {
    'AnimationController': m.ClassMirror(
      'AnimationController',
      {
        'value': _AnimationController_value$,
        'status': _AnimationController_status$,
        'reset': _AnimationController_reset$,
        'forward': _AnimationController_forward$,
        'reverse': _AnimationController_reverse$,
        'animateTo': _AnimationController_animateTo$,
        'animateBack': _AnimationController_animateBack$,
        'repeat': _AnimationController_repeat$,
        'animateWith': _AnimationController_animateWith$,
        'stop': _AnimationController_stop$,
        'dispose': _AnimationController_dispose$,
      },
      {'value': _AnimationController_value_set$},
    ),
    '_AnimationController&Animation&AnimationEagerListenerMixin&AnimationLocalListenersMixin':
        m.ClassMirror(
      '_AnimationController&Animation&AnimationEagerListenerMixin&AnimationLocalListenersMixin',
      {'addListener': _Animation_addListener$},
      {},
    )
  },
);
Function _AnimationController_value$(
  m.Scope scope$,
  AnimationController target$,
) =>
    () {
      return target$.value;
    };
void _AnimationController_value_set$(
  m.Scope scope$,
  AnimationController target$,
) =>
    (dynamic other$) {
      target$.value = other$;
    };
Function _AnimationController_status$(
  m.Scope scope$,
  AnimationController target$,
) =>
    () {
      return target$.status;
    };
Function _AnimationController__$(m.Scope scope$) => ({
      double? value,
      Duration? duration,
      Duration? reverseDuration,
      String? debugLabel,
      double? lowerBound,
      double? upperBound,
      AnimationBehavior? animationBehavior,
      required TickerProvider vsync,
    }) {
      return AnimationController(
        animationBehavior: animationBehavior ?? AnimationBehavior.normal,
        debugLabel: debugLabel,
        duration: duration,
        lowerBound: lowerBound ?? 0.0,
        reverseDuration: reverseDuration,
        upperBound: upperBound ?? 1.0,
        value: value,
        vsync: vsync,
      );
    };
Function _AnimationController_unbounded_$(m.Scope scope$) =>
    AnimationController.unbounded;
Function _AnimationController_reset$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.reset;
Function _AnimationController_forward$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.forward;
Function _AnimationController_reverse$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.reverse;
Function _AnimationController_animateTo$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.animateTo;
Function _AnimationController_animateBack$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.animateBack;
Function _AnimationController_repeat$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.repeat;
Function _AnimationController_animateWith$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.animateWith;
Function _AnimationController_stop$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.stop;
Function _AnimationController_dispose$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.dispose;

Function _Animation_addListener$(
  m.Scope scope$,
  AnimationLocalListenersMixin target$,
) =>
    (m.FunctionPointer listener) {
      void listenerProxy() => scope$.engine.callFunctionPointer(
            scope$,
            listener,
            [],
            {},
          );
      target$.addListener(listenerProxy);
    };
