// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/ink_well.dart';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/debug.dart';
import 'package:flutter/src/material/feedback.dart';
import 'package:flutter/src/material/ink_highlight.dart';
import 'package:flutter/src/material/material.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/theme.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/ink_well.dart',
  {'InkWell.': _InkWell__$},
  {},
  {},
);
Function _InkWell__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      m.FunctionPointer? onTap,
      m.FunctionPointer? onDoubleTap,
      m.FunctionPointer? onLongPress,
      m.FunctionPointer? onTapDown,
      m.FunctionPointer? onTapUp,
      m.FunctionPointer? onTapCancel,
      m.FunctionPointer? onSecondaryTap,
      m.FunctionPointer? onSecondaryTapUp,
      m.FunctionPointer? onSecondaryTapDown,
      m.FunctionPointer? onSecondaryTapCancel,
      m.FunctionPointer? onHighlightChanged,
      m.FunctionPointer? onHover,
      MouseCursor? mouseCursor,
      Color? focusColor,
      Color? hoverColor,
      Color? highlightColor,
      MaterialStateProperty<Color>? overlayColor,
      Color? splashColor,
      InteractiveInkFeatureFactory? splashFactory,
      double? radius,
      BorderRadius? borderRadius,
      ShapeBorder? customBorder,
      bool? enableFeedback,
      bool? excludeFromSemantics,
      FocusNode? focusNode,
      bool? canRequestFocus,
      m.FunctionPointer? onFocusChange,
      bool? autofocus,
      MaterialStatesController? statesController,
    }) {
      void onDoubleTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDoubleTap!,
            [],
            {},
          );
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      void onHighlightChangedProxy(bool onHighlightChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHighlightChanged!,
            [onHighlightChanged_value$],
            {},
          );
      void onHoverProxy(bool onHover_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_value$],
            {},
          );
      void onLongPressProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onLongPress!,
            [],
            {},
          );
      void onSecondaryTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onSecondaryTap!,
            [],
            {},
          );
      void onSecondaryTapCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onSecondaryTapCancel!,
            [],
            {},
          );
      void onSecondaryTapDownProxy(
              TapDownDetails onSecondaryTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSecondaryTapDown!,
            [onSecondaryTapDown_details$],
            {},
          );
      void onSecondaryTapUpProxy(TapUpDetails onSecondaryTapUp_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSecondaryTapUp!,
            [onSecondaryTapUp_details$],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      void onTapCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTapCancel!,
            [],
            {},
          );
      void onTapDownProxy(TapDownDetails onTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onTapDown!,
            [onTapDown_details$],
            {},
          );
      void onTapUpProxy(TapUpDetails onTapUp_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onTapUp!,
            [onTapUp_details$],
            {},
          );
      return InkWell(
        autofocus: autofocus ?? false,
        borderRadius: borderRadius,
        canRequestFocus: canRequestFocus ?? true,
        child: child,
        customBorder: customBorder,
        enableFeedback: enableFeedback ?? true,
        excludeFromSemantics: excludeFromSemantics ?? false,
        focusColor: focusColor,
        focusNode: focusNode,
        highlightColor: highlightColor,
        hoverColor: hoverColor,
        key: key,
        mouseCursor: mouseCursor,
        onDoubleTap: onDoubleTap == null ? null : onDoubleTapProxy,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onHighlightChanged:
            onHighlightChanged == null ? null : onHighlightChangedProxy,
        onHover: onHover == null ? null : onHoverProxy,
        onLongPress: onLongPress == null ? null : onLongPressProxy,
        onSecondaryTap: onSecondaryTap == null ? null : onSecondaryTapProxy,
        onSecondaryTapCancel:
            onSecondaryTapCancel == null ? null : onSecondaryTapCancelProxy,
        onSecondaryTapDown:
            onSecondaryTapDown == null ? null : onSecondaryTapDownProxy,
        onSecondaryTapUp:
            onSecondaryTapUp == null ? null : onSecondaryTapUpProxy,
        onTap: onTap == null ? null : onTapProxy,
        onTapCancel: onTapCancel == null ? null : onTapCancelProxy,
        onTapDown: onTapDown == null ? null : onTapDownProxy,
        onTapUp: onTapUp == null ? null : onTapUpProxy,
        overlayColor: overlayColor,
        radius: radius,
        splashColor: splashColor,
        splashFactory: splashFactory,
        statesController: statesController,
      );
    };
