// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/text_field.dart';
import 'dart:ui' show BoxHeightStyle, BoxWidthStyle;
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/material/adaptive_text_selection_toolbar.dart';
import 'package:flutter/src/material/color_scheme.dart';
import 'package:flutter/src/material/colors.dart';
import 'package:flutter/src/material/debug.dart';
import 'package:flutter/src/material/desktop_text_selection.dart';
import 'package:flutter/src/material/feedback.dart';
import 'package:flutter/src/material/input_decorator.dart';
import 'package:flutter/src/material/magnifier.dart';
import 'package:flutter/src/material/material_localizations.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/selectable_text.dart'
    show iOSHorizontalOffset;
import 'package:flutter/src/material/spell_check_suggestions_toolbar.dart';
import 'package:flutter/src/material/text_selection.dart';
import 'package:flutter/src/material/theme.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/text_field.dart',
  {'TextField.': _TextField__$},
  {},
  {},
);
Function _TextField__$(m.Scope scope$) => ({
      Key? key,
      TextEditingController? controller,
      FocusNode? focusNode,
      UndoHistoryController? undoController,
      InputDecoration? decoration,
      TextInputType? keyboardType,
      TextInputAction? textInputAction,
      TextCapitalization? textCapitalization,
      TextStyle? style,
      StrutStyle? strutStyle,
      TextAlign? textAlign,
      TextAlignVertical? textAlignVertical,
      TextDirection? textDirection,
      bool? readOnly,
      ToolbarOptions? toolbarOptions,
      bool? showCursor,
      bool? autofocus,
      String? obscuringCharacter,
      bool? obscureText,
      bool? autocorrect,
      SmartDashesType? smartDashesType,
      SmartQuotesType? smartQuotesType,
      bool? enableSuggestions,
      int? maxLines,
      int? minLines,
      bool? expands,
      int? maxLength,
      MaxLengthEnforcement? maxLengthEnforcement,
      m.FunctionPointer? onChanged,
      m.FunctionPointer? onEditingComplete,
      m.FunctionPointer? onSubmitted,
      m.FunctionPointer? onAppPrivateCommand,
      List? inputFormatters,
      bool? enabled,
      double? cursorWidth,
      double? cursorHeight,
      Radius? cursorRadius,
      bool? cursorOpacityAnimates,
      Color? cursorColor,
      BoxHeightStyle? selectionHeightStyle,
      BoxWidthStyle? selectionWidthStyle,
      Brightness? keyboardAppearance,
      EdgeInsets? scrollPadding,
      DragStartBehavior? dragStartBehavior,
      bool? enableInteractiveSelection,
      TextSelectionControls? selectionControls,
      m.FunctionPointer? onTap,
      m.FunctionPointer? onTapOutside,
      MouseCursor? mouseCursor,
      m.FunctionPointer? buildCounter,
      ScrollController? scrollController,
      ScrollPhysics? scrollPhysics,
      Iterable? autofillHints,
      ContentInsertionConfiguration? contentInsertionConfiguration,
      Clip? clipBehavior,
      String? restorationId,
      bool? scribbleEnabled,
      bool? enableIMEPersonalizedLearning,
      m.FunctionPointer? contextMenuBuilder,
      bool? canRequestFocus,
      SpellCheckConfiguration? spellCheckConfiguration,
      TextMagnifierConfiguration? magnifierConfiguration,
    }) {
      Widget? buildCounterProxy(
        BuildContext buildCounter_context$, {
        required int currentLength,
        required bool isFocused,
        required int? maxLength,
      }) =>
          scope$.engine.callFunctionPointer(
            scope$,
            buildCounter!,
            [buildCounter_context$],
            {
              'currentLength': currentLength,
              'isFocused': isFocused,
              'maxLength': maxLength,
            },
          );
      Widget contextMenuBuilderProxy(
        BuildContext contextMenuBuilder_context$,
        EditableTextState contextMenuBuilder_editableTextState$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            contextMenuBuilder!,
            [
              contextMenuBuilder_context$,
              contextMenuBuilder_editableTextState$,
            ],
            {},
          );
      void onAppPrivateCommandProxy(
        String onAppPrivateCommand_$p0$,
        Map onAppPrivateCommand_$p1$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onAppPrivateCommand!,
            [
              onAppPrivateCommand_$p0$,
              onAppPrivateCommand_$p1$,
            ],
            {},
          );
      void onChangedProxy(String onChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChanged!,
            [onChanged_value$],
            {},
          );
      void onEditingCompleteProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEditingComplete!,
            [],
            {},
          );
      void onSubmittedProxy(String onSubmitted_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSubmitted!,
            [onSubmitted_value$],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      void onTapOutsideProxy(PointerDownEvent onTapOutside_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onTapOutside!,
            [onTapOutside_event$],
            {},
          );
      return TextField(
        autocorrect: autocorrect ?? true,
        autofillHints: autofillHints == null
            ? const <String>[]
            : Iterable.castFrom(autofillHints),
        autofocus: autofocus ?? false,
        buildCounter: buildCounter == null ? null : buildCounterProxy,
        canRequestFocus: canRequestFocus ?? true,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        contentInsertionConfiguration: contentInsertionConfiguration,
        contextMenuBuilder: contextMenuBuilder == null
            ? (BuildContext context, EditableTextState editableTextState) {
                return AdaptiveTextSelectionToolbar.editableText(
                  editableTextState: editableTextState,
                );
              }
            : contextMenuBuilderProxy,
        controller: controller,
        cursorColor: cursorColor,
        cursorHeight: cursorHeight,
        cursorOpacityAnimates: cursorOpacityAnimates,
        cursorRadius: cursorRadius,
        cursorWidth: cursorWidth ?? 2.0,
        decoration: decoration ?? const InputDecoration(),
        dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
        enableIMEPersonalizedLearning: enableIMEPersonalizedLearning ?? true,
        enableInteractiveSelection: enableInteractiveSelection,
        enableSuggestions: enableSuggestions ?? true,
        enabled: enabled,
        expands: expands ?? false,
        focusNode: focusNode,
        inputFormatters:
            inputFormatters == null ? null : List.from(inputFormatters),
        key: key,
        keyboardAppearance: keyboardAppearance,
        keyboardType: keyboardType,
        magnifierConfiguration: magnifierConfiguration,
        maxLength: maxLength,
        maxLengthEnforcement: maxLengthEnforcement,
        maxLines: maxLines ?? 1,
        minLines: minLines,
        mouseCursor: mouseCursor,
        obscureText: obscureText ?? false,
        obscuringCharacter: obscuringCharacter ?? 'â€¢',
        onAppPrivateCommand:
            onAppPrivateCommand == null ? null : onAppPrivateCommandProxy,
        onChanged: onChanged == null ? null : onChangedProxy,
        onEditingComplete:
            onEditingComplete == null ? null : onEditingCompleteProxy,
        onSubmitted: onSubmitted == null ? null : onSubmittedProxy,
        onTap: onTap == null ? null : onTapProxy,
        onTapOutside: onTapOutside == null ? null : onTapOutsideProxy,
        readOnly: readOnly ?? false,
        restorationId: restorationId,
        scribbleEnabled: scribbleEnabled ?? true,
        scrollController: scrollController,
        scrollPadding: scrollPadding ?? const EdgeInsets.all(20.0),
        scrollPhysics: scrollPhysics,
        selectionControls: selectionControls,
        selectionHeightStyle: selectionHeightStyle ?? BoxHeightStyle.tight,
        selectionWidthStyle: selectionWidthStyle ?? BoxWidthStyle.tight,
        showCursor: showCursor,
        smartDashesType: smartDashesType,
        smartQuotesType: smartQuotesType,
        spellCheckConfiguration: spellCheckConfiguration,
        strutStyle: strutStyle,
        style: style,
        textAlign: textAlign ?? TextAlign.start,
        textAlignVertical: textAlignVertical,
        textCapitalization: textCapitalization ?? TextCapitalization.none,
        textDirection: textDirection,
        textInputAction: textInputAction,
        toolbarOptions: toolbarOptions,
        undoController: undoController,
      );
    };
