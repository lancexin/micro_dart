// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/basic.dart';
import 'dart:math';
import 'dart:ui' show Image, ImageFilter, TextHeightBehavior;
import 'package:flutter/animation.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/debug.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/localizations.dart';
import 'package:flutter/src/widgets/visibility.dart';
import 'package:flutter/src/widgets/widget_span.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/basic.dart',
  {
    'Directionality.of': _Directionality_of$,
    'Opacity.': _Opacity__$,
    'CustomPaint.': _CustomPaint__$,
    'ClipRect.': _ClipRect__$,
    'ClipRRect.': _ClipRRect__$,
    'ClipOval.': _ClipOval__$,
    'PhysicalShape.': _PhysicalShape__$,
    'Transform.': _Transform__$,
    'Transform.rotate': _Transform_rotate_$,
    'Transform.scale': _Transform_scale_$,
    'FittedBox.': _FittedBox__$,
    'FractionalTranslation.': _FractionalTranslation__$,
    'RotatedBox.': _RotatedBox__$,
    'Padding.': _Padding__$,
    'Align.': _Align__$,
    'Center.': _Center__$,
    'SizedBox.': _SizedBox__$,
    'SizedBox.expand': _SizedBox_expand_$,
    'SizedBox.shrink': _SizedBox_shrink_$,
    'ConstrainedBox.': _ConstrainedBox__$,
    'OverflowBox.': _OverflowBox__$,
    'AspectRatio.': _AspectRatio__$,
    'IntrinsicHeight.': _IntrinsicHeight__$,
    'SliverPadding.': _SliverPadding__$,
    'Stack.': _Stack__$,
    'IndexedStack.': _IndexedStack__$,
    'Positioned.': _Positioned__$,
    'Positioned.fill': _Positioned_fill_$,
    'PositionedDirectional.': _PositionedDirectional__$,
    'Row.': _Row__$,
    'Column.': _Column__$,
    'Flexible.': _Flexible__$,
    'Expanded.': _Expanded__$,
    'Wrap.': _Wrap__$,
    'Listener.': _Listener__$,
    'MouseRegion.': _MouseRegion__$,
    'RepaintBoundary.': _RepaintBoundary__$,
    'IgnorePointer.': _IgnorePointer__$,
    'Semantics.': _Semantics__$,
    'Semantics.fromProperties': _Semantics_fromProperties_$,
    'MergeSemantics.': _MergeSemantics__$,
    'ExcludeSemantics.': _ExcludeSemantics__$,
    'Builder.': _Builder__$,
    'StatefulBuilder.': _StatefulBuilder__$,
  },
  {},
  {},
);
Function _Directionality_of$(m.Scope scope$) => Directionality.of;
Function _Opacity__$(m.Scope scope$) => ({
      Key? key,
      required double opacity,
      bool? alwaysIncludeSemantics,
      Widget? child,
    }) {
      return Opacity(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        child: child,
        key: key,
        opacity: opacity,
      );
    };
Function _CustomPaint__$(m.Scope scope$) => ({
      Key? key,
      CustomPainter? painter,
      CustomPainter? foregroundPainter,
      Size? size,
      bool? isComplex,
      bool? willChange,
      Widget? child,
    }) {
      return CustomPaint(
        child: child,
        foregroundPainter: foregroundPainter,
        isComplex: isComplex ?? false,
        key: key,
        painter: painter,
        size: size ?? Size.zero,
        willChange: willChange ?? false,
      );
    };
Function _ClipRect__$(m.Scope scope$) => ({
      Key? key,
      CustomClipper<Rect>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipRect(
        child: child,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        clipper: clipper,
        key: key,
      );
    };
Function _ClipRRect__$(m.Scope scope$) => ({
      Key? key,
      BorderRadiusGeometry? borderRadius,
      CustomClipper<RRect>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipRRect(
        borderRadius: borderRadius ?? BorderRadius.zero,
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
        key: key,
      );
    };
Function _ClipOval__$(m.Scope scope$) => ({
      Key? key,
      CustomClipper<Rect>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipOval(
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
        key: key,
      );
    };
Function _PhysicalShape__$(m.Scope scope$) => ({
      Key? key,
      required CustomClipper<Path> clipper,
      Clip? clipBehavior,
      double? elevation,
      required Color color,
      Color? shadowColor,
      Widget? child,
    }) {
      return PhysicalShape(
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        clipper: clipper,
        color: color,
        elevation: elevation ?? 0.0,
        key: key,
        shadowColor: shadowColor ?? const Color(0xFF000000),
      );
    };
Function _Transform__$(m.Scope scope$) => ({
      Key? key,
      required Matrix4 transform,
      Offset? origin,
      AlignmentGeometry? alignment,
      bool? transformHitTests,
      FilterQuality? filterQuality,
      Widget? child,
    }) {
      return Transform(
        alignment: alignment,
        child: child,
        filterQuality: filterQuality,
        key: key,
        origin: origin,
        transform: transform,
        transformHitTests: transformHitTests ?? true,
      );
    };
Function _Transform_rotate_$(m.Scope scope$) => Transform.rotate;
Function _Transform_scale_$(m.Scope scope$) => Transform.scale;
Function _FittedBox__$(m.Scope scope$) => ({
      Key? key,
      BoxFit? fit,
      AlignmentGeometry? alignment,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return FittedBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        fit: fit ?? BoxFit.contain,
        key: key,
      );
    };
Function _FractionalTranslation__$(m.Scope scope$) => ({
      Key? key,
      required Offset translation,
      bool? transformHitTests,
      Widget? child,
    }) {
      return FractionalTranslation(
        child: child,
        key: key,
        transformHitTests: transformHitTests ?? true,
        translation: translation,
      );
    };
Function _RotatedBox__$(m.Scope scope$) => ({
      Key? key,
      required int quarterTurns,
      Widget? child,
    }) {
      return RotatedBox(
        child: child,
        key: key,
        quarterTurns: quarterTurns,
      );
    };
Function _Padding__$(m.Scope scope$) => ({
      Key? key,
      required EdgeInsetsGeometry padding,
      Widget? child,
    }) {
      return Padding(
        child: child,
        key: key,
        padding: padding,
      );
    };
Function _Align__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      double? widthFactor,
      double? heightFactor,
      Widget? child,
    }) {
      return Align(
        alignment: alignment ?? Alignment.center,
        child: child,
        heightFactor: heightFactor,
        key: key,
        widthFactor: widthFactor,
      );
    };
Function _Center__$(m.Scope scope$) => ({
      Key? key,
      double? widthFactor,
      double? heightFactor,
      Widget? child,
    }) {
      return Center(
        child: child,
        heightFactor: heightFactor,
        key: key,
        widthFactor: widthFactor,
      );
    };
Function _SizedBox__$(m.Scope scope$) => ({
      Key? key,
      double? width,
      double? height,
      Widget? child,
    }) {
      return SizedBox(
        child: child,
        height: height,
        key: key,
        width: width,
      );
    };
Function _SizedBox_expand_$(m.Scope scope$) => SizedBox.expand;
Function _SizedBox_shrink_$(m.Scope scope$) => SizedBox.shrink;
Function _ConstrainedBox__$(m.Scope scope$) => ({
      Key? key,
      required BoxConstraints constraints,
      Widget? child,
    }) {
      return ConstrainedBox(
        child: child,
        constraints: constraints,
        key: key,
      );
    };
Function _OverflowBox__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      double? minWidth,
      double? maxWidth,
      double? minHeight,
      double? maxHeight,
      Widget? child,
    }) {
      return OverflowBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        key: key,
        maxHeight: maxHeight,
        maxWidth: maxWidth,
        minHeight: minHeight,
        minWidth: minWidth,
      );
    };
Function _AspectRatio__$(m.Scope scope$) => ({
      Key? key,
      required double aspectRatio,
      Widget? child,
    }) {
      return AspectRatio(
        aspectRatio: aspectRatio,
        child: child,
        key: key,
      );
    };
Function _IntrinsicHeight__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return IntrinsicHeight(
        child: child,
        key: key,
      );
    };
Function _SliverPadding__$(m.Scope scope$) => ({
      Key? key,
      required EdgeInsetsGeometry padding,
      Widget? sliver,
    }) {
      return SliverPadding(
        key: key,
        padding: padding,
        sliver: sliver,
      );
    };
Function _Stack__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      TextDirection? textDirection,
      StackFit? fit,
      Clip? clipBehavior,
      List? children,
    }) {
      return Stack(
        alignment: alignment ?? AlignmentDirectional.topStart,
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        fit: fit ?? StackFit.loose,
        key: key,
        textDirection: textDirection,
      );
    };
Function _IndexedStack__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      TextDirection? textDirection,
      Clip? clipBehavior,
      StackFit? sizing,
      int? index,
      List? children,
    }) {
      return IndexedStack(
        alignment: alignment ?? AlignmentDirectional.topStart,
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        index: index ?? 0,
        key: key,
        sizing: sizing ?? StackFit.loose,
        textDirection: textDirection,
      );
    };
Function _Positioned__$(m.Scope scope$) => ({
      Key? key,
      double? left,
      double? top,
      double? right,
      double? bottom,
      double? width,
      double? height,
      required Widget child,
    }) {
      return Positioned(
        bottom: bottom,
        child: child,
        height: height,
        key: key,
        left: left,
        right: right,
        top: top,
        width: width,
      );
    };
Function _Positioned_fill_$(m.Scope scope$) => Positioned.fill;
Function _PositionedDirectional__$(m.Scope scope$) => ({
      Key? key,
      double? start,
      double? top,
      double? end,
      double? bottom,
      double? width,
      double? height,
      required Widget child,
    }) {
      return PositionedDirectional(
        bottom: bottom,
        child: child,
        end: end,
        height: height,
        key: key,
        start: start,
        top: top,
        width: width,
      );
    };
Function _Row__$(m.Scope scope$) => ({
      Key? key,
      MainAxisAlignment? mainAxisAlignment,
      MainAxisSize? mainAxisSize,
      CrossAxisAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      TextBaseline? textBaseline,
      List? children,
    }) {
      return Row(
        children: children == null ? const <Widget>[] : List.from(children),
        crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
        key: key,
        mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
        mainAxisSize: mainAxisSize ?? MainAxisSize.max,
        textBaseline: textBaseline,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function _Column__$(m.Scope scope$) => ({
      Key? key,
      MainAxisAlignment? mainAxisAlignment,
      MainAxisSize? mainAxisSize,
      CrossAxisAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      TextBaseline? textBaseline,
      List? children,
    }) {
      return Column(
        children: children == null ? const <Widget>[] : List.from(children),
        crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
        key: key,
        mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
        mainAxisSize: mainAxisSize ?? MainAxisSize.max,
        textBaseline: textBaseline,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function _Flexible__$(m.Scope scope$) => ({
      Key? key,
      int? flex,
      FlexFit? fit,
      required Widget child,
    }) {
      return Flexible(
        child: child,
        fit: fit ?? FlexFit.loose,
        flex: flex ?? 1,
        key: key,
      );
    };
Function _Expanded__$(m.Scope scope$) => ({
      Key? key,
      int? flex,
      required Widget child,
    }) {
      return Expanded(
        child: child,
        flex: flex ?? 1,
        key: key,
      );
    };
Function _Wrap__$(m.Scope scope$) => ({
      Key? key,
      Axis? direction,
      WrapAlignment? alignment,
      double? spacing,
      WrapAlignment? runAlignment,
      double? runSpacing,
      WrapCrossAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      Clip? clipBehavior,
      List? children,
    }) {
      return Wrap(
        alignment: alignment ?? WrapAlignment.start,
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.none,
        crossAxisAlignment: crossAxisAlignment ?? WrapCrossAlignment.start,
        direction: direction ?? Axis.horizontal,
        key: key,
        runAlignment: runAlignment ?? WrapAlignment.start,
        runSpacing: runSpacing ?? 0.0,
        spacing: spacing ?? 0.0,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function _Listener__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onPointerDown,
      m.FunctionPointer? onPointerMove,
      m.FunctionPointer? onPointerUp,
      m.FunctionPointer? onPointerHover,
      m.FunctionPointer? onPointerCancel,
      m.FunctionPointer? onPointerPanZoomStart,
      m.FunctionPointer? onPointerPanZoomUpdate,
      m.FunctionPointer? onPointerPanZoomEnd,
      m.FunctionPointer? onPointerSignal,
      HitTestBehavior? behavior,
      Widget? child,
    }) {
      void onPointerCancelProxy(PointerCancelEvent onPointerCancel_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerCancel!,
            [onPointerCancel_event$],
            {},
          );
      void onPointerDownProxy(PointerDownEvent onPointerDown_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerDown!,
            [onPointerDown_event$],
            {},
          );
      void onPointerHoverProxy(PointerHoverEvent onPointerHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerHover!,
            [onPointerHover_event$],
            {},
          );
      void onPointerMoveProxy(PointerMoveEvent onPointerMove_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerMove!,
            [onPointerMove_event$],
            {},
          );
      void onPointerPanZoomEndProxy(
              PointerPanZoomEndEvent onPointerPanZoomEnd_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomEnd!,
            [onPointerPanZoomEnd_event$],
            {},
          );
      void onPointerPanZoomStartProxy(
              PointerPanZoomStartEvent onPointerPanZoomStart_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomStart!,
            [onPointerPanZoomStart_event$],
            {},
          );
      void onPointerPanZoomUpdateProxy(
              PointerPanZoomUpdateEvent onPointerPanZoomUpdate_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomUpdate!,
            [onPointerPanZoomUpdate_event$],
            {},
          );
      void onPointerSignalProxy(PointerSignalEvent onPointerSignal_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerSignal!,
            [onPointerSignal_event$],
            {},
          );
      void onPointerUpProxy(PointerUpEvent onPointerUp_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerUp!,
            [onPointerUp_event$],
            {},
          );
      return Listener(
        behavior: behavior ?? HitTestBehavior.deferToChild,
        child: child,
        key: key,
        onPointerCancel: onPointerCancel == null ? null : onPointerCancelProxy,
        onPointerDown: onPointerDown == null ? null : onPointerDownProxy,
        onPointerHover: onPointerHover == null ? null : onPointerHoverProxy,
        onPointerMove: onPointerMove == null ? null : onPointerMoveProxy,
        onPointerPanZoomEnd:
            onPointerPanZoomEnd == null ? null : onPointerPanZoomEndProxy,
        onPointerPanZoomStart:
            onPointerPanZoomStart == null ? null : onPointerPanZoomStartProxy,
        onPointerPanZoomUpdate:
            onPointerPanZoomUpdate == null ? null : onPointerPanZoomUpdateProxy,
        onPointerSignal: onPointerSignal == null ? null : onPointerSignalProxy,
        onPointerUp: onPointerUp == null ? null : onPointerUpProxy,
      );
    };
Function _MouseRegion__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onEnter,
      m.FunctionPointer? onExit,
      m.FunctionPointer? onHover,
      MouseCursor? cursor,
      bool? opaque,
      HitTestBehavior? hitTestBehavior,
      Widget? child,
    }) {
      void onEnterProxy(PointerEnterEvent onEnter_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEnter!,
            [onEnter_event$],
            {},
          );
      void onExitProxy(PointerExitEvent onExit_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onExit!,
            [onExit_event$],
            {},
          );
      void onHoverProxy(PointerHoverEvent onHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_event$],
            {},
          );
      return MouseRegion(
        child: child,
        cursor: cursor ?? MouseCursor.defer,
        hitTestBehavior: hitTestBehavior,
        key: key,
        onEnter: onEnter == null ? null : onEnterProxy,
        onExit: onExit == null ? null : onExitProxy,
        onHover: onHover == null ? null : onHoverProxy,
        opaque: opaque ?? true,
      );
    };
Function _RepaintBoundary__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return RepaintBoundary(
        child: child,
        key: key,
      );
    };
Function _IgnorePointer__$(m.Scope scope$) => ({
      Key? key,
      bool? ignoring,
      bool? ignoringSemantics,
      Widget? child,
    }) {
      return IgnorePointer(
        child: child,
        ignoring: ignoring ?? true,
        ignoringSemantics: ignoringSemantics,
        key: key,
      );
    };
Function _Semantics__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      bool? container,
      bool? explicitChildNodes,
      bool? excludeSemantics,
      bool? enabled,
      bool? checked,
      bool? mixed,
      bool? selected,
      bool? toggled,
      bool? button,
      bool? slider,
      bool? keyboardKey,
      bool? link,
      bool? header,
      bool? textField,
      bool? readOnly,
      bool? focusable,
      bool? focused,
      bool? inMutuallyExclusiveGroup,
      bool? obscured,
      bool? multiline,
      bool? scopesRoute,
      bool? namesRoute,
      bool? hidden,
      bool? image,
      bool? liveRegion,
      int? maxValueLength,
      int? currentValueLength,
      String? label,
      AttributedString? attributedLabel,
      String? value,
      AttributedString? attributedValue,
      String? increasedValue,
      AttributedString? attributedIncreasedValue,
      String? decreasedValue,
      AttributedString? attributedDecreasedValue,
      String? hint,
      AttributedString? attributedHint,
      String? tooltip,
      String? onTapHint,
      String? onLongPressHint,
      TextDirection? textDirection,
      SemanticsSortKey? sortKey,
      SemanticsTag? tagForChildren,
      m.FunctionPointer? onTap,
      m.FunctionPointer? onLongPress,
      m.FunctionPointer? onScrollLeft,
      m.FunctionPointer? onScrollRight,
      m.FunctionPointer? onScrollUp,
      m.FunctionPointer? onScrollDown,
      m.FunctionPointer? onIncrease,
      m.FunctionPointer? onDecrease,
      m.FunctionPointer? onCopy,
      m.FunctionPointer? onCut,
      m.FunctionPointer? onPaste,
      m.FunctionPointer? onDismiss,
      m.FunctionPointer? onMoveCursorForwardByCharacter,
      m.FunctionPointer? onMoveCursorBackwardByCharacter,
      m.FunctionPointer? onSetSelection,
      m.FunctionPointer? onSetText,
      m.FunctionPointer? onDidGainAccessibilityFocus,
      m.FunctionPointer? onDidLoseAccessibilityFocus,
      Map? customSemanticsActions,
    }) {
      void onCopyProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onCopy!,
            [],
            {},
          );
      void onCutProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onCut!,
            [],
            {},
          );
      void onDecreaseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDecrease!,
            [],
            {},
          );
      void onDidGainAccessibilityFocusProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDidGainAccessibilityFocus!,
            [],
            {},
          );
      void onDidLoseAccessibilityFocusProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDidLoseAccessibilityFocus!,
            [],
            {},
          );
      void onDismissProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDismiss!,
            [],
            {},
          );
      void onIncreaseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onIncrease!,
            [],
            {},
          );
      void onLongPressProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onLongPress!,
            [],
            {},
          );
      void onMoveCursorBackwardByCharacterProxy(
              bool onMoveCursorBackwardByCharacter_extendSelection$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onMoveCursorBackwardByCharacter!,
            [onMoveCursorBackwardByCharacter_extendSelection$],
            {},
          );
      void onMoveCursorForwardByCharacterProxy(
              bool onMoveCursorForwardByCharacter_extendSelection$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onMoveCursorForwardByCharacter!,
            [onMoveCursorForwardByCharacter_extendSelection$],
            {},
          );
      void onPasteProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPaste!,
            [],
            {},
          );
      void onScrollDownProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollDown!,
            [],
            {},
          );
      void onScrollLeftProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollLeft!,
            [],
            {},
          );
      void onScrollRightProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollRight!,
            [],
            {},
          );
      void onScrollUpProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollUp!,
            [],
            {},
          );
      void onSetSelectionProxy(TextSelection onSetSelection_selection$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSetSelection!,
            [onSetSelection_selection$],
            {},
          );
      void onSetTextProxy(String onSetText_text$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSetText!,
            [onSetText_text$],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      return Semantics(
        attributedDecreasedValue: attributedDecreasedValue,
        attributedHint: attributedHint,
        attributedIncreasedValue: attributedIncreasedValue,
        attributedLabel: attributedLabel,
        attributedValue: attributedValue,
        button: button,
        checked: checked,
        child: child,
        container: container ?? false,
        currentValueLength: currentValueLength,
        customSemanticsActions: customSemanticsActions == null
            ? null
            : Map.from(customSemanticsActions),
        decreasedValue: decreasedValue,
        enabled: enabled,
        excludeSemantics: excludeSemantics ?? false,
        explicitChildNodes: explicitChildNodes ?? false,
        focusable: focusable,
        focused: focused,
        header: header,
        hidden: hidden,
        hint: hint,
        image: image,
        inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
        increasedValue: increasedValue,
        key: key,
        keyboardKey: keyboardKey,
        label: label,
        link: link,
        liveRegion: liveRegion,
        maxValueLength: maxValueLength,
        mixed: mixed,
        multiline: multiline,
        namesRoute: namesRoute,
        obscured: obscured,
        onCopy: onCopy == null ? null : onCopyProxy,
        onCut: onCut == null ? null : onCutProxy,
        onDecrease: onDecrease == null ? null : onDecreaseProxy,
        onDidGainAccessibilityFocus: onDidGainAccessibilityFocus == null
            ? null
            : onDidGainAccessibilityFocusProxy,
        onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus == null
            ? null
            : onDidLoseAccessibilityFocusProxy,
        onDismiss: onDismiss == null ? null : onDismissProxy,
        onIncrease: onIncrease == null ? null : onIncreaseProxy,
        onLongPress: onLongPress == null ? null : onLongPressProxy,
        onLongPressHint: onLongPressHint,
        onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter == null
            ? null
            : onMoveCursorBackwardByCharacterProxy,
        onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter == null
            ? null
            : onMoveCursorForwardByCharacterProxy,
        onPaste: onPaste == null ? null : onPasteProxy,
        onScrollDown: onScrollDown == null ? null : onScrollDownProxy,
        onScrollLeft: onScrollLeft == null ? null : onScrollLeftProxy,
        onScrollRight: onScrollRight == null ? null : onScrollRightProxy,
        onScrollUp: onScrollUp == null ? null : onScrollUpProxy,
        onSetSelection: onSetSelection == null ? null : onSetSelectionProxy,
        onSetText: onSetText == null ? null : onSetTextProxy,
        onTap: onTap == null ? null : onTapProxy,
        onTapHint: onTapHint,
        readOnly: readOnly,
        scopesRoute: scopesRoute,
        selected: selected,
        slider: slider,
        sortKey: sortKey,
        tagForChildren: tagForChildren,
        textDirection: textDirection,
        textField: textField,
        toggled: toggled,
        tooltip: tooltip,
        value: value,
      );
    };
Function _Semantics_fromProperties_$(m.Scope scope$) =>
    Semantics.fromProperties;
Function _MergeSemantics__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return MergeSemantics(
        child: child,
        key: key,
      );
    };
Function _ExcludeSemantics__$(m.Scope scope$) => ({
      Key? key,
      bool? excluding,
      Widget? child,
    }) {
      return ExcludeSemantics(
        child: child,
        excluding: excluding ?? true,
        key: key,
      );
    };
Function _Builder__$(m.Scope scope$) => ({
      Key? key,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(BuildContext builder_context$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [builder_context$],
            {},
          );
      return Builder(
        builder: builderProxy,
        key: key,
      );
    };
Function _StatefulBuilder__$(m.Scope scope$) => ({
      Key? key,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        void Function(void Function()) builder_setState$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [
              builder_context$,
              builder_setState$,
            ],
            {},
          );
      return StatefulBuilder(
        builder: builderProxy,
        key: key,
      );
    };
