// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/selectable_text.dart';
import 'dart:ui' show BoxHeightStyle, BoxWidthStyle;
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/src/material/adaptive_text_selection_toolbar.dart';
import 'package:flutter/src/material/desktop_text_selection.dart';
import 'package:flutter/src/material/feedback.dart';
import 'package:flutter/src/material/magnifier.dart';
import 'package:flutter/src/material/text_selection.dart';
import 'package:flutter/src/material/theme.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/selectable_text.dart',
  {
    'SelectableText.': _SelectableText__$,
    'SelectableText.rich': _SelectableText_rich_$,
  },
  {},
  {},
);
Function _SelectableText__$(m.Scope scope$) => (
      String data, {
      Key? key,
      FocusNode? focusNode,
      TextStyle? style,
      StrutStyle? strutStyle,
      TextAlign? textAlign,
      TextDirection? textDirection,
      double? textScaleFactor,
      bool? showCursor,
      bool? autofocus,
      ToolbarOptions? toolbarOptions,
      int? minLines,
      int? maxLines,
      double? cursorWidth,
      double? cursorHeight,
      Radius? cursorRadius,
      Color? cursorColor,
      BoxHeightStyle? selectionHeightStyle,
      BoxWidthStyle? selectionWidthStyle,
      DragStartBehavior? dragStartBehavior,
      bool? enableInteractiveSelection,
      TextSelectionControls? selectionControls,
      m.FunctionPointer? onTap,
      ScrollPhysics? scrollPhysics,
      String? semanticsLabel,
      TextHeightBehavior? textHeightBehavior,
      TextWidthBasis? textWidthBasis,
      m.FunctionPointer? onSelectionChanged,
      m.FunctionPointer? contextMenuBuilder,
      TextMagnifierConfiguration? magnifierConfiguration,
    }) {
      Widget contextMenuBuilderProxy(
        BuildContext contextMenuBuilder_context$,
        EditableTextState contextMenuBuilder_editableTextState$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            contextMenuBuilder!,
            [
              contextMenuBuilder_context$,
              contextMenuBuilder_editableTextState$,
            ],
            {},
          );
      void onSelectionChangedProxy(
        TextSelection onSelectionChanged_selection$,
        SelectionChangedCause? onSelectionChanged_cause$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSelectionChanged!,
            [
              onSelectionChanged_selection$,
              onSelectionChanged_cause$,
            ],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      return SelectableText(
        data,
        autofocus: autofocus ?? false,
        contextMenuBuilder: contextMenuBuilder == null
            ? (BuildContext context, EditableTextState editableTextState) {
                return AdaptiveTextSelectionToolbar.editableText(
                  editableTextState: editableTextState,
                );
              }
            : contextMenuBuilderProxy,
        cursorColor: cursorColor,
        cursorHeight: cursorHeight,
        cursorRadius: cursorRadius,
        cursorWidth: cursorWidth ?? 2.0,
        dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
        enableInteractiveSelection: enableInteractiveSelection ?? true,
        focusNode: focusNode,
        key: key,
        magnifierConfiguration: magnifierConfiguration,
        maxLines: maxLines,
        minLines: minLines,
        onSelectionChanged:
            onSelectionChanged == null ? null : onSelectionChangedProxy,
        onTap: onTap == null ? null : onTapProxy,
        scrollPhysics: scrollPhysics,
        selectionControls: selectionControls,
        selectionHeightStyle: selectionHeightStyle ?? BoxHeightStyle.tight,
        selectionWidthStyle: selectionWidthStyle ?? BoxWidthStyle.tight,
        semanticsLabel: semanticsLabel,
        showCursor: showCursor ?? false,
        strutStyle: strutStyle,
        style: style,
        textAlign: textAlign,
        textDirection: textDirection,
        textHeightBehavior: textHeightBehavior,
        textScaleFactor: textScaleFactor,
        textWidthBasis: textWidthBasis,
        toolbarOptions: toolbarOptions,
      );
    };
Function _SelectableText_rich_$(m.Scope scope$) => (
      TextSpan textSpan, {
      Key? key,
      FocusNode? focusNode,
      TextStyle? style,
      StrutStyle? strutStyle,
      TextAlign? textAlign,
      TextDirection? textDirection,
      double? textScaleFactor,
      bool? showCursor,
      bool? autofocus,
      ToolbarOptions? toolbarOptions,
      int? minLines,
      int? maxLines,
      double? cursorWidth,
      double? cursorHeight,
      Radius? cursorRadius,
      Color? cursorColor,
      BoxHeightStyle? selectionHeightStyle,
      BoxWidthStyle? selectionWidthStyle,
      DragStartBehavior? dragStartBehavior,
      bool? enableInteractiveSelection,
      TextSelectionControls? selectionControls,
      m.FunctionPointer? onTap,
      ScrollPhysics? scrollPhysics,
      String? semanticsLabel,
      TextHeightBehavior? textHeightBehavior,
      TextWidthBasis? textWidthBasis,
      m.FunctionPointer? onSelectionChanged,
      m.FunctionPointer? contextMenuBuilder,
      TextMagnifierConfiguration? magnifierConfiguration,
    }) {
      Widget contextMenuBuilderProxy(
        BuildContext contextMenuBuilder_context$,
        EditableTextState contextMenuBuilder_editableTextState$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            contextMenuBuilder!,
            [
              contextMenuBuilder_context$,
              contextMenuBuilder_editableTextState$,
            ],
            {},
          );
      void onSelectionChangedProxy(
        TextSelection onSelectionChanged_selection$,
        SelectionChangedCause? onSelectionChanged_cause$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSelectionChanged!,
            [
              onSelectionChanged_selection$,
              onSelectionChanged_cause$,
            ],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      return SelectableText.rich(
        textSpan,
        autofocus: autofocus ?? false,
        contextMenuBuilder: contextMenuBuilder == null
            ? (BuildContext context, EditableTextState editableTextState) {
                return AdaptiveTextSelectionToolbar.editableText(
                  editableTextState: editableTextState,
                );
              }
            : contextMenuBuilderProxy,
        cursorColor: cursorColor,
        cursorHeight: cursorHeight,
        cursorRadius: cursorRadius,
        cursorWidth: cursorWidth ?? 2.0,
        dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
        enableInteractiveSelection: enableInteractiveSelection ?? true,
        focusNode: focusNode,
        key: key,
        magnifierConfiguration: magnifierConfiguration,
        maxLines: maxLines,
        minLines: minLines,
        onSelectionChanged:
            onSelectionChanged == null ? null : onSelectionChangedProxy,
        onTap: onTap == null ? null : onTapProxy,
        scrollPhysics: scrollPhysics,
        selectionControls: selectionControls,
        selectionHeightStyle: selectionHeightStyle ?? BoxHeightStyle.tight,
        selectionWidthStyle: selectionWidthStyle ?? BoxWidthStyle.tight,
        semanticsLabel: semanticsLabel,
        showCursor: showCursor ?? false,
        strutStyle: strutStyle,
        style: style,
        textAlign: textAlign,
        textDirection: textDirection,
        textHeightBehavior: textHeightBehavior,
        textScaleFactor: textScaleFactor,
        textWidthBasis: textWidthBasis,
        toolbarOptions: toolbarOptions,
      );
    };
