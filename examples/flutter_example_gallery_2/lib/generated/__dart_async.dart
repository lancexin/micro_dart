// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:async';
import 'dart:collection' show HashMap;

const libraryMirror = m.LibraryMirror(
  'dart:async',
  {
    'Future.delayed': _Future_delayed_$,
    'Timer.': _Timer__$,
  },
  {},
  {
    'Future': m.ClassMirror(
      'Future',
      {
        'then': _Future_then$,
        'catchError': _Future_catchError$,
        'whenComplete': _Future_whenComplete$,
      },
      {},
    ),
    'Timer': m.ClassMirror(
      'Timer',
      {'cancel': _Timer_cancel$},
      {},
    ),
  },
);
Function _Future_delayed_$(m.Scope scope$) => (
      Duration duration, [
      m.FunctionPointer? computation,
    ]) {
      if (computation == null) {
        return Future.delayed(duration);
      }
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation!,
            [],
            {},
          );
      return Future.delayed(
        duration,
        computation == null ? null : computationProxy,
      );
    };
Function _Future_then$(
  m.Scope scope$,
  Future target$,
) =>
    (
      m.FunctionPointer onValue, {
      Function? onError,
    }) {
      FutureOr onValueProxy(dynamic onValue_value$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onValue,
            [onValue_value$],
            {},
          );
      return target$.then(
        onValueProxy,
        onError: onError,
      );
    };
Function _Future_catchError$(
  m.Scope scope$,
  Future target$,
) =>
    (
      Function onError, {
      m.FunctionPointer? test,
    }) {
      bool testProxy(Object test_error$) => scope$.engine.callFunctionPointer(
            scope$,
            test!,
            [test_error$],
            {},
          );
      return target$.catchError(
        onError,
        test: test == null ? null : testProxy,
      );
    };
Function _Future_whenComplete$(
  m.Scope scope$,
  Future target$,
) =>
    (m.FunctionPointer action) {
      FutureOr<void> actionProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [],
            {},
          );
      return target$.whenComplete(actionProxy);
    };
Function _Timer__$(m.Scope scope$) => (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return Timer(
        duration,
        callbackProxy,
      );
    };
Function _Timer_cancel$(
  m.Scope scope$,
  Timer target$,
) =>
    target$.cancel;
