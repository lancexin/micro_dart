// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/image.dart';
import 'dart:async';
import 'dart:io' show File;
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/disposable_build_context.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/localizations.dart';
import 'package:flutter/src/widgets/media_query.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:flutter/src/widgets/scroll_aware_image_provider.dart';
import 'package:flutter/src/widgets/text.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/image.dart',
  {
    'Image.': _Image__$,
    'Image.asset': _Image_asset_$,
  },
  {},
  {},
);
Function _Image__$(m.Scope scope$) => ({
      Key? key,
      required ImageProvider<Object> image,
      m.FunctionPointer? frameBuilder,
      m.FunctionPointer? loadingBuilder,
      m.FunctionPointer? errorBuilder,
      String? semanticLabel,
      bool? excludeFromSemantics,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry? alignment,
      ImageRepeat? repeat,
      Rect? centerSlice,
      bool? matchTextDirection,
      bool? gaplessPlayback,
      bool? isAntiAlias,
      FilterQuality? filterQuality,
    }) {
      Widget errorBuilderProxy(
        BuildContext errorBuilder_context$,
        Object errorBuilder_error$,
        StackTrace? errorBuilder_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            errorBuilder!,
            [
              errorBuilder_context$,
              errorBuilder_error$,
              errorBuilder_stackTrace$,
            ],
            {},
          );
      Widget frameBuilderProxy(
        BuildContext frameBuilder_context$,
        Widget frameBuilder_child$,
        int? frameBuilder_frame$,
        bool frameBuilder_wasSynchronouslyLoaded$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            frameBuilder!,
            [
              frameBuilder_context$,
              frameBuilder_child$,
              frameBuilder_frame$,
              frameBuilder_wasSynchronouslyLoaded$,
            ],
            {},
          );
      Widget loadingBuilderProxy(
        BuildContext loadingBuilder_context$,
        Widget loadingBuilder_child$,
        ImageChunkEvent? loadingBuilder_loadingProgress$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            loadingBuilder!,
            [
              loadingBuilder_context$,
              loadingBuilder_child$,
              loadingBuilder_loadingProgress$,
            ],
            {},
          );
      return Image(
        alignment: alignment ?? Alignment.center,
        centerSlice: centerSlice,
        color: color,
        colorBlendMode: colorBlendMode,
        errorBuilder: errorBuilder == null ? null : errorBuilderProxy,
        excludeFromSemantics: excludeFromSemantics ?? false,
        filterQuality: filterQuality ?? FilterQuality.low,
        fit: fit,
        frameBuilder: frameBuilder == null ? null : frameBuilderProxy,
        gaplessPlayback: gaplessPlayback ?? false,
        height: height,
        image: image,
        isAntiAlias: isAntiAlias ?? false,
        key: key,
        loadingBuilder: loadingBuilder == null ? null : loadingBuilderProxy,
        matchTextDirection: matchTextDirection ?? false,
        opacity: opacity,
        repeat: repeat ?? ImageRepeat.noRepeat,
        semanticLabel: semanticLabel,
        width: width,
      );
    };
Function _Image_asset_$(m.Scope scope$) => (
      String name, {
      Key? key,
      AssetBundle? bundle,
      m.FunctionPointer? frameBuilder,
      m.FunctionPointer? errorBuilder,
      String? semanticLabel,
      bool? excludeFromSemantics,
      double? scale,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry? alignment,
      ImageRepeat? repeat,
      Rect? centerSlice,
      bool? matchTextDirection,
      bool? gaplessPlayback,
      bool? isAntiAlias,
      String? package,
      FilterQuality? filterQuality,
      int? cacheWidth,
      int? cacheHeight,
    }) {
      Widget errorBuilderProxy(
        BuildContext errorBuilder_context$,
        Object errorBuilder_error$,
        StackTrace? errorBuilder_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            errorBuilder!,
            [
              errorBuilder_context$,
              errorBuilder_error$,
              errorBuilder_stackTrace$,
            ],
            {},
          );
      Widget frameBuilderProxy(
        BuildContext frameBuilder_context$,
        Widget frameBuilder_child$,
        int? frameBuilder_frame$,
        bool frameBuilder_wasSynchronouslyLoaded$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            frameBuilder!,
            [
              frameBuilder_context$,
              frameBuilder_child$,
              frameBuilder_frame$,
              frameBuilder_wasSynchronouslyLoaded$,
            ],
            {},
          );
      return Image.asset(
        name,
        alignment: alignment ?? Alignment.center,
        bundle: bundle,
        cacheHeight: cacheHeight,
        cacheWidth: cacheWidth,
        centerSlice: centerSlice,
        color: color,
        colorBlendMode: colorBlendMode,
        errorBuilder: errorBuilder == null ? null : errorBuilderProxy,
        excludeFromSemantics: excludeFromSemantics ?? false,
        filterQuality: filterQuality ?? FilterQuality.low,
        fit: fit,
        frameBuilder: frameBuilder == null ? null : frameBuilderProxy,
        gaplessPlayback: gaplessPlayback ?? false,
        height: height,
        isAntiAlias: isAntiAlias ?? false,
        key: key,
        matchTextDirection: matchTextDirection ?? false,
        opacity: opacity,
        package: package,
        repeat: repeat ?? ImageRepeat.noRepeat,
        scale: scale,
        semanticLabel: semanticLabel,
        width: width,
      );
    };
