// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:ui';
import 'dart:async';
import 'dart:collection';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate' show SendPort;
import 'dart:math';
import 'dart:nativewrappers';
import 'dart:typed_data';

const libraryMirror = m.LibraryMirror(
  'dart:ui',
  {
    'Offset.zero': _Offset_zero$,
    'Offset.': _Offset__$,
    'Offset.fromDirection': _Offset_fromDirection_$,
    'Size.': _Size__$,
    'Size.fromHeight': _Size_fromHeight_$,
    'Size.fromRadius': _Size_fromRadius_$,
    'Rect.fromLTRB': _Rect_fromLTRB_$,
    'Rect.fromLTWH': _Rect_fromLTWH_$,
    'Rect.fromCircle': _Rect_fromCircle_$,
    'Rect.fromPoints': _Rect_fromPoints_$,
    'Radius.zero': _Radius_zero$,
    'Radius.circular': _Radius_circular_$,
    'RRect.fromRectAndRadius': _RRect_fromRectAndRadius_$,
    'lerpDouble': _lerpDouble$,
    'Color.': _Color__$,
    'Color.alphaBlend': _Color_alphaBlend$,
    'Paint.': _Paint__$,
    'Path.': _Path__$,
    'Vertices.': _Vertices__$,
    'DisplayFeature.': _DisplayFeature__$,
    'FontWeight.w300': _FontWeight_w300$,
    'FontWeight.w400': _FontWeight_w400$,
    'FontWeight.w500': _FontWeight_w500$,
    'FontWeight.w600': _FontWeight_w600$,
    'FontWeight.w700': _FontWeight_w700$,
    'FontWeight.normal': _FontWeight_normal$,
    'FontWeight.bold': _FontWeight_bold$,
    'Brightness.light': _Brightness_light$,
    'Brightness.dark': _Brightness_dark$,
    'TextDirection.ltr': _TextDirection_ltr$,
    'Clip.antiAlias': _Clip_antiAlias$,
    'TextAlign.end': _TextAlign_end$,
    'TextAlign.center': _TextAlign_center$,
    'Clip.antiAliasWithSaveLayer': _Clip_antiAliasWithSaveLayer$,
  },
  {},
  {
    'Offset': m.ClassMirror(
      'Offset',
      {
        'dx': _Offset_dx$,
        'dy': _Offset_dy$,
        'distance': _Offset_distance$,
        'translate': _Offset_translate$,
        '-': _Offset_minus$$,
        '+': _Offset_plus$$,
        '*': _Offset_times$$,
        '/': _Offset_over$$,
        '&': _Offset_bit_and$$,
      },
      {},
    ),
    'Size': m.ClassMirror(
      'Size',
      {
        'width': _Size_width$,
        'height': _Size_height$,
        'aspectRatio': _Size_aspectRatio$,
        'shortestSide': _Size_shortestSide$,
        'center': _Size_center$,
      },
      {},
    ),
    'Rect': m.ClassMirror(
      'Rect',
      {
        'left': _Rect_left$,
        'top': _Rect_top$,
        'right': _Rect_right$,
        'bottom': _Rect_bottom$,
        'width': _Rect_width$,
        'height': _Rect_height$,
        'size': _Rect_size$,
        'topCenter': _Rect_topCenter$,
        'center': _Rect_center$,
        'translate': _Rect_translate$,
        'overlaps': _Rect_overlaps$,
      },
      {},
    ),
    'RRect': m.ClassMirror(
      'RRect',
      {'middleRect': _RRect_middleRect$},
      {},
    ),
    'Color': m.ClassMirror(
      'Color',
      {
        'value': _Color_value$,
        'withAlpha': _Color_withAlpha$,
        'withOpacity': _Color_withOpacity$,
      },
      {},
    ),
    'Paint': m.ClassMirror(
      'Paint',
      {},
      {
        'color': _Paint_color_set$,
        'style': _Paint_style_set$,
        'strokeWidth': _Paint_strokeWidth_set$,
        'shader': _Paint_shader_set$,
      },
    ),
    'Path': m.ClassMirror(
      'Path',
      {
        'moveTo': _Path_moveTo$,
        'relativeMoveTo': _Path_relativeMoveTo$,
        'lineTo': _Path_lineTo$,
        'quadraticBezierTo': _Path_quadraticBezierTo$,
        'arcTo': _Path_arcTo$,
        'arcToPoint': _Path_arcToPoint$,
        'addRect': _Path_addRect$,
        'addPolygon': _Path_addPolygon$,
        'close': _Path_close$,
      },
      {},
    ),
    'Canvas': m.ClassMirror(
      'Canvas',
      {
        'save': _Canvas_save$,
        'restore': _Canvas_restore$,
        'translate': _Canvas_translate$,
        'rotate': _Canvas_rotate$,
        'drawLine': _Canvas_drawLine$,
        'drawRect': _Canvas_drawRect$,
        'drawRRect': _Canvas_drawRRect$,
        'drawArc': _Canvas_drawArc$,
        'drawPath': _Canvas_drawPath$,
        'drawVertices': _Canvas_drawVertices$,
      },
      {},
    ),
    'DisplayFeature': m.ClassMirror(
      'DisplayFeature',
      {'bounds': _DisplayFeature_bounds$},
      {},
    ),
    'Locale': m.ClassMirror(
      'Locale',
      {'toString': _Locale_toString$},
      {},
    ),
    'TextRange': m.ClassMirror(
      'TextRange',
      {'end': _TextRange_end$},
      {},
    ),
  },
);
Function _Offset_zero$(m.Scope scope$) => () => Offset.zero;
Function _Offset_dx$(
  m.Scope scope$,
  Offset target$,
) =>
    () {
      return target$.dx;
    };
Function _Offset_dy$(
  m.Scope scope$,
  Offset target$,
) =>
    () {
      return target$.dy;
    };
Function _Offset_distance$(
  m.Scope scope$,
  Offset target$,
) =>
    () {
      return target$.distance;
    };
Function _Offset__$(m.Scope scope$) => (
      double dx,
      double dy,
    ) {
      return Offset(
        dx,
        dy,
      );
    };
Function _Offset_fromDirection_$(m.Scope scope$) => Offset.fromDirection;
Function _Offset_translate$(
  m.Scope scope$,
  Offset target$,
) =>
    target$.translate;
Function _Offset_minus$$(
  m.Scope scope$,
  Offset target$,
) =>
    (Offset other$) => target$ - other$;
Function _Offset_plus$$(
  m.Scope scope$,
  Offset target$,
) =>
    (Offset other$) => target$ + other$;
Function _Offset_times$$(
  m.Scope scope$,
  Offset target$,
) =>
    (double other$) => target$ * other$;
Function _Offset_over$$(
  m.Scope scope$,
  Offset target$,
) =>
    (double other$) => target$ / other$;
Function _Offset_bit_and$$(
  m.Scope scope$,
  Offset target$,
) =>
    (Size other$) => target$ & other$;
Function _Size_width$(
  m.Scope scope$,
  Size target$,
) =>
    () {
      return target$.width;
    };
Function _Size_height$(
  m.Scope scope$,
  Size target$,
) =>
    () {
      return target$.height;
    };
Function _Size_aspectRatio$(
  m.Scope scope$,
  Size target$,
) =>
    () {
      return target$.aspectRatio;
    };
Function _Size_shortestSide$(
  m.Scope scope$,
  Size target$,
) =>
    () {
      return target$.shortestSide;
    };
Function _Size__$(m.Scope scope$) => (
      double width,
      double height,
    ) {
      return Size(
        width,
        height,
      );
    };
Function _Size_fromHeight_$(m.Scope scope$) => Size.fromHeight;
Function _Size_fromRadius_$(m.Scope scope$) => Size.fromRadius;
Function _Size_center$(
  m.Scope scope$,
  Size target$,
) =>
    target$.center;
Function _Rect_left$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.left;
    };
Function _Rect_top$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.top;
    };
Function _Rect_right$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.right;
    };
Function _Rect_bottom$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.bottom;
    };
Function _Rect_width$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.width;
    };
Function _Rect_height$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.height;
    };
Function _Rect_size$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.size;
    };
Function _Rect_topCenter$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.topCenter;
    };
Function _Rect_center$(
  m.Scope scope$,
  Rect target$,
) =>
    () {
      return target$.center;
    };
Function _Rect_fromLTRB_$(m.Scope scope$) => Rect.fromLTRB;
Function _Rect_fromLTWH_$(m.Scope scope$) => Rect.fromLTWH;
Function _Rect_fromCircle_$(m.Scope scope$) => Rect.fromCircle;
Function _Rect_fromPoints_$(m.Scope scope$) => Rect.fromPoints;
Function _Rect_translate$(
  m.Scope scope$,
  Rect target$,
) =>
    target$.translate;
Function _Rect_overlaps$(
  m.Scope scope$,
  Rect target$,
) =>
    target$.overlaps;
Function _Radius_zero$(m.Scope scope$) => () => Radius.zero;
Function _Radius_circular_$(m.Scope scope$) => Radius.circular;
Function _RRect_middleRect$(
  m.Scope scope$,
  RRect target$,
) =>
    () {
      return target$.middleRect;
    };
Function _RRect_fromRectAndRadius_$(m.Scope scope$) => RRect.fromRectAndRadius;
Function _lerpDouble$(m.Scope scope$) => lerpDouble;
Function _Color_value$(
  m.Scope scope$,
  Color target$,
) =>
    () {
      return target$.value;
    };
Function _Color__$(m.Scope scope$) => (int value) {
      return Color(value);
    };
Function _Color_withAlpha$(
  m.Scope scope$,
  Color target$,
) =>
    target$.withAlpha;
Function _Color_withOpacity$(
  m.Scope scope$,
  Color target$,
) =>
    target$.withOpacity;
Function _Color_alphaBlend$(m.Scope scope$) => Color.alphaBlend;
void _Paint_color_set$(
  m.Scope scope$,
  Paint target$,
) =>
    (dynamic other$) {
      target$.color = other$;
    };
void _Paint_style_set$(
  m.Scope scope$,
  Paint target$,
) =>
    (dynamic other$) {
      target$.style = other$;
    };
void _Paint_strokeWidth_set$(
  m.Scope scope$,
  Paint target$,
) =>
    (dynamic other$) {
      target$.strokeWidth = other$;
    };
void _Paint_shader_set$(
  m.Scope scope$,
  Paint target$,
) =>
    (dynamic other$) {
      target$.shader = other$;
    };
Function _Paint__$(m.Scope scope$) => () {
      return Paint();
    };
Function _Path__$(m.Scope scope$) => () {
      return Path();
    };
Function _Path_moveTo$(
  m.Scope scope$,
  Path target$,
) =>
    target$.moveTo;
Function _Path_relativeMoveTo$(
  m.Scope scope$,
  Path target$,
) =>
    target$.relativeMoveTo;
Function _Path_lineTo$(
  m.Scope scope$,
  Path target$,
) =>
    target$.lineTo;
Function _Path_quadraticBezierTo$(
  m.Scope scope$,
  Path target$,
) =>
    target$.quadraticBezierTo;
Function _Path_arcTo$(
  m.Scope scope$,
  Path target$,
) =>
    target$.arcTo;
Function _Path_arcToPoint$(
  m.Scope scope$,
  Path target$,
) =>
    target$.arcToPoint;
Function _Path_addRect$(
  m.Scope scope$,
  Path target$,
) =>
    target$.addRect;
Function _Path_addPolygon$(
  m.Scope scope$,
  Path target$,
) =>
    target$.addPolygon;
Function _Path_close$(
  m.Scope scope$,
  Path target$,
) =>
    target$.close;
Function _Vertices__$(m.Scope scope$) => (
      VertexMode mode,
      List positions, {
      List? colors,
      List? textureCoordinates,
      List? indices,
    }) {
      return Vertices(
        mode,
        List.from(positions),
        colors: colors == null ? null : List.from(colors),
        indices: indices == null ? null : List.from(indices),
        textureCoordinates:
            textureCoordinates == null ? null : List.from(textureCoordinates),
      );
    };
Function _Canvas_save$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.save;
Function _Canvas_restore$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.restore;
Function _Canvas_translate$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.translate;
Function _Canvas_rotate$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.rotate;
Function _Canvas_drawLine$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.drawLine;
Function _Canvas_drawRect$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.drawRect;
Function _Canvas_drawRRect$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.drawRRect;
Function _Canvas_drawArc$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.drawArc;
Function _Canvas_drawPath$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.drawPath;
Function _Canvas_drawVertices$(
  m.Scope scope$,
  Canvas target$,
) =>
    target$.drawVertices;
Function _DisplayFeature_bounds$(
  m.Scope scope$,
  DisplayFeature target$,
) =>
    () {
      return target$.bounds;
    };
Function _DisplayFeature__$(m.Scope scope$) => ({
      required Rect bounds,
      required DisplayFeatureType type,
      required DisplayFeatureState state,
    }) {
      return DisplayFeature(
        bounds: bounds,
        state: state,
        type: type,
      );
    };
Function _Locale_toString$(
  m.Scope scope$,
  Locale target$,
) =>
    target$.toString;
Function _FontWeight_w300$(m.Scope scope$) => () => FontWeight.w300;
Function _FontWeight_w400$(m.Scope scope$) => () => FontWeight.w400;
Function _FontWeight_w500$(m.Scope scope$) => () => FontWeight.w500;
Function _FontWeight_w600$(m.Scope scope$) => () => FontWeight.w600;
Function _FontWeight_w700$(m.Scope scope$) => () => FontWeight.w700;
Function _FontWeight_normal$(m.Scope scope$) => () => FontWeight.normal;
Function _FontWeight_bold$(m.Scope scope$) => () => FontWeight.bold;
Function _TextRange_end$(
  m.Scope scope$,
  TextRange target$,
) =>
    () {
      return target$.end;
    };
Function _Brightness_light$(m.Scope scope$) => () => Brightness.light;
Function _Brightness_dark$(m.Scope scope$) => () => Brightness.dark;
Function _TextDirection_ltr$(m.Scope scope$) => () => TextDirection.ltr;
Function _Clip_antiAlias$(m.Scope scope$) => () => Clip.antiAlias;
Function _TextAlign_end$(m.Scope scope$) => () => TextAlign.end;
Function _TextAlign_center$(m.Scope scope$) => () => TextAlign.center;
Function _Clip_antiAliasWithSaveLayer$(m.Scope scope$) =>
    () => Clip.antiAliasWithSaveLayer;
