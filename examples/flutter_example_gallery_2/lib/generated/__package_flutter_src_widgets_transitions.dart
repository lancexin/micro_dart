// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/transitions.dart';
import 'dart:math';
import 'package:flutter/rendering.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/container.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/text.dart';

part '../proxy/proxy__package_flutter_src_widgets_transitions.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/transitions.dart',
  {
    'AnimatedWidget.': _AnimatedWidget__$,
    'SlideTransition.': _SlideTransition__$,
    'ScaleTransition.': _ScaleTransition__$,
    'RotationTransition.': _RotationTransition__$,
    'SizeTransition.': _SizeTransition__$,
    'FadeTransition.': _FadeTransition__$,
    'RelativeRectTween.': _RelativeRectTween__$,
    'PositionedTransition.': _PositionedTransition__$,
    'AnimatedBuilder.': _AnimatedBuilder__$,
  },
  {},
  {
    'AnimatedWidget': m.ClassMirror(
      'AnimatedWidget',
      {'listenable': _AnimatedWidget_listenable$},
      {},
    )
  },
);
Function _AnimatedWidget_listenable$(
  m.Scope scope$,
  AnimatedWidget target$,
) =>
    () {
      return target$.listenable;
    };
Function _SlideTransition__$(m.Scope scope$) => ({
      Key? key,
      required Animation<Offset> position,
      bool? transformHitTests,
      TextDirection? textDirection,
      Widget? child,
    }) {
      return SlideTransition(
        child: child,
        key: key,
        position: position,
        textDirection: textDirection,
        transformHitTests: transformHitTests ?? true,
      );
    };
Function _ScaleTransition__$(m.Scope scope$) => ({
      Key? key,
      required Animation<double> scale,
      Alignment? alignment,
      FilterQuality? filterQuality,
      Widget? child,
    }) {
      return ScaleTransition(
        alignment: alignment ?? Alignment.center,
        child: child,
        filterQuality: filterQuality,
        key: key,
        scale: scale,
      );
    };
Function _RotationTransition__$(m.Scope scope$) => ({
      Key? key,
      required Animation<double> turns,
      Alignment? alignment,
      FilterQuality? filterQuality,
      Widget? child,
    }) {
      return RotationTransition(
        alignment: alignment ?? Alignment.center,
        child: child,
        filterQuality: filterQuality,
        key: key,
        turns: turns,
      );
    };
Function _SizeTransition__$(m.Scope scope$) => ({
      Key? key,
      Axis? axis,
      required Animation<double> sizeFactor,
      double? axisAlignment,
      Widget? child,
    }) {
      return SizeTransition(
        axis: axis ?? Axis.vertical,
        axisAlignment: axisAlignment ?? 0.0,
        child: child,
        key: key,
        sizeFactor: sizeFactor,
      );
    };
Function _FadeTransition__$(m.Scope scope$) => ({
      Key? key,
      required Animation<double> opacity,
      bool? alwaysIncludeSemantics,
      Widget? child,
    }) {
      return FadeTransition(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        child: child,
        key: key,
        opacity: opacity,
      );
    };
Function _RelativeRectTween__$(m.Scope scope$) => ({
      RelativeRect? begin,
      RelativeRect? end,
    }) {
      return RelativeRectTween(
        begin: begin,
        end: end,
      );
    };
Function _PositionedTransition__$(m.Scope scope$) => ({
      Key? key,
      required Animation<RelativeRect> rect,
      required Widget child,
    }) {
      return PositionedTransition(
        child: child,
        key: key,
        rect: rect,
      );
    };
Function _AnimatedBuilder__$(m.Scope scope$) => ({
      Key? key,
      required Listenable animation,
      required m.FunctionPointer builder,
      Widget? child,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        Widget? builder_child$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [
              builder_context$,
              builder_child$,
            ],
            {},
          );
      return AnimatedBuilder(
        animation: animation,
        builder: builderProxy,
        child: child,
        key: key,
      );
    };
