// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/interactive_viewer.dart';
import 'dart:math';
import 'package:flutter/foundation.dart' show clampDouble;
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:vector_math/vector_math_64.dart' show Matrix4, Quad, Vector3;
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';
import 'package:flutter/src/widgets/layout_builder.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/interactive_viewer.dart',
  {
    'InteractiveViewer.': _InteractiveViewer__$,
    'TransformationController.': _TransformationController__$,
  },
  {},
  {
    'TransformationController': m.ClassMirror(
      'TransformationController',
      {'toScene': _TransformationController_toScene$},
      {},
    )
  },
);
Function _InteractiveViewer__$(m.Scope scope$) => ({
      Key? key,
      Clip? clipBehavior,
      bool? alignPanAxis,
      PanAxis? panAxis,
      EdgeInsets? boundaryMargin,
      bool? constrained,
      double? maxScale,
      double? minScale,
      double? interactionEndFrictionCoefficient,
      m.FunctionPointer? onInteractionEnd,
      m.FunctionPointer? onInteractionStart,
      m.FunctionPointer? onInteractionUpdate,
      bool? panEnabled,
      bool? scaleEnabled,
      double? scaleFactor,
      TransformationController? transformationController,
      Alignment? alignment,
      bool? trackpadScrollCausesScale,
      required Widget child,
    }) {
      void onInteractionEndProxy(ScaleEndDetails onInteractionEnd_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionEnd!,
            [onInteractionEnd_details$],
            {},
          );
      void onInteractionStartProxy(
              ScaleStartDetails onInteractionStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionStart!,
            [onInteractionStart_details$],
            {},
          );
      void onInteractionUpdateProxy(
              ScaleUpdateDetails onInteractionUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionUpdate!,
            [onInteractionUpdate_details$],
            {},
          );
      return InteractiveViewer(
        alignPanAxis: alignPanAxis ?? false,
        alignment: alignment,
        boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
        child: child,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        constrained: constrained ?? true,
        interactionEndFrictionCoefficient:
            interactionEndFrictionCoefficient ?? 0.0000135,
        key: key,
        maxScale: maxScale ?? 2.5,
        minScale: minScale ?? 0.8,
        onInteractionEnd:
            onInteractionEnd == null ? null : onInteractionEndProxy,
        onInteractionStart:
            onInteractionStart == null ? null : onInteractionStartProxy,
        onInteractionUpdate:
            onInteractionUpdate == null ? null : onInteractionUpdateProxy,
        panAxis: panAxis ?? PanAxis.free,
        panEnabled: panEnabled ?? true,
        scaleEnabled: scaleEnabled ?? true,
        scaleFactor: scaleFactor ?? kDefaultMouseScrollToScaleFactor,
        trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
        transformationController: transformationController,
      );
    };
Function _TransformationController__$(m.Scope scope$) => ([Matrix4? value]) {
      if (value == null) {
        return TransformationController();
      }
      return TransformationController(value!);
    };
Function _TransformationController_toScene$(
  m.Scope scope$,
  TransformationController target$,
) =>
    target$.toScene;
