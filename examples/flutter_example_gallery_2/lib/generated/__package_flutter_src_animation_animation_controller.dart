// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/animation/animation_controller.dart';
import 'dart:ui' show lerpDouble;
import 'package:flutter/foundation.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/animation/curves.dart';
import 'package:flutter/src/animation/listener_helpers.dart';

part '../proxy/proxy__package_flutter_src_animation_animation_controller.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/animation/animation_controller.dart',
  {'AnimationController.': _AnimationController__$},
  {},
  {
    ...proxyClassMirrors,
    'AnimationController': m.ClassMirror(
      'AnimationController',
      {
        'view': _AnimationController_view$,
        'value': _AnimationController_value$,
        'isAnimating': _AnimationController_isAnimating$,
        'status': _AnimationController_status$,
        'reset': _AnimationController_reset$,
        'forward': _AnimationController_forward$,
        'reverse': _AnimationController_reverse$,
        'animateTo': _AnimationController_animateTo$,
        'fling': _AnimationController_fling$,
        'stop': _AnimationController_stop$,
        'dispose': _AnimationController_dispose$,
      },
      {'value': _AnimationController_value_set$},
    )
  },
);
Function _AnimationController_view$(
  m.Scope scope$,
  AnimationController target$,
) =>
    () {
      return target$.view;
    };
Function _AnimationController_value$(
  m.Scope scope$,
  AnimationController target$,
) =>
    () {
      return target$.value;
    };
void _AnimationController_value_set$(
  m.Scope scope$,
  AnimationController target$,
) =>
    (dynamic other$) {
      target$.value = other$;
    };
Function _AnimationController_isAnimating$(
  m.Scope scope$,
  AnimationController target$,
) =>
    () {
      return target$.isAnimating;
    };
Function _AnimationController_status$(
  m.Scope scope$,
  AnimationController target$,
) =>
    () {
      return target$.status;
    };
Function _AnimationController__$(m.Scope scope$) => ({
      double? value,
      Duration? duration,
      Duration? reverseDuration,
      String? debugLabel,
      double? lowerBound,
      double? upperBound,
      AnimationBehavior? animationBehavior,
      required TickerProvider vsync,
    }) {
      return AnimationController(
        animationBehavior: animationBehavior ?? AnimationBehavior.normal,
        debugLabel: debugLabel,
        duration: duration,
        lowerBound: lowerBound ?? 0.0,
        reverseDuration: reverseDuration,
        upperBound: upperBound ?? 1.0,
        value: value,
        vsync: vsync,
      );
    };
Function _AnimationController_reset$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.reset;
Function _AnimationController_forward$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.forward;
Function _AnimationController_reverse$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.reverse;
Function _AnimationController_animateTo$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.animateTo;
Function _AnimationController_fling$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.fling;
Function _AnimationController_stop$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.stop;
Function _AnimationController_dispose$(
  m.Scope scope$,
  AnimationController target$,
) =>
    target$.dispose;
