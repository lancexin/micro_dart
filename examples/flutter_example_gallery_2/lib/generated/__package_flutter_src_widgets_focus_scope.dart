// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:flutter/widgets.dart';
import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/focus_scope.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/focus_manager.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/inherited_notifier.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/focus_scope.dart',
  {
    'Focus.': _Focus__$,
    'FocusScope.': _FocusScope__$,
    'ExcludeFocus.': _ExcludeFocus__$,
  },
  {},
  {},
);
Function _Focus__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      FocusNode? focusNode,
      FocusNode? parentNode,
      bool? autofocus,
      m.FunctionPointer? onFocusChange,
      m.FunctionPointer? onKeyEvent,
      m.FunctionPointer? onKey,
      bool? canRequestFocus,
      bool? skipTraversal,
      bool? descendantsAreFocusable,
      bool? descendantsAreTraversable,
      bool? includeSemantics,
      String? debugLabel,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      KeyEventResult onKeyProxy(
        FocusNode onKey_node$,
        RawKeyEvent onKey_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKey!,
            [
              onKey_node$,
              onKey_event$,
            ],
            {},
          );
      KeyEventResult onKeyEventProxy(
        FocusNode onKeyEvent_node$,
        KeyEvent onKeyEvent_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKeyEvent!,
            [
              onKeyEvent_node$,
              onKeyEvent_event$,
            ],
            {},
          );
      return Focus(
        autofocus: autofocus ?? false,
        canRequestFocus: canRequestFocus,
        child: child,
        debugLabel: debugLabel,
        descendantsAreFocusable: descendantsAreFocusable,
        descendantsAreTraversable: descendantsAreTraversable,
        focusNode: focusNode,
        includeSemantics: includeSemantics ?? true,
        key: key,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onKey: onKey == null ? null : onKeyProxy,
        onKeyEvent: onKeyEvent == null ? null : onKeyEventProxy,
        parentNode: parentNode,
        skipTraversal: skipTraversal,
      );
    };
Function _FocusScope__$(m.Scope scope$) => ({
      Key? key,
      FocusScopeNode? node,
      FocusNode? parentNode,
      required Widget child,
      bool? autofocus,
      m.FunctionPointer? onFocusChange,
      bool? canRequestFocus,
      bool? skipTraversal,
      m.FunctionPointer? onKeyEvent,
      m.FunctionPointer? onKey,
      String? debugLabel,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      KeyEventResult onKeyProxy(
        FocusNode onKey_node$,
        RawKeyEvent onKey_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKey!,
            [
              onKey_node$,
              onKey_event$,
            ],
            {},
          );
      KeyEventResult onKeyEventProxy(
        FocusNode onKeyEvent_node$,
        KeyEvent onKeyEvent_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKeyEvent!,
            [
              onKeyEvent_node$,
              onKeyEvent_event$,
            ],
            {},
          );
      return FocusScope(
        autofocus: autofocus ?? false,
        canRequestFocus: canRequestFocus,
        child: child,
        debugLabel: debugLabel,
        key: key,
        node: node,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onKey: onKey == null ? null : onKeyProxy,
        onKeyEvent: onKeyEvent == null ? null : onKeyEventProxy,
        parentNode: parentNode,
        skipTraversal: skipTraversal,
      );
    };
Function _ExcludeFocus__$(m.Scope scope$) => ({
      Key? key,
      bool? excluding,
      required Widget child,
    }) {
      return ExcludeFocus(
        child: child,
        excluding: excluding ?? true,
        key: key,
      );
    };
