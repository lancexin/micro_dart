// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:material_color_utilities/quantize/quantizer_wu.dart';
import 'package:material_color_utilities/utils/color_utils.dart';
import 'package:material_color_utilities/quantize/quantizer.dart';
import 'package:material_color_utilities/quantize/quantizer_map.dart';

const libraryMirror = m.LibraryMirror(
  'package:material_color_utilities/quantize/quantizer_wu.dart',
  {
    'QuantizerWu.indexBits': _QuantizerWu_indexBits$,
    'QuantizerWu.maxIndex': _QuantizerWu_maxIndex$,
    'QuantizerWu.sideLength': _QuantizerWu_sideLength$,
    'QuantizerWu.totalSize': _QuantizerWu_totalSize$,
    'QuantizerWu.': _QuantizerWu__$,
    'QuantizerWu.getIndex': _QuantizerWu_getIndex$,
    'QuantizerWu.volume': _QuantizerWu_volume$,
    'QuantizerWu.bottom': _QuantizerWu_bottom$,
    'QuantizerWu.top': _QuantizerWu_top$,
    'MaximizeResult.': _MaximizeResult__$,
    'CreateBoxesResult.': _CreateBoxesResult__$,
    'Box.': _Box__$,
    'Direction.red': _Direction_red$,
    'Direction.green': _Direction_green$,
    'Direction.blue': _Direction_blue$,
    'Direction.values': _Direction_values$,
  },
  {},
  {
    'QuantizerWu': m.ClassMirror(
      'QuantizerWu',
      {
        '#as': QuantizerWu_as$,
        '#is': QuantizerWu_is$,
        'weights': _QuantizerWu_weights$,
        'momentsR': _QuantizerWu_momentsR$,
        'momentsG': _QuantizerWu_momentsG$,
        'momentsB': _QuantizerWu_momentsB$,
        'moments': _QuantizerWu_moments$,
        'cubes': _QuantizerWu_cubes$,
        'quantize': _QuantizerWu_quantize$,
        'constructHistogram': _QuantizerWu_constructHistogram$,
        'computeMoments': _QuantizerWu_computeMoments$,
        'createBoxes': _QuantizerWu_createBoxes$,
        'createResult': _QuantizerWu_createResult$,
        'variance': _QuantizerWu_variance$,
        'cut': _QuantizerWu_cut$,
        'maximize': _QuantizerWu_maximize$,
      },
      {
        'weights': _QuantizerWu_weights_set$,
        'momentsR': _QuantizerWu_momentsR_set$,
        'momentsG': _QuantizerWu_momentsG_set$,
        'momentsB': _QuantizerWu_momentsB_set$,
        'moments': _QuantizerWu_moments_set$,
        'cubes': _QuantizerWu_cubes_set$,
      },
    ),
    'MaximizeResult': m.ClassMirror(
      'MaximizeResult',
      {
        '#as': MaximizeResult_as$,
        '#is': MaximizeResult_is$,
        'cutLocation': _MaximizeResult_cutLocation$,
        'maximum': _MaximizeResult_maximum$,
      },
      {
        'cutLocation': _MaximizeResult_cutLocation_set$,
        'maximum': _MaximizeResult_maximum_set$,
      },
    ),
    'CreateBoxesResult': m.ClassMirror(
      'CreateBoxesResult',
      {
        '#as': CreateBoxesResult_as$,
        '#is': CreateBoxesResult_is$,
        'requestedCount': _CreateBoxesResult_requestedCount$,
        'resultCount': _CreateBoxesResult_resultCount$,
      },
      {
        'requestedCount': _CreateBoxesResult_requestedCount_set$,
        'resultCount': _CreateBoxesResult_resultCount_set$,
      },
    ),
    'Box': m.ClassMirror(
      'Box',
      {
        '#as': Box_as$,
        '#is': Box_is$,
        'r0': _Box_r0$,
        'r1': _Box_r1$,
        'g0': _Box_g0$,
        'g1': _Box_g1$,
        'b0': _Box_b0$,
        'b1': _Box_b1$,
        'vol': _Box_vol$,
        'toString': _Box_toString$,
      },
      {
        'r0': _Box_r0_set$,
        'r1': _Box_r1_set$,
        'g0': _Box_g0_set$,
        'g1': _Box_g1_set$,
        'b0': _Box_b0_set$,
        'b1': _Box_b1_set$,
        'vol': _Box_vol_set$,
      },
    ),
    'Direction': m.ClassMirror(
      'Direction',
      {},
      {},
    ),
  },
);
Function QuantizerWu_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as QuantizerWu;
Function QuantizerWu_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is QuantizerWu;
Function _QuantizerWu_weights$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    () {
      return target$.weights;
    };
void _QuantizerWu_weights_set$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    (dynamic other$) {
      target$.weights = other$;
    };
Function _QuantizerWu_momentsR$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    () {
      return target$.momentsR;
    };
void _QuantizerWu_momentsR_set$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    (dynamic other$) {
      target$.momentsR = other$;
    };
Function _QuantizerWu_momentsG$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    () {
      return target$.momentsG;
    };
void _QuantizerWu_momentsG_set$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    (dynamic other$) {
      target$.momentsG = other$;
    };
Function _QuantizerWu_momentsB$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    () {
      return target$.momentsB;
    };
void _QuantizerWu_momentsB_set$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    (dynamic other$) {
      target$.momentsB = other$;
    };
Function _QuantizerWu_moments$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    () {
      return target$.moments;
    };
void _QuantizerWu_moments_set$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    (dynamic other$) {
      target$.moments = other$;
    };
Function _QuantizerWu_cubes$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    () {
      return target$.cubes;
    };
void _QuantizerWu_cubes_set$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    (dynamic other$) {
      target$.cubes = other$;
    };
Function _QuantizerWu_indexBits$(m.Scope scope$) => () => QuantizerWu.indexBits;
Function _QuantizerWu_maxIndex$(m.Scope scope$) => () => QuantizerWu.maxIndex;
Function _QuantizerWu_sideLength$(m.Scope scope$) =>
    () => QuantizerWu.sideLength;
Function _QuantizerWu_totalSize$(m.Scope scope$) => () => QuantizerWu.totalSize;
Function _QuantizerWu__$(m.Scope scope$) => () {
      return QuantizerWu();
    };
Function _QuantizerWu_quantize$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.quantize;
Function _QuantizerWu_getIndex$(m.Scope scope$) => QuantizerWu.getIndex;
Function _QuantizerWu_constructHistogram$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.constructHistogram;
Function _QuantizerWu_computeMoments$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.computeMoments;
Function _QuantizerWu_createBoxes$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.createBoxes;
Function _QuantizerWu_createResult$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.createResult;
Function _QuantizerWu_variance$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.variance;
Function _QuantizerWu_cut$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.cut;
Function _QuantizerWu_maximize$(
  m.Scope scope$,
  QuantizerWu target$,
) =>
    target$.maximize;
Function _QuantizerWu_volume$(m.Scope scope$) => QuantizerWu.volume;
Function _QuantizerWu_bottom$(m.Scope scope$) => QuantizerWu.bottom;
Function _QuantizerWu_top$(m.Scope scope$) => QuantizerWu.top;
Function MaximizeResult_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MaximizeResult;
Function MaximizeResult_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MaximizeResult;
Function _MaximizeResult_cutLocation$(
  m.Scope scope$,
  MaximizeResult target$,
) =>
    () {
      return target$.cutLocation;
    };
void _MaximizeResult_cutLocation_set$(
  m.Scope scope$,
  MaximizeResult target$,
) =>
    (dynamic other$) {
      target$.cutLocation = other$;
    };
Function _MaximizeResult_maximum$(
  m.Scope scope$,
  MaximizeResult target$,
) =>
    () {
      return target$.maximum;
    };
void _MaximizeResult_maximum_set$(
  m.Scope scope$,
  MaximizeResult target$,
) =>
    (dynamic other$) {
      target$.maximum = other$;
    };
Function _MaximizeResult__$(m.Scope scope$) => ({
      required int cutLocation,
      required double maximum,
    }) {
      return MaximizeResult(
        cutLocation: cutLocation,
        maximum: maximum,
      );
    };
Function CreateBoxesResult_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CreateBoxesResult;
Function CreateBoxesResult_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CreateBoxesResult;
Function _CreateBoxesResult_requestedCount$(
  m.Scope scope$,
  CreateBoxesResult target$,
) =>
    () {
      return target$.requestedCount;
    };
void _CreateBoxesResult_requestedCount_set$(
  m.Scope scope$,
  CreateBoxesResult target$,
) =>
    (dynamic other$) {
      target$.requestedCount = other$;
    };
Function _CreateBoxesResult_resultCount$(
  m.Scope scope$,
  CreateBoxesResult target$,
) =>
    () {
      return target$.resultCount;
    };
void _CreateBoxesResult_resultCount_set$(
  m.Scope scope$,
  CreateBoxesResult target$,
) =>
    (dynamic other$) {
      target$.resultCount = other$;
    };
Function _CreateBoxesResult__$(m.Scope scope$) => ({
      required int requestedCount,
      required int resultCount,
    }) {
      return CreateBoxesResult(
        requestedCount: requestedCount,
        resultCount: resultCount,
      );
    };
Function Box_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Box;
Function Box_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Box;
Function _Box_r0$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.r0;
    };
void _Box_r0_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.r0 = other$;
    };
Function _Box_r1$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.r1;
    };
void _Box_r1_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.r1 = other$;
    };
Function _Box_g0$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.g0;
    };
void _Box_g0_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.g0 = other$;
    };
Function _Box_g1$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.g1;
    };
void _Box_g1_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.g1 = other$;
    };
Function _Box_b0$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.b0;
    };
void _Box_b0_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.b0 = other$;
    };
Function _Box_b1$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.b1;
    };
void _Box_b1_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.b1 = other$;
    };
Function _Box_vol$(
  m.Scope scope$,
  Box target$,
) =>
    () {
      return target$.vol;
    };
void _Box_vol_set$(
  m.Scope scope$,
  Box target$,
) =>
    (dynamic other$) {
      target$.vol = other$;
    };
Function _Box__$(m.Scope scope$) => ({
      int? r0,
      int? r1,
      int? g0,
      int? g1,
      int? b0,
      int? b1,
      int? vol,
    }) {
      return Box(
        b0: b0 ?? 0,
        b1: b1 ?? 0,
        g0: g0 ?? 0,
        g1: g1 ?? 0,
        r0: r0 ?? 0,
        r1: r1 ?? 0,
        vol: vol ?? 0,
      );
    };
Function _Box_toString$(
  m.Scope scope$,
  Box target$,
) =>
    target$.toString;
Function _Direction_red$(m.Scope scope$) => () => Direction.red;
Function _Direction_green$(m.Scope scope$) => () => Direction.green;
Function _Direction_blue$(m.Scope scope$) => () => Direction.blue;
Function _Direction_values$(m.Scope scope$) => () => Direction.values;
