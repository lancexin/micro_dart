// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:collection/src/empty_unmodifiable_set.dart';
import 'dart:collection';
import 'package:collection/src/unmodifiable_wrappers.dart';
import 'package:collection/src/wrappers.dart';

const libraryMirror = m.LibraryMirror(
  'package:collection/src/empty_unmodifiable_set.dart',
  {'EmptyUnmodifiableSet.': _EmptyUnmodifiableSet__$},
  {},
  {
    'EmptyUnmodifiableSet': m.ClassMirror(
      'EmptyUnmodifiableSet',
      {
        '#as': EmptyUnmodifiableSet_as$,
        '#is': EmptyUnmodifiableSet_is$,
        'iterator': _EmptyUnmodifiableSet_iterator$,
        'length': _EmptyUnmodifiableSet_length$,
        'cast': _EmptyUnmodifiableSet_cast$,
        'contains': _EmptyUnmodifiableSet_contains$,
        'containsAll': _EmptyUnmodifiableSet_containsAll$,
        'followedBy': _EmptyUnmodifiableSet_followedBy$,
        'lookup': _EmptyUnmodifiableSet_lookup$,
        'singleWhere': _EmptyUnmodifiableSet_singleWhere$,
        'whereType': _EmptyUnmodifiableSet_whereType$,
        'toSet': _EmptyUnmodifiableSet_toSet$,
        'union': _EmptyUnmodifiableSet_union$,
        'intersection': _EmptyUnmodifiableSet_intersection$,
        'difference': _EmptyUnmodifiableSet_difference$,
      },
      {},
    )
  },
);
Function EmptyUnmodifiableSet_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as EmptyUnmodifiableSet<E>;
Function EmptyUnmodifiableSet_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is EmptyUnmodifiableSet<E>;
Function _EmptyUnmodifiableSet_iterator$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _EmptyUnmodifiableSet_length$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    () {
      return target$.length;
    };
Function _EmptyUnmodifiableSet__$(m.Scope scope$) => () {
      return EmptyUnmodifiableSet();
    };
Function _EmptyUnmodifiableSet_cast$<E, T>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.cast<T>;
Function _EmptyUnmodifiableSet_contains$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.contains;
Function _EmptyUnmodifiableSet_containsAll$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.containsAll;
Function _EmptyUnmodifiableSet_followedBy$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.followedBy;
Function _EmptyUnmodifiableSet_lookup$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.lookup;
Function _EmptyUnmodifiableSet_singleWhere$(
  m.Scope scope$,
  EmptyUnmodifiableSet target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic test_$p0$) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [test_$p0$],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.singleWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _EmptyUnmodifiableSet_whereType$<E, T>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.whereType<T>;
Function _EmptyUnmodifiableSet_toSet$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.toSet;
Function _EmptyUnmodifiableSet_union$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.union;
Function _EmptyUnmodifiableSet_intersection$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.intersection;
Function _EmptyUnmodifiableSet_difference$<E>(
  m.Scope scope$,
  EmptyUnmodifiableSet<E> target$,
) =>
    target$.difference;
