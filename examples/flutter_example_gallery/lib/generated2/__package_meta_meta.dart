// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:meta/meta.dart';
import 'package:meta/meta_meta.dart';

const libraryMirror = m.LibraryMirror(
  'package:meta/meta.dart',
  {
    'alwaysThrows': _alwaysThrows$,
    'checked': _checked$,
    'doNotStore': _doNotStore$,
    'experimental': _experimental$,
    'factory': _factory$,
    'immutable': _immutable$,
    'internal': _internal$,
    'isTest': _isTest$,
    'isTestGroup': _isTestGroup$,
    'literal': _literal$,
    'mustBeOverridden': _mustBeOverridden$,
    'mustCallSuper': _mustCallSuper$,
    'nonVirtual': _nonVirtual$,
    'optionalTypeArgs': _optionalTypeArgs$,
    'protected': _protected$,
    'reopen': _reopen$,
    'required': _required$,
    'sealed': _sealed$,
    'useResult': _useResult$,
    'virtual': _virtual$,
    'visibleForOverriding': _visibleForOverriding$,
    'visibleForTesting': _visibleForTesting$,
    'Immutable.': _Immutable__$,
    'Required.': _Required__$,
    'UseResult.': _UseResult__$,
    'UseResult.unless': _UseResult_unless_$,
  },
  {},
  {
    'Immutable': m.ClassMirror(
      'Immutable',
      {
        '#as': Immutable_as$,
        '#is': Immutable_is$,
        'reason': _Immutable_reason$,
      },
      {},
    ),
    'Required': m.ClassMirror(
      'Required',
      {
        '#as': Required_as$,
        '#is': Required_is$,
        'reason': _Required_reason$,
      },
      {},
    ),
    'UseResult': m.ClassMirror(
      'UseResult',
      {
        '#as': UseResult_as$,
        '#is': UseResult_is$,
        'reason': _UseResult_reason$,
        'parameterDefined': _UseResult_parameterDefined$,
      },
      {},
    ),
  },
);
Function _alwaysThrows$(m.Scope scope$) => () => alwaysThrows;
Function _checked$(m.Scope scope$) => () => checked;
Function _doNotStore$(m.Scope scope$) => () => doNotStore;
Function _experimental$(m.Scope scope$) => () => experimental;
Function _factory$(m.Scope scope$) => () => factory;
Function _immutable$(m.Scope scope$) => () => immutable;
Function _internal$(m.Scope scope$) => () => internal;
Function _isTest$(m.Scope scope$) => () => isTest;
Function _isTestGroup$(m.Scope scope$) => () => isTestGroup;
Function _literal$(m.Scope scope$) => () => literal;
Function _mustBeOverridden$(m.Scope scope$) => () => mustBeOverridden;
Function _mustCallSuper$(m.Scope scope$) => () => mustCallSuper;
Function _nonVirtual$(m.Scope scope$) => () => nonVirtual;
Function _optionalTypeArgs$(m.Scope scope$) => () => optionalTypeArgs;
Function _protected$(m.Scope scope$) => () => protected;
Function _reopen$(m.Scope scope$) => () => reopen;
Function _required$(m.Scope scope$) => () => required;
Function _sealed$(m.Scope scope$) => () => sealed;
Function _useResult$(m.Scope scope$) => () => useResult;
Function _virtual$(m.Scope scope$) => () => virtual;
Function _visibleForOverriding$(m.Scope scope$) => () => visibleForOverriding;
Function _visibleForTesting$(m.Scope scope$) => () => visibleForTesting;
Function Immutable_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Immutable;
Function Immutable_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Immutable;
Function _Immutable_reason$(
  m.Scope scope$,
  Immutable target$,
) =>
    () {
      return target$.reason;
    };
Function _Immutable__$(m.Scope scope$) => ([String? reason]) {
      if (reason == null) {
        return Immutable();
      }
      return Immutable(reason!);
    };
Function Required_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Required;
Function Required_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Required;
Function _Required_reason$(
  m.Scope scope$,
  Required target$,
) =>
    () {
      return target$.reason;
    };
Function _Required__$(m.Scope scope$) => ([String? reason]) {
      if (reason == null) {
        return Required();
      }
      return Required(reason!);
    };
Function UseResult_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UseResult;
Function UseResult_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UseResult;
Function _UseResult_reason$(
  m.Scope scope$,
  UseResult target$,
) =>
    () {
      return target$.reason;
    };
Function _UseResult_parameterDefined$(
  m.Scope scope$,
  UseResult target$,
) =>
    () {
      return target$.parameterDefined;
    };
Function _UseResult__$(m.Scope scope$) => ([String? reason]) {
      if (reason == null) {
        return UseResult();
      }
      return UseResult(reason!);
    };
Function _UseResult_unless_$(m.Scope scope$) => UseResult.unless;
