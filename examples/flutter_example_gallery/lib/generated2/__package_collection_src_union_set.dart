// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:collection/src/union_set.dart';
import 'dart:collection';
import 'package:collection/src/unmodifiable_wrappers.dart';

const libraryMirror = m.LibraryMirror(
  'package:collection/src/union_set.dart',
  {
    'UnionSet.': _UnionSet__$,
    'UnionSet.from': _UnionSet_from_$,
  },
  {},
  {
    'UnionSet': m.ClassMirror(
      'UnionSet',
      {
        '#as': UnionSet_as$,
        '#is': UnionSet_is$,
        'length': _UnionSet_length$,
        'iterator': _UnionSet_iterator$,
        'contains': _UnionSet_contains$,
        'lookup': _UnionSet_lookup$,
        'toSet': _UnionSet_toSet$,
      },
      {},
    )
  },
);
Function UnionSet_as$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnionSet<E>;
Function UnionSet_is$<E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnionSet<E>;
Function _UnionSet_length$<E>(
  m.Scope scope$,
  UnionSet<E> target$,
) =>
    () {
      return target$.length;
    };
Function _UnionSet_iterator$<E>(
  m.Scope scope$,
  UnionSet<E> target$,
) =>
    () {
      return target$.iterator;
    };
Function _UnionSet__$(m.Scope scope$) => (
      Set sets, {
      bool? disjoint,
    }) {
      return UnionSet(
        Set.from(sets),
        disjoint: disjoint ?? false,
      );
    };
Function _UnionSet_from_$(m.Scope scope$) => UnionSet.from;
Function _UnionSet_contains$<E>(
  m.Scope scope$,
  UnionSet<E> target$,
) =>
    target$.contains;
Function _UnionSet_lookup$<E>(
  m.Scope scope$,
  UnionSet<E> target$,
) =>
    target$.lookup;
Function _UnionSet_toSet$<E>(
  m.Scope scope$,
  UnionSet<E> target$,
) =>
    target$.toSet;
