// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:material_color_utilities/quantize/quantizer_wsmeans.dart';
import 'dart:math' show Random, min;
import 'package:material_color_utilities/quantize/point_provider.dart';
import 'package:material_color_utilities/quantize/point_provider_lab.dart';
import 'package:material_color_utilities/quantize/quantizer.dart';

const libraryMirror = m.LibraryMirror(
  'package:material_color_utilities/quantize/quantizer_wsmeans.dart',
  {
    'DistanceAndIndex.': _DistanceAndIndex__$,
    'QuantizerWsmeans.debug': _QuantizerWsmeans_debug$,
    'QuantizerWsmeans.': _QuantizerWsmeans__$,
    'QuantizerWsmeans.debugLog': _QuantizerWsmeans_debugLog$,
    'QuantizerWsmeans.quantize': _QuantizerWsmeans_quantize$,
  },
  {},
  {
    'DistanceAndIndex': m.ClassMirror(
      'DistanceAndIndex',
      {
        '#as': DistanceAndIndex_as$,
        '#is': DistanceAndIndex_is$,
        'distance': _DistanceAndIndex_distance$,
        'index': _DistanceAndIndex_index$,
        'compareTo': _DistanceAndIndex_compareTo$,
      },
      {
        'distance': _DistanceAndIndex_distance_set$,
        'index': _DistanceAndIndex_index_set$,
      },
    ),
    'QuantizerWsmeans': m.ClassMirror(
      'QuantizerWsmeans',
      {
        '#as': QuantizerWsmeans_as$,
        '#is': QuantizerWsmeans_is$,
      },
      {},
    ),
  },
);
Function DistanceAndIndex_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DistanceAndIndex;
Function DistanceAndIndex_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DistanceAndIndex;
Function _DistanceAndIndex_distance$(
  m.Scope scope$,
  DistanceAndIndex target$,
) =>
    () {
      return target$.distance;
    };
void _DistanceAndIndex_distance_set$(
  m.Scope scope$,
  DistanceAndIndex target$,
) =>
    (dynamic other$) {
      target$.distance = other$;
    };
Function _DistanceAndIndex_index$(
  m.Scope scope$,
  DistanceAndIndex target$,
) =>
    () {
      return target$.index;
    };
void _DistanceAndIndex_index_set$(
  m.Scope scope$,
  DistanceAndIndex target$,
) =>
    (dynamic other$) {
      target$.index = other$;
    };
Function _DistanceAndIndex__$(m.Scope scope$) => (
      double distance,
      int index,
    ) {
      return DistanceAndIndex(
        distance,
        index,
      );
    };
Function _DistanceAndIndex_compareTo$(
  m.Scope scope$,
  DistanceAndIndex target$,
) =>
    target$.compareTo;
Function QuantizerWsmeans_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as QuantizerWsmeans;
Function QuantizerWsmeans_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is QuantizerWsmeans;
Function _QuantizerWsmeans_debug$(m.Scope scope$) =>
    () => QuantizerWsmeans.debug;
Function _QuantizerWsmeans__$(m.Scope scope$) => () {
      return QuantizerWsmeans();
    };
Function _QuantizerWsmeans_debugLog$(m.Scope scope$) =>
    QuantizerWsmeans.debugLog;
Function _QuantizerWsmeans_quantize$(m.Scope scope$) =>
    QuantizerWsmeans.quantize;
