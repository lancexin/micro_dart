import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:code_builder/code_builder.dart' as cb;
import 'package:dart_style/dart_style.dart';

import 'abs_visotor.dart';
import 'code_gen_utils.dart';
import 'namedsystem.dart';
import 'overwrite_strategy.dart';
import 'extenation.dart';

class ClassItem {
  final String name;

  ClassItem(this.name);
  Map<String, cb.Expression> proxyGetterList = {};
  Map<String, cb.Expression> proxySetterList = {};
}

class CodeGenMirror extends AbsVisitor {
  final OverwriteStrategy overwriteStrategy;
  final NamedSystem namedSystem;
  final dartFormatter = DartFormatter();
  final dartEmitter = cb.DartEmitter();

  final Set<cb.Directive> importList = {};
  final Map<String, ClassItem> proxyClassList = {};
  final Map<String, cb.Expression> proxyGlobalGetterList = {};
  final Map<String, cb.Expression> proxyGlobalSetterList = {};

  final Set<cb.Method> proxyGlobalMethods = {};

  String? libraryName;

  CodeGenMirror(this.namedSystem, this.overwriteStrategy);

  String generate() {
    List<cb.Expression> posational = [];
    posational.add(cb.literalString(libraryName!));
    posational.add(cb.literalMap(proxyGlobalGetterList));
    posational.add(cb.literalMap(proxyGlobalSetterList));
    posational.add(
        cb.literalMap(proxyClassList.map<String, cb.Expression>((key, value) {
      List<cb.Expression> posational = [];
      posational.add(cb.literalString(key));
      posational.add(cb.literalMap(value.proxyGetterList));
      posational.add(cb.literalMap(value.proxySetterList));
      return MapEntry(key, cb.refer("m.ClassMirror").call(posational));
    })));
    var library = cb.Library((p0) => p0
      ..comments.add("generated by micro_dart_generator")
      ..comments.add("ignore_for_file: non_constant_identifier_names")
      ..directives.add(cb.Directive.import(
          "package:micro_dart_runtime/micro_dart_runtime.dart",
          as: "m"))
      ..directives.addAll(importList)
      ..body.add(cb.Field((p0) => p0
        ..name = 'libraryMirror'
        ..modifier = cb.FieldModifier.constant
        ..assignment = cb.refer("m.LibraryMirror").call(posational).code))
      ..body.addAll(proxyGlobalMethods));

    try {
      return dartFormatter.format(library.accept(dartEmitter).toString());
    } catch (e, s) {
      print("$e  $s");
      return library.accept(dartEmitter).toString();
    }
    //return dartFormatter.format(library.accept(dartEmitter).toString());
  }

  @override
  void visitLibraryElement(LibraryElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.identifier)) {
      return;
    }

    namedSystem.getLibraryName(element.identifier);
    libraryName = element.identifier;
    if (!namedSystem.isCoreLibrary(element.identifier)) {
      importList.add(cb.Directive.import(element.identifier));
    }
    overwriteStrategy.libraryAddImports[element.identifier]?.forEach((element) {
      importList.add(cb.Directive.import(element[0],
          show: List<String>.from(element[1]),
          hide: List<String>.from(element[2])));
    });
    element.visitChildren(this);
  }

  @override
  void visitLibraryImportElement(LibraryImportElement element) {
    if (element.importedLibrary == null) {
      return;
    }
    if (element.importedLibrary!.identifier.startsWith("dart:_") ||
        element.importedLibrary!.identifier.startsWith("package:_")) {
      return;
    }

    if (overwriteStrategy.libraryIngoreImports[element.library.identifier]
            ?.contains(element.importedLibrary!.identifier) ??
        false) {
      return;
    }

    if (!namedSystem.isCoreLibrary(element.importedLibrary!.identifier)) {
      Set<String> showlist = {};
      Set<String> hidelist = {};
      for (var element in element.combinators) {
        if (element is ShowElementCombinator) {
          showlist.addAll(element.shownNames);
        } else if (element is HideElementCombinator) {
          hidelist.addAll(element.hiddenNames);
        }
      }

      importList.add(cb.Directive.import(element.importedLibrary!.identifier,
          show: showlist.toList(), hide: hidelist.toList()));
    }
  }

  @override
  void visitConstructorElement(ConstructorElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }
  }

  @override
  void visitEnumElement(EnumElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }
    proxyClassList[element.displayName] = ClassItem(element.displayName);
    element.visitChildren(this);
  }

  @override
  void visitFieldElement(FieldElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }
  }

  @override
  void visitClassElement(ClassElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.isPrivate) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }

    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }
    proxyClassList[element.displayName] = ClassItem(element.displayName);
    final asKey = "${element.key}@#as";
    final isKey = "${element.key}@#is";
    if (!overwriteStrategy.ingoreKeys.contains(asKey)) {
      writeTargetKeywordClassName(element, "#as");
    }
    if (!overwriteStrategy.ingoreKeys.contains(isKey)) {
      writeTargetKeywordClassName(element, "#is");
    }

    element.visitChildren(this);
  }

  void writeTargetKeywordClassName(ClassElement classElement, String keyeword) {
    var type = classElement.thisType;
    var classItem = proxyClassList[classElement.name];
    if (classItem == null) {
      throw Exception("not found classItem ${classElement.name}");
    }
    var proxyName =
        "${classElement.name}_${binaryOperatorList[keyeword]![0]}\$";
    var method = cb.Method(((p0) {
      p0.name = proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      typeParams.addAll(classElement.typeParameters);

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target";
          p0.type = cb.refer("dynamic");
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.lambda = true;
          p0.body = cb.Code(
              "target ${binaryOperatorList[keyeword]![0]} ${dartTypeToClassName(type)}");
        },
      ).closure.code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[keyeword] = cb.refer(proxyName).expression;
  }

  void addParameter(ParameterElement element, List<cb.Parameter> list,
      int index, bool toFunctionPointer,
      {String? pre}) {
    list.add(cb.Parameter(
      (p0) {
        p0.named = element.isNamed;
        var name = element.name;
        if (name.isEmpty) {
          name = "\$p$index";
        }
        if (pre != null && !element.isNamed) {
          name = "${pre}_$name";
        }
        p0.name = name;
        var typeString = dartTypeToClassName(element.type,
            toFunctionPointer: toFunctionPointer);

        if (typeString == "void") {
          typeString = "dynamic";
        }

        if (toFunctionPointer) {
          if (element.hasDefaultValue && !typeString.endsWith("?")) {
            typeString = "$typeString?";
          } else if (element.isRequiredNamed ||
              (element.isNamed && !typeString.endsWith("?"))) {
            p0.required = true;
            p0.named = true;
          }
        } else {
          if (element.hasDefaultValue && !typeString.endsWith("?")) {
            typeString = "$typeString?";
          } else if ((element.isNamed && !typeString.endsWith("?"))) {
            typeString = "$typeString?";
          }
        }

        p0.type = cb.refer(typeString);
      },
    ));
  }

  void functionElementWithFunctionType(ExecutableElement functionElement,
      bool isStatic, void Function(cb.Method mechod) callback) {
    List<cb.Parameter> requiredParameters = [];
    List<cb.Parameter> optionalParameters = [];

    var type = functionElement.type;

    for (int i = 0; i < type.parameters.length; i++) {
      var element = type.parameters[i];

      if (type.parameters[i].isNamed) {
        addParameter(element, optionalParameters, i, true);
      } else {
        addParameter(element, requiredParameters, i, true);
      }
    }
    var classElement = functionElement.enclosingElement;
    var method = cb.Method(((p0) {
      p0.name = functionElement.proxyName;
      p0.returns = cb.refer("Function");
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      if (!isStatic) {
        classElement as InterfaceElement;
        var type = classElement.thisType;
        p0.requiredParameters.add(cb.Parameter(
          (p0) {
            p0.name = "target";
            p0.type = cb.refer(dartTypeToClassName(type));
          },
        ));
        p0.types.addAll(classElement.typeParameters
            .map<cb.TypeReference>((e) => cb.TypeReference(
                  (p0) {
                    p0.symbol = e.name;
                    if (e.bound != null) {
                      p0.bound = cb.refer(e.bound.toString());
                    }
                  },
                )));
      }

      p0.lambda = true;
      var method = cb.Method(
        (p1) {
          p1.types.addAll(functionElement.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p2) {
                      p2.symbol = e.name;
                      if (e.bound != null) {
                        p2.bound = cb.refer(e.bound.toString());
                      }
                    },
                  )));

          p1.requiredParameters.addAll(requiredParameters);
          p1.optionalParameters.addAll(optionalParameters);
          p1.body = functionBody(functionElement);
        },
      ).genericClosure.code;
      p0.body = method; //cb.Code(method.accept(dartEmitter).toString());
    }));

    callback(method);
  }

  cb.Code functionBody(ExecutableElement functionElement) {
    List<ParameterElement> posational = [];
    List<ParameterElement> optionalPosational = [];
    List<ParameterElement> named = [];
    List<ParameterElement> globalFunctionParamers = [];
    var functionType = functionElement.type;
    for (int i = 0; i < functionType.parameters.length; i++) {
      var parameter = functionType.parameters[i];
      if (parameter.isPositional) {
        if (parameter.isOptionalPositional) {
          optionalPosational.add(parameter);
        } else {
          posational.add(parameter);
        }
      } else if (parameter.isNamed) {
        named.add(parameter);
      }
      if (isFunctionType(parameter.type)) {
        if (!parameter.isOptionalPositional) {
          globalFunctionParamers.add(parameter);
        }
      }
    }

    List<cb.Code> statements = [];
    for (var parameter in globalFunctionParamers) {
      writeFunctionParmeterProxy(functionElement, parameter, statements);
    }

    if (optionalPosational.isNotEmpty) {
      ParameterElement? functionParamer;
      List<ParameterElement> optionalPosational2 =
          List.from(optionalPosational);
      writeOptionalIfNull(optionalPosational, statements);
      writeFunctionBodyWithFunctionPointer(
          functionElement, posational, named, statements);
      var ite = optionalPosational.iterator;
      while (ite.moveNext()) {
        var parameter = ite.current;
        posational.add(parameter);
        optionalPosational2.remove(parameter);
        if (isFunctionType(parameter.type)) {
          functionParamer = parameter;
        } else {
          functionParamer = null;
        }
        if (functionParamer != null) {
          writeFunctionParmeterProxy(
              functionElement, functionParamer, statements);
        }
        if (optionalPosational2.isNotEmpty) {
          writeOptionalIfNull(optionalPosational2, statements);
        }

        writeFunctionBodyWithFunctionPointer(
            functionElement, posational, named, statements);
        if (functionType.returnType is VoidType) {
          statements.add(cb.Code("return;"));
        }
      }
    } else {
      writeFunctionBodyWithFunctionPointer(
          functionElement, posational, named, statements);
    }

    return cb.Block.of(statements);
  }

  void writeFunctionBodyWithFunctionPointer(
      ExecutableElement functionElement,
      List<ParameterElement> posational,
      List<ParameterElement> named,
      List<cb.Code> list) {
    var functionType = functionElement.type;
    bool hasReturn = (functionType.returnType is! VoidType);

    var className = "";
    if (functionElement is PropertyAccessorElement ||
        functionElement is MethodElement) {
      if (functionElement.isStatic) {
        className = functionElement.enclosingElement.displayName;
      } else {
        className = "target";
      }
    }
    var name = functionElement.name;
    if (className.isNotEmpty) {
      name = "$className.$name";
    }

    if (hasReturn) {
      name = "return $name";
    }

    var posationalList = posational.map<cb.Expression>((e) {
      var name = isFunctionType(e.type) ? "${e.name}Proxy" : e.name;

      if (e.hasDefaultValue) {
        name = "$name ?? ${getDefaultValueCode(e)}";
      } else if (e.type.nullabilitySuffix == NullabilitySuffix.question &&
          isFunctionType(e.type)) {
        name = "${e.name} == null ? null : $name";
      }

      return cb.refer(name).expression;
    }).toList();

    var nameMap = Map<String, cb.Expression>.fromIterable(
      named,
      key: (e) {
        return e.name;
      },
      value: (e) {
        e as ParameterElement;
        var name = isFunctionType(e.type) ? "${e.name}Proxy" : e.name;
        if (e.hasDefaultValue) {
          name = "${e.name} == null ? ${getDefaultValueCode(e)} : $name";
        } else if (e.type.nullabilitySuffix == NullabilitySuffix.question &&
            isFunctionType(e.type)) {
          name = "${e.name} == null ? null : $name";
        }
        return cb.refer(name).expression;
      },
    );

    var typeArguments = functionElement.typeParameters
        .map<cb.Reference>((e) => cb.refer(e.name))
        .toList();

    list.add(
        cb.refer(name).call(posationalList, nameMap, typeArguments).statement);
  }

  String? getDefaultValueCode(ParameterElement element) {
    var parentElement = element.enclosingElement;
    String? key;
    if (parentElement is ConstructorElement ||
        parentElement is MethodElement ||
        parentElement is FunctionElement) {
      key = parentElement?.key;
    }

    if (key != null && element.defaultValueCode != null) {
      Map? map = overwriteStrategy.defaultValueCodeOverwrites[key];
      if (map != null && map.containsKey(element.defaultValueCode)) {
        return map[element.defaultValueCode];
      }
    }

    return element.defaultValueCode;
  }

  void writeOptionalIfNull(
      List<ParameterElement> optionalPosationals, List<cb.Code> list) {
    if (optionalPosationals.isEmpty) {
      return;
    }
    list.add(const cb.Code('if ('));
    for (int i = 0; i < optionalPosationals.length; i++) {
      list.add(
          cb.refer(optionalPosationals[i].name).equalTo(cb.literalNull).code);
      if (i < optionalPosationals.length - 1) {
        list.add(const cb.Code(' && '));
      }
    }

    list.add(const cb.Code(') {'));

    list.add(const cb.Code('}'));
  }

  void writeFunctionParmeterProxy(ExecutableElement functionElement,
      ParameterElement parameterElement, List<cb.Code> list) {
    var type = parameterElement.type as FunctionType;
    var name = parameterElement.name;
    var proxyName = "${name}Proxy";
    bool isAsync = (type.returnType.isDartAsyncFuture ||
        type.returnType.isDartAsyncFutureOr);

    List<cb.Parameter> requiredParameters = [];
    List<cb.Parameter> optionalParameters = [];
    String pre = parameterElement.name;
    for (int i = 0; i < type.parameters.length; i++) {
      if (type.parameters[i].isNamed) {
        addParameter(type.parameters[i], optionalParameters, i, false,
            pre: pre);
      } else {
        addParameter(type.parameters[i], requiredParameters, i, false,
            pre: pre);
      }
    }
    var method = cb.Method(((p0) {
      p0.name = proxyName;
      p0.modifier = isAsync ? cb.MethodModifier.async : null;
      p0.returns = cb.refer(dartTypeToClassName(type.returnType));
      p0.types.addAll(
          type.typeFormals.map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.optionalParameters.addAll(optionalParameters);
      p0.requiredParameters.addAll(requiredParameters);
      p0.lambda = true;
      p0.body = functionProxyBody(functionElement, parameterElement);
    }));

    list.add(cb.Code(method.accept(dartEmitter).toString()));
  }

  cb.Code functionProxyBody(
      ExecutableElement functionElement, ParameterElement parameterElement) {
    var type = parameterElement.type as FunctionType;

    bool isAsync = (type.returnType.isDartAsyncFuture ||
        type.returnType.isDartAsyncFutureOr);
    var callFunctionPointer = "callFunctionPointer";
    var scope = "scope";
    if (isAsync) {
      scope = "await scope";
      callFunctionPointer = "callFunctionPointerAsync";
    }
    var pointerName = parameterElement.name;
    if (type.nullabilitySuffix == NullabilitySuffix.question ||
        parameterElement.hasDefaultValue) {
      pointerName = "$pointerName!";
    }
    List<cb.Reference> positionalArguments = [];
    Map<String, cb.Reference> namedArguments = {};

    for (int i = 0; i < type.parameters.length; i++) {
      if (type.parameters[i].isNamed) {
        var name = type.parameters[i].name;
        if (name.isEmpty) {
          name = "\$p$i";
        }
        namedArguments[name] = cb.refer(name);
      } else if (type.parameters[i].isPositional) {
        var name = type.parameters[i].name;
        if (name.isEmpty) {
          name = "\$p$i";
        }
        String pre = parameterElement.displayName;
        name = "${pre}_$name";
        positionalArguments.add(cb.refer(name));
      }
    }
    return cb
        .refer(scope)
        .property("engine")
        .property(callFunctionPointer)
        .call([
      cb.refer("scope"),
      cb.refer(pointerName),
      cb.literalList(positionalArguments),
      cb.literalMap(namedArguments)
    ]).statement;
  }

  @override
  void visitFunctionElement(FunctionElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }

    if (hasFunctionTypeParams(element.type)) {
      functionElementWithFunctionType(element, true, (cb.Method method) {
        proxyGlobalMethods.add(method);
        var name = element.getNameWithClass();
        proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
      });
      return;
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");
      p0.types.addAll(
          element.typeParameters.map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.body = cb.TypeReference(
        (p0) {
          p0.symbol = element.name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    proxyGlobalGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  void writeSpecialMethodElement(MethodElement element) {
    var name = "target.${element.name}";
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      throw Exception(
          "not found classItem ${element.enclosingElement.displayName}");
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target";
          p0.type = cb.refer(dartTypeToClassName(type));
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.requiredParameters.add(cb.Parameter(
            (p0) {
              p0.name = "index";
              p0.type = cb.refer(dartTypeToClassName(element.parameters[0].type,
                  toFunctionPointer: false));
            },
          ));

          if (element.name == "[]=") {
            p0.requiredParameters.add(cb.Parameter(
              (p0) {
                p0.name = "other";
                p0.type = cb.refer(dartTypeToClassName(
                    element.parameters[1].type,
                    toFunctionPointer: false));
              },
            ));
          }

          p0.lambda = true;
          if (element.name == "[]") {
            p0.body = cb.Code("target[index]");
          } else if (element.name == "[]=") {
            p0.body = cb.Code("target[index]=other");
          }
        },
      ).closure.code;

      cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  void writeUnaryMethodElement(MethodElement element) {
    var name = "target.${element.name}";
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      throw Exception(
          "not found classItem ${element.enclosingElement.displayName}");
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target";
          p0.type = cb.refer(dartTypeToClassName(type));
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.lambda = true;
          p0.body = cb.Code(" ${unaryOperatorList[element.name]![0]} target");
        },
      ).closure.code;

      cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  void writeBinaryMethodElement(MethodElement element) {
    var name = "target.${element.name}";
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      throw Exception(
          "not found classItem ${element.enclosingElement.displayName}");
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target";
          p0.type = cb.refer(dartTypeToClassName(type));
        },
      ));

      p0.body = cb.Method(
        (p0) {
          p0.requiredParameters.add(cb.Parameter(
            (p0) {
              p0.name = "other";
              p0.type = cb.refer(dartTypeToClassName(element.parameters[0].type,
                  toFunctionPointer: false));
            },
          ));

          p0.lambda = true;
          p0.body =
              cb.Code("target ${binaryOperatorList[element.name]![0]} other");
        },
      ).closure.code;

      cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.name] =
        cb.refer(element.proxyName!).expression;
  }

  @override
  void visitMethodElement(MethodElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }
    var name = element.name;
    if (binaryOperatorList.containsKey(name)) {
      writeBinaryMethodElement(element);
      return;
    } else if (unaryOperatorList.containsKey(name)) {
      writeUnaryMethodElement(element);
      return;
    } else if (specialOperatorList.containsKey(name)) {
      writeSpecialMethodElement(element);

      return;
    }
    if (hasFunctionTypeParams(element.type)) {
      functionElementWithFunctionType(element, element.isStatic,
          (cb.Method method) {
        proxyGlobalMethods.add(method);
        var name = element.getNameWithClass();
        proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
      });
      return;
    }
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      throw Exception(
          "not found classItem ${element.enclosingElement.displayName}");
    }

    if (element.isStatic) {
      name = element.getNameWithClass();
    } else {
      name = "target.${element.name}";
    }

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.returns = cb.refer("Function");

      List<TypeParameterElement> typeParams = [];

      if (element.isStatic) {
        typeParams.addAll(element.typeParameters);
      } else {
        typeParams.addAll(classElement.typeParameters);
        for (var type in element.typeParameters) {
          var list = typeParams.where((element) => element.name == type.name);
          if (list.isEmpty) {
            typeParams.add(type);
          }
        }
      }

      p0.types.addAll(typeParams.map<cb.TypeReference>((e) => cb.TypeReference(
            (p0) {
              p0.symbol = e.name;
              if (e.bound != null) {
                p0.bound = cb.refer(e.bound.toString());
              }
            },
          )));

      p0.lambda = true;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "scope";
          p0.type = cb.refer("m.Scope");
        },
      ));
      if (!element.isStatic) {
        p0.requiredParameters.add(cb.Parameter(
          (p0) {
            p0.name = "target";
            p0.type = cb.refer(dartTypeToClassName(type));
          },
        ));
      }

      p0.body = cb.TypeReference(
        (p0) {
          p0.symbol = name;
          p0.types.addAll(element.typeParameters
              .map<cb.TypeReference>((e) => cb.TypeReference(
                    (p0) {
                      p0.symbol = e.name;
                    },
                  )));
        },
      ).code;
    }));
    proxyGlobalMethods.add(method);
    if (element.isStatic) {
      proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
    } else {
      classItem.proxyGetterList[element.name] =
          cb.refer(element.proxyName!).expression;
    }
  }

  @override
  void visitPropertyAccessorElement(PropertyAccessorElement element) {
    if (element.name.startsWith("_")) {
      return;
    }
    if (element.hasDeprecated) {
      return;
    }
    if (overwriteStrategy.ingoreKeys.contains(element.key)) {
      return;
    }
    if (element.isStatic) {
      writeStaticProperty(element);
    } else {
      writeClassProperty(element);
    }
  }

  void writeStaticProperty(PropertyAccessorElement element) {
    if (element.isGetter) {
      writeStaticPropertyGetter(element);
    } else if (element.isSetter) {
      writeStaticPropertySetter(element);
    }
  }

  void writeClassProperty(PropertyAccessorElement element) {
    if (element.isGetter) {
      writeClassPropertyGetter(element);
    } else if (element.isSetter) {
      writeClassPropertySetter(element);
    }
  }

  void writeStaticPropertyGetter(PropertyAccessorElement element) {
    var name = element.getNameWithClass();

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.types.addAll(
          element.typeParameters.map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      var returnType = element.returnType;
      if (returnType is InterfaceType) {
        if (returnType.element.isPrivate) {
          p0.returns = cb.refer("dynamic");
        } else {
          p0.returns = cb
              .refer(dartTypeToClassName(returnType, toFunctionPointer: false));
        }
      } else {
        p0.returns =
            cb.refer(dartTypeToClassName(returnType, toFunctionPointer: false));
      }

      p0.body = cb.Block.of([
        cb.Code("return "),
        cb.TypeReference(
          (p0) {
            p0.symbol = name;
            p0.types.addAll(element.typeParameters
                .map<cb.TypeReference>((e) => cb.TypeReference(
                      (p0) {
                        p0.symbol = e.name;
                      },
                    )));
          },
        ).statement
      ]);
    }));
    proxyGlobalMethods.add(method);
    proxyGlobalGetterList[name] = cb.refer(element.proxyName!).expression;
  }

  void writeStaticPropertySetter(
      PropertyAccessorElement propertyAccessorElement) {
    if (hasFunctionTypeParams(propertyAccessorElement.type)) {
      functionElementWithFunctionType(propertyAccessorElement, true,
          (cb.Method method) {
        proxyGlobalMethods.add(method);
        proxyGlobalSetterList[propertyAccessorElement.getNameWithClass()] =
            cb.refer(propertyAccessorElement.proxyName!).expression;
      });
      return;
    }

    var name = propertyAccessorElement.getNameWithClass();

    List<cb.Parameter> requiredParameters = [];

    for (int i = 0; i < propertyAccessorElement.type.parameters.length; i++) {
      if (propertyAccessorElement.type.parameters[i].isRequired) {
        addParameter(propertyAccessorElement.type.parameters[i],
            requiredParameters, i, true);
      }
    }
    var method = cb.Method(((p0) {
      p0.name = propertyAccessorElement.proxyName;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "other";
          p0.type = requiredParameters.first.type;
        },
      ));
      p0.types.addAll(propertyAccessorElement.typeParameters
          .map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.returns = cb.refer("void");
      p0.lambda = false;
      p0.body = cb.refer(name).assign(cb.refer("other")).statement;
    }));
    proxyGlobalMethods.add(method);
    proxyGlobalSetterList[name] =
        cb.refer(propertyAccessorElement.proxyName!).expression;
  }

  void writeClassPropertyGetter(PropertyAccessorElement element) {
    var classElement = element.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem = proxyClassList[element.enclosingElement.displayName];
    if (classItem == null) {
      throw Exception(
          "not found classItem ${element.enclosingElement.displayName}");
    }
    var name = "target.${element.displayName}";

    var method = cb.Method(((p0) {
      p0.name = element.proxyName;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target";
          p0.type = cb.refer(dartTypeToClassName(type));
        },
      ));
      p0.types.addAll(classElement.typeParameters
          .map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      var returnType = element.returnType;
      if (returnType is InterfaceType) {
        if (returnType.element.isPrivate) {
          p0.returns = cb.refer("dynamic");
        } else {
          p0.returns = cb
              .refer(dartTypeToClassName(returnType, toFunctionPointer: false));
        }
      } else {
        p0.returns =
            cb.refer(dartTypeToClassName(returnType, toFunctionPointer: false));
      }

      p0.body = cb.Block.of([
        cb.Code("return "),
        cb.TypeReference(
          (p0) {
            p0.symbol = name;
            p0.types.addAll(element.typeParameters
                .map<cb.TypeReference>((e) => cb.TypeReference(
                      (p0) {
                        p0.symbol = e.name;
                      },
                    )));
          },
        ).statement
      ]);
    }));

    proxyGlobalMethods.add(method);
    classItem.proxyGetterList[element.displayName] =
        cb.refer(element.proxyName!).expression;
  }

  void writeClassPropertySetter(
      PropertyAccessorElement propertyAccessorElement) {
    var classElement =
        propertyAccessorElement.enclosingElement as InterfaceElement;
    var type = classElement.thisType;
    var classItem =
        proxyClassList[propertyAccessorElement.enclosingElement.displayName];
    if (classItem == null) {
      throw Exception(
          "not found classItem ${propertyAccessorElement.enclosingElement.displayName}");
    }
    var name = "target.${propertyAccessorElement.displayName}";

    if (hasFunctionTypeParams(propertyAccessorElement.type)) {
      functionElementWithFunctionType(propertyAccessorElement, false,
          (cb.Method method) {
        proxyGlobalMethods.add(method);
        classItem.proxySetterList[propertyAccessorElement.displayName] =
            cb.refer(propertyAccessorElement.proxyName!).expression;
      });
      return;
    }

    List<cb.Parameter> requiredParameters = [];

    for (int i = 0; i < propertyAccessorElement.type.parameters.length; i++) {
      if (propertyAccessorElement.type.parameters[i].isRequired) {
        addParameter(propertyAccessorElement.type.parameters[i],
            requiredParameters, i, true);
      }
    }
    var method = cb.Method(((p0) {
      p0.name = propertyAccessorElement.proxyName;
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "target";
          p0.type = cb.refer(dartTypeToClassName(type));
        },
      ));
      p0.requiredParameters.add(cb.Parameter(
        (p0) {
          p0.name = "other";
          p0.type = requiredParameters.first.type;
        },
      ));
      p0.types.addAll(classElement.typeParameters
          .map<cb.TypeReference>((e) => cb.TypeReference(
                (p0) {
                  p0.symbol = e.name;
                  if (e.bound != null) {
                    p0.bound = cb.refer(e.bound.toString());
                  }
                },
              )));
      p0.returns = cb.refer("void");
      p0.lambda = false;
      p0.body = cb.refer(name).assign(cb.refer("other")).statement;
    }));
    proxyGlobalMethods.add(method);
    classItem.proxySetterList[propertyAccessorElement.displayName] =
        cb.refer(propertyAccessorElement.proxyName!).expression;
  }
}
