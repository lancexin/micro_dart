// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/box_decoration.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:flutter/src/painting/box_shadow.dart';
import 'package:flutter/src/painting/colors.dart';
import 'package:flutter/src/painting/decoration.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/painting/gradient.dart';
import 'package:flutter/src/painting/image_provider.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/box_decoration.dart',
  {'BoxDecoration.lerp': _BoxDecoration_lerp$},
  {},
  {
    'BoxDecoration': m.ClassMirror(
      'BoxDecoration',
      {
        'color': _BoxDecoration_color$,
        'image': _BoxDecoration_image$,
        'border': _BoxDecoration_border$,
        'borderRadius': _BoxDecoration_borderRadius$,
        'boxShadow': _BoxDecoration_boxShadow$,
        'gradient': _BoxDecoration_gradient$,
        'backgroundBlendMode': _BoxDecoration_backgroundBlendMode$,
        'shape': _BoxDecoration_shape$,
        'padding': _BoxDecoration_padding$,
        'isComplex': _BoxDecoration_isComplex$,
        'hashCode': _BoxDecoration_hashCode$,
        'copyWith': _BoxDecoration_copyWith$,
        'debugAssertIsValid': _BoxDecoration_debugAssertIsValid$,
        'getClipPath': _BoxDecoration_getClipPath$,
        'scale': _BoxDecoration_scale$,
        'lerpFrom': _BoxDecoration_lerpFrom$,
        'lerpTo': _BoxDecoration_lerpTo$,
        'debugFillProperties': _BoxDecoration_debugFillProperties$,
        'hitTest': _BoxDecoration_hitTest$,
      },
      {},
    )
  },
);
Color? _BoxDecoration_color$(BoxDecoration target) {
  return target.color;
}

DecorationImage? _BoxDecoration_image$(BoxDecoration target) {
  return target.image;
}

BoxBorder? _BoxDecoration_border$(BoxDecoration target) {
  return target.border;
}

BorderRadiusGeometry? _BoxDecoration_borderRadius$(BoxDecoration target) {
  return target.borderRadius;
}

List<BoxShadow>? _BoxDecoration_boxShadow$(BoxDecoration target) {
  return target.boxShadow;
}

Gradient? _BoxDecoration_gradient$(BoxDecoration target) {
  return target.gradient;
}

BlendMode? _BoxDecoration_backgroundBlendMode$(BoxDecoration target) {
  return target.backgroundBlendMode;
}

BoxShape _BoxDecoration_shape$(BoxDecoration target) {
  return target.shape;
}

EdgeInsetsGeometry _BoxDecoration_padding$(BoxDecoration target) {
  return target.padding;
}

bool _BoxDecoration_isComplex$(BoxDecoration target) {
  return target.isComplex;
}

int _BoxDecoration_hashCode$(BoxDecoration target) {
  return target.hashCode;
}

Function _BoxDecoration_copyWith$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.copyWith;
Function _BoxDecoration_debugAssertIsValid$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.debugAssertIsValid;
Function _BoxDecoration_getClipPath$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.getClipPath;
Function _BoxDecoration_scale$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.scale;
Function _BoxDecoration_lerpFrom$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.lerpFrom;
Function _BoxDecoration_lerpTo$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.lerpTo;
Function _BoxDecoration_lerp$(m.Scope scope) => BoxDecoration.lerp;
Function _BoxDecoration_debugFillProperties$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.debugFillProperties;
Function _BoxDecoration_hitTest$(
  m.Scope scope,
  BoxDecoration target,
) =>
    target.hitTest;
