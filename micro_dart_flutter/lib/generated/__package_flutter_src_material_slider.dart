// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/slider.dart';
import 'dart:async';
import 'dart:math';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart' show timeDilation;
import 'package:flutter/services.dart';
import 'package:flutter/src/material/color_scheme.dart';
import 'package:flutter/src/material/colors.dart';
import 'package:flutter/src/material/constants.dart';
import 'package:flutter/src/material/debug.dart';
import 'package:flutter/src/material/material.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/slider_theme.dart';
import 'package:flutter/src/material/theme.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/slider.dart',
  {
    'Slider.': _Slider__$,
    'Slider.adaptive': _Slider_adaptive_$,
  },
  {},
  {
    'Slider': m.ClassMirror(
      'Slider',
      {
        '#as': Slider_as$,
        '#is': Slider_is$,
        'value': _Slider_value$,
        'secondaryTrackValue': _Slider_secondaryTrackValue$,
        'onChanged': _Slider_onChanged$,
        'onChangeStart': _Slider_onChangeStart$,
        'onChangeEnd': _Slider_onChangeEnd$,
        'min': _Slider_min$,
        'max': _Slider_max$,
        'divisions': _Slider_divisions$,
        'label': _Slider_label$,
        'activeColor': _Slider_activeColor$,
        'inactiveColor': _Slider_inactiveColor$,
        'secondaryActiveColor': _Slider_secondaryActiveColor$,
        'thumbColor': _Slider_thumbColor$,
        'overlayColor': _Slider_overlayColor$,
        'mouseCursor': _Slider_mouseCursor$,
        'semanticFormatterCallback': _Slider_semanticFormatterCallback$,
        'focusNode': _Slider_focusNode$,
        'autofocus': _Slider_autofocus$,
        'createState': _Slider_createState$,
        'debugFillProperties': _Slider_debugFillProperties$,
      },
      {},
    )
  },
);
Function Slider_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Slider;
Function Slider_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Slider;
Function _Slider_value$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.value;
    };
Function _Slider_secondaryTrackValue$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.secondaryTrackValue;
    };
Function _Slider_onChanged$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.onChanged;
    };
Function _Slider_onChangeStart$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.onChangeStart;
    };
Function _Slider_onChangeEnd$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.onChangeEnd;
    };
Function _Slider_min$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.min;
    };
Function _Slider_max$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.max;
    };
Function _Slider_divisions$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.divisions;
    };
Function _Slider_label$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.label;
    };
Function _Slider_activeColor$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.activeColor;
    };
Function _Slider_inactiveColor$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.inactiveColor;
    };
Function _Slider_secondaryActiveColor$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.secondaryActiveColor;
    };
Function _Slider_thumbColor$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.thumbColor;
    };
Function _Slider_overlayColor$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.overlayColor;
    };
Function _Slider_mouseCursor$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.mouseCursor;
    };
Function _Slider_semanticFormatterCallback$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.semanticFormatterCallback;
    };
Function _Slider_focusNode$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.focusNode;
    };
Function _Slider_autofocus$(
  m.Scope scope$,
  Slider target$,
) =>
    () {
      return target$.autofocus;
    };
Function _Slider__$(m.Scope scope$) => ({
      Key? key,
      required double value,
      double? secondaryTrackValue,
      required m.FunctionPointer? onChanged,
      m.FunctionPointer? onChangeStart,
      m.FunctionPointer? onChangeEnd,
      double? min,
      double? max,
      int? divisions,
      String? label,
      Color? activeColor,
      Color? inactiveColor,
      Color? secondaryActiveColor,
      Color? thumbColor,
      MaterialStateProperty<Color>? overlayColor,
      MouseCursor? mouseCursor,
      m.FunctionPointer? semanticFormatterCallback,
      FocusNode? focusNode,
      bool? autofocus,
    }) {
      void onChangeEndProxy(double onChangeEnd_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChangeEnd!,
            [onChangeEnd_value$],
            {},
          );
      void onChangeStartProxy(double onChangeStart_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChangeStart!,
            [onChangeStart_value$],
            {},
          );
      void onChangedProxy(double onChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChanged!,
            [onChanged_value$],
            {},
          );
      String semanticFormatterCallbackProxy(
              double semanticFormatterCallback_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            semanticFormatterCallback!,
            [semanticFormatterCallback_value$],
            {},
          );
      return Slider(
        activeColor: activeColor,
        autofocus: autofocus ?? false,
        divisions: divisions,
        focusNode: focusNode,
        inactiveColor: inactiveColor,
        key: key,
        label: label,
        max: max ?? 1.0,
        min: min ?? 0.0,
        mouseCursor: mouseCursor,
        onChangeEnd: onChangeEnd == null ? null : onChangeEndProxy,
        onChangeStart: onChangeStart == null ? null : onChangeStartProxy,
        onChanged: onChanged == null ? null : onChangedProxy,
        overlayColor: overlayColor,
        secondaryActiveColor: secondaryActiveColor,
        secondaryTrackValue: secondaryTrackValue,
        semanticFormatterCallback: semanticFormatterCallback == null
            ? null
            : semanticFormatterCallbackProxy,
        thumbColor: thumbColor,
        value: value,
      );
    };
Function _Slider_adaptive_$(m.Scope scope$) => ({
      Key? key,
      required double value,
      double? secondaryTrackValue,
      required m.FunctionPointer? onChanged,
      m.FunctionPointer? onChangeStart,
      m.FunctionPointer? onChangeEnd,
      double? min,
      double? max,
      int? divisions,
      String? label,
      MouseCursor? mouseCursor,
      Color? activeColor,
      Color? inactiveColor,
      Color? secondaryActiveColor,
      Color? thumbColor,
      MaterialStateProperty<Color>? overlayColor,
      m.FunctionPointer? semanticFormatterCallback,
      FocusNode? focusNode,
      bool? autofocus,
    }) {
      void onChangeEndProxy(double onChangeEnd_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChangeEnd!,
            [onChangeEnd_value$],
            {},
          );
      void onChangeStartProxy(double onChangeStart_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChangeStart!,
            [onChangeStart_value$],
            {},
          );
      void onChangedProxy(double onChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChanged!,
            [onChanged_value$],
            {},
          );
      String semanticFormatterCallbackProxy(
              double semanticFormatterCallback_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            semanticFormatterCallback!,
            [semanticFormatterCallback_value$],
            {},
          );
      return Slider.adaptive(
        activeColor: activeColor,
        autofocus: autofocus ?? false,
        divisions: divisions,
        focusNode: focusNode,
        inactiveColor: inactiveColor,
        key: key,
        label: label,
        max: max ?? 1.0,
        min: min ?? 0.0,
        mouseCursor: mouseCursor,
        onChangeEnd: onChangeEnd == null ? null : onChangeEndProxy,
        onChangeStart: onChangeStart == null ? null : onChangeStartProxy,
        onChanged: onChanged == null ? null : onChangedProxy,
        overlayColor: overlayColor,
        secondaryActiveColor: secondaryActiveColor,
        secondaryTrackValue: secondaryTrackValue,
        semanticFormatterCallback: semanticFormatterCallback == null
            ? null
            : semanticFormatterCallbackProxy,
        thumbColor: thumbColor,
        value: value,
      );
    };
Function _Slider_createState$(
  m.Scope scope$,
  Slider target$,
) =>
    target$.createState;
Function _Slider_debugFillProperties$(
  m.Scope scope$,
  Slider target$,
) =>
    target$.debugFillProperties;
