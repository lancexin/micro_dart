// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/services/asset_bundle.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/services/binding.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/services/asset_bundle.dart',
  {
    'rootBundle': _rootBundle$,
    'AssetBundle.loadStructuredData': _AssetBundle_loadStructuredData$,
    'AssetBundle.loadStructuredBinaryData':
        _AssetBundle_loadStructuredBinaryData$,
    'NetworkAssetBundle.': _NetworkAssetBundle__$,
    'NetworkAssetBundle.loadStructuredData':
        _NetworkAssetBundle_loadStructuredData$,
    'NetworkAssetBundle.loadStructuredBinaryData':
        _NetworkAssetBundle_loadStructuredBinaryData$,
    'CachingAssetBundle.loadStructuredData':
        _CachingAssetBundle_loadStructuredData$,
    'CachingAssetBundle.loadStructuredBinaryData':
        _CachingAssetBundle_loadStructuredBinaryData$,
    'PlatformAssetBundle.': _PlatformAssetBundle__$,
  },
  {},
  {
    'AssetBundle': m.ClassMirror(
      'AssetBundle',
      {
        '#as': AssetBundle_as$,
        '#is': AssetBundle_is$,
        'load': _AssetBundle_load$,
        'loadBuffer': _AssetBundle_loadBuffer$,
        'loadString': _AssetBundle_loadString$,
        'evict': _AssetBundle_evict$,
        'clear': _AssetBundle_clear$,
        'toString': _AssetBundle_toString$,
      },
      {},
    ),
    'NetworkAssetBundle': m.ClassMirror(
      'NetworkAssetBundle',
      {
        '#as': NetworkAssetBundle_as$,
        '#is': NetworkAssetBundle_is$,
        'load': _NetworkAssetBundle_load$,
        'toString': _NetworkAssetBundle_toString$,
      },
      {},
    ),
    'CachingAssetBundle': m.ClassMirror(
      'CachingAssetBundle',
      {
        '#as': CachingAssetBundle_as$,
        '#is': CachingAssetBundle_is$,
        'loadString': _CachingAssetBundle_loadString$,
        'evict': _CachingAssetBundle_evict$,
        'clear': _CachingAssetBundle_clear$,
        'loadBuffer': _CachingAssetBundle_loadBuffer$,
      },
      {},
    ),
    'PlatformAssetBundle': m.ClassMirror(
      'PlatformAssetBundle',
      {
        '#as': PlatformAssetBundle_as$,
        '#is': PlatformAssetBundle_is$,
        'load': _PlatformAssetBundle_load$,
        'loadBuffer': _PlatformAssetBundle_loadBuffer$,
      },
      {},
    ),
  },
);
AssetBundle _rootBundle$() {
  return rootBundle;
}

Function AssetBundle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AssetBundle;
Function AssetBundle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AssetBundle;
Function _AssetBundle_load$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    target$.load;
Function _AssetBundle_loadBuffer$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    target$.loadBuffer;
Function _AssetBundle_loadString$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    target$.loadString;
Function _AssetBundle_loadStructuredData$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    (
      String key,
      m.FunctionPointer parser,
    ) {
      Future parserProxy(String parser_value$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            parser,
            [parser_value$],
            {},
          );
      return target$.loadStructuredData(
        key,
        parserProxy,
      );
    };
Function _AssetBundle_loadStructuredBinaryData$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    (
      String key,
      m.FunctionPointer parser,
    ) {
      FutureOr parserProxy(ByteData parser_data$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            parser,
            [parser_data$],
            {},
          );
      return target$.loadStructuredBinaryData(
        key,
        parserProxy,
      );
    };
Function _AssetBundle_evict$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    target$.evict;
Function _AssetBundle_clear$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    target$.clear;
Function _AssetBundle_toString$(
  m.Scope scope$,
  AssetBundle target$,
) =>
    target$.toString;
Function NetworkAssetBundle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as NetworkAssetBundle;
Function NetworkAssetBundle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is NetworkAssetBundle;
Function _NetworkAssetBundle__$(m.Scope scope$) => (Uri baseUrl) {
      return NetworkAssetBundle(baseUrl);
    };
Function _NetworkAssetBundle_load$(
  m.Scope scope$,
  NetworkAssetBundle target$,
) =>
    target$.load;
Function _NetworkAssetBundle_loadStructuredData$(
  m.Scope scope$,
  NetworkAssetBundle target$,
) =>
    (
      String key,
      m.FunctionPointer parser,
    ) {
      Future parserProxy(String parser_value$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            parser,
            [parser_value$],
            {},
          );
      return target$.loadStructuredData(
        key,
        parserProxy,
      );
    };
Function _NetworkAssetBundle_loadStructuredBinaryData$(
  m.Scope scope$,
  NetworkAssetBundle target$,
) =>
    (
      String key,
      m.FunctionPointer parser,
    ) {
      FutureOr parserProxy(ByteData parser_data$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            parser,
            [parser_data$],
            {},
          );
      return target$.loadStructuredBinaryData(
        key,
        parserProxy,
      );
    };
Function _NetworkAssetBundle_toString$(
  m.Scope scope$,
  NetworkAssetBundle target$,
) =>
    target$.toString;
Function CachingAssetBundle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CachingAssetBundle;
Function CachingAssetBundle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CachingAssetBundle;
Function _CachingAssetBundle_loadString$(
  m.Scope scope$,
  CachingAssetBundle target$,
) =>
    target$.loadString;
Function _CachingAssetBundle_loadStructuredData$(
  m.Scope scope$,
  CachingAssetBundle target$,
) =>
    (
      String key,
      m.FunctionPointer parser,
    ) {
      Future parserProxy(String parser_value$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            parser,
            [parser_value$],
            {},
          );
      return target$.loadStructuredData(
        key,
        parserProxy,
      );
    };
Function _CachingAssetBundle_loadStructuredBinaryData$(
  m.Scope scope$,
  CachingAssetBundle target$,
) =>
    (
      String key,
      m.FunctionPointer parser,
    ) {
      FutureOr parserProxy(ByteData parser_data$) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            parser,
            [parser_data$],
            {},
          );
      return target$.loadStructuredBinaryData(
        key,
        parserProxy,
      );
    };
Function _CachingAssetBundle_evict$(
  m.Scope scope$,
  CachingAssetBundle target$,
) =>
    target$.evict;
Function _CachingAssetBundle_clear$(
  m.Scope scope$,
  CachingAssetBundle target$,
) =>
    target$.clear;
Function _CachingAssetBundle_loadBuffer$(
  m.Scope scope$,
  CachingAssetBundle target$,
) =>
    target$.loadBuffer;
Function PlatformAssetBundle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PlatformAssetBundle;
Function PlatformAssetBundle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PlatformAssetBundle;
Function _PlatformAssetBundle__$(m.Scope scope$) => () {
      return PlatformAssetBundle();
    };
Function _PlatformAssetBundle_load$(
  m.Scope scope$,
  PlatformAssetBundle target$,
) =>
    target$.load;
Function _PlatformAssetBundle_loadBuffer$(
  m.Scope scope$,
  PlatformAssetBundle target$,
) =>
    target$.loadBuffer;
