// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/async.dart';
import 'dart:async' show StreamSubscription;
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/framework.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/async.dart',
  {
    'AsyncSnapshot.nothing': _AsyncSnapshot_nothing_$,
    'AsyncSnapshot.waiting': _AsyncSnapshot_waiting_$,
    'AsyncSnapshot.withData': _AsyncSnapshot_withData_$,
    'AsyncSnapshot.withError': _AsyncSnapshot_withError_$,
    'StreamBuilder.': _StreamBuilder__$,
    'FutureBuilder.debugRethrowError': _FutureBuilder_debugRethrowError$,
    'FutureBuilder.': _FutureBuilder__$,
    'ConnectionState.none': _ConnectionState_none$,
    'ConnectionState.waiting': _ConnectionState_waiting$,
    'ConnectionState.active': _ConnectionState_active$,
    'ConnectionState.done': _ConnectionState_done$,
    'ConnectionState.values': _ConnectionState_values$,
  },
  {'FutureBuilder.debugRethrowError': _FutureBuilder_debugRethrowError_set$},
  {
    'StreamBuilderBase': m.ClassMirror(
      'StreamBuilderBase',
      {
        '#as': StreamBuilderBase_as$,
        '#is': StreamBuilderBase_is$,
        'stream': _StreamBuilderBase_stream$,
        'initial': _StreamBuilderBase_initial$,
        'afterConnected': _StreamBuilderBase_afterConnected$,
        'afterData': _StreamBuilderBase_afterData$,
        'afterError': _StreamBuilderBase_afterError$,
        'afterDone': _StreamBuilderBase_afterDone$,
        'afterDisconnected': _StreamBuilderBase_afterDisconnected$,
        'build': _StreamBuilderBase_build$,
        'createState': _StreamBuilderBase_createState$,
      },
      {},
    ),
    'AsyncSnapshot': m.ClassMirror(
      'AsyncSnapshot',
      {
        '#as': AsyncSnapshot_as$,
        '#is': AsyncSnapshot_is$,
        'connectionState': _AsyncSnapshot_connectionState$,
        'data': _AsyncSnapshot_data$,
        'error': _AsyncSnapshot_error$,
        'stackTrace': _AsyncSnapshot_stackTrace$,
        'requireData': _AsyncSnapshot_requireData$,
        'hasData': _AsyncSnapshot_hasData$,
        'hasError': _AsyncSnapshot_hasError$,
        'hashCode': _AsyncSnapshot_hashCode$,
        'inState': _AsyncSnapshot_inState$,
        'toString': _AsyncSnapshot_toString$,
        '==': _AsyncSnapshot_eq$$,
      },
      {},
    ),
    'StreamBuilder': m.ClassMirror(
      'StreamBuilder',
      {
        '#as': StreamBuilder_as$,
        '#is': StreamBuilder_is$,
        'builder': _StreamBuilder_builder$,
        'initialData': _StreamBuilder_initialData$,
        'initial': _StreamBuilder_initial$,
        'afterConnected': _StreamBuilder_afterConnected$,
        'afterData': _StreamBuilder_afterData$,
        'afterError': _StreamBuilder_afterError$,
        'afterDone': _StreamBuilder_afterDone$,
        'afterDisconnected': _StreamBuilder_afterDisconnected$,
        'build': _StreamBuilder_build$,
      },
      {},
    ),
    'FutureBuilder': m.ClassMirror(
      'FutureBuilder',
      {
        '#as': FutureBuilder_as$,
        '#is': FutureBuilder_is$,
        'future': _FutureBuilder_future$,
        'builder': _FutureBuilder_builder$,
        'initialData': _FutureBuilder_initialData$,
        'createState': _FutureBuilder_createState$,
      },
      {},
    ),
    'ConnectionState': m.ClassMirror(
      'ConnectionState',
      {},
      {},
    ),
  },
);
Function StreamBuilderBase_as$<T, S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamBuilderBase<T, S>;
Function StreamBuilderBase_is$<T, S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamBuilderBase<T, S>;
Function _StreamBuilderBase_stream$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    () {
      return target$.stream;
    };
Function _StreamBuilderBase_initial$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.initial;
Function _StreamBuilderBase_afterConnected$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.afterConnected;
Function _StreamBuilderBase_afterData$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.afterData;
Function _StreamBuilderBase_afterError$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.afterError;
Function _StreamBuilderBase_afterDone$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.afterDone;
Function _StreamBuilderBase_afterDisconnected$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.afterDisconnected;
Function _StreamBuilderBase_build$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.build;
Function _StreamBuilderBase_createState$<T, S>(
  m.Scope scope$,
  StreamBuilderBase<T, S> target$,
) =>
    target$.createState;
Function AsyncSnapshot_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AsyncSnapshot<T>;
Function AsyncSnapshot_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AsyncSnapshot<T>;
Function _AsyncSnapshot_connectionState$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.connectionState;
    };
Function _AsyncSnapshot_data$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.data;
    };
Function _AsyncSnapshot_error$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.error;
    };
Function _AsyncSnapshot_stackTrace$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.stackTrace;
    };
Function _AsyncSnapshot_requireData$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.requireData;
    };
Function _AsyncSnapshot_hasData$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.hasData;
    };
Function _AsyncSnapshot_hasError$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.hasError;
    };
Function _AsyncSnapshot_hashCode$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    () {
      return target$.hashCode;
    };
Function _AsyncSnapshot_nothing_$(m.Scope scope$) => AsyncSnapshot.nothing;
Function _AsyncSnapshot_waiting_$(m.Scope scope$) => AsyncSnapshot.waiting;
Function _AsyncSnapshot_withData_$(m.Scope scope$) => AsyncSnapshot.withData;
Function _AsyncSnapshot_withError_$(m.Scope scope$) => AsyncSnapshot.withError;
Function _AsyncSnapshot_inState$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    target$.inState;
Function _AsyncSnapshot_toString$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    target$.toString;
Function _AsyncSnapshot_eq$$<T>(
  m.Scope scope$,
  AsyncSnapshot<T> target$,
) =>
    (Object other$) => target$ == other$;
Function StreamBuilder_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamBuilder<T>;
Function StreamBuilder_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamBuilder<T>;
Function _StreamBuilder_builder$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    () {
      return target$.builder;
    };
Function _StreamBuilder_initialData$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    () {
      return target$.initialData;
    };
Function _StreamBuilder__$(m.Scope scope$) => ({
      Key? key,
      dynamic? initialData,
      Stream? stream,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        AsyncSnapshot builder_snapshot$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [
              builder_context$,
              builder_snapshot$,
            ],
            {},
          );
      return StreamBuilder(
        builder: builderProxy,
        initialData: initialData,
        key: key,
        stream: stream,
      );
    };
Function _StreamBuilder_initial$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.initial;
Function _StreamBuilder_afterConnected$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.afterConnected;
Function _StreamBuilder_afterData$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.afterData;
Function _StreamBuilder_afterError$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.afterError;
Function _StreamBuilder_afterDone$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.afterDone;
Function _StreamBuilder_afterDisconnected$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.afterDisconnected;
Function _StreamBuilder_build$<T>(
  m.Scope scope$,
  StreamBuilder<T> target$,
) =>
    target$.build;
Function FutureBuilder_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FutureBuilder<T>;
Function FutureBuilder_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FutureBuilder<T>;
Function _FutureBuilder_future$<T>(
  m.Scope scope$,
  FutureBuilder<T> target$,
) =>
    () {
      return target$.future;
    };
Function _FutureBuilder_builder$<T>(
  m.Scope scope$,
  FutureBuilder<T> target$,
) =>
    () {
      return target$.builder;
    };
Function _FutureBuilder_initialData$<T>(
  m.Scope scope$,
  FutureBuilder<T> target$,
) =>
    () {
      return target$.initialData;
    };
bool _FutureBuilder_debugRethrowError$() {
  return FutureBuilder.debugRethrowError;
}

void _FutureBuilder_debugRethrowError_set$(bool other$) {
  FutureBuilder.debugRethrowError = other$;
}

Function _FutureBuilder__$(m.Scope scope$) => ({
      Key? key,
      Future? future,
      dynamic? initialData,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        AsyncSnapshot builder_snapshot$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [
              builder_context$,
              builder_snapshot$,
            ],
            {},
          );
      return FutureBuilder(
        builder: builderProxy,
        future: future,
        initialData: initialData,
        key: key,
      );
    };
Function _FutureBuilder_createState$<T>(
  m.Scope scope$,
  FutureBuilder<T> target$,
) =>
    target$.createState;
ConnectionState _ConnectionState_none$() {
  return ConnectionState.none;
}

ConnectionState _ConnectionState_waiting$() {
  return ConnectionState.waiting;
}

ConnectionState _ConnectionState_active$() {
  return ConnectionState.active;
}

ConnectionState _ConnectionState_done$() {
  return ConnectionState.done;
}

List<ConnectionState> _ConnectionState_values$() {
  return ConnectionState.values;
}
