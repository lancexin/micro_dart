// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/async.dart';
import 'dart:async' show StreamSubscription;
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/framework.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/async.dart',
  {
    'FutureBuilder.debugRethrowError': _FutureBuilder_debugRethrowError$,
    'ConnectionState.none': _ConnectionState_none$,
    'ConnectionState.waiting': _ConnectionState_waiting$,
    'ConnectionState.active': _ConnectionState_active$,
    'ConnectionState.done': _ConnectionState_done$,
    'ConnectionState.values': _ConnectionState_values$,
  },
  {'FutureBuilder.debugRethrowError': _FutureBuilder_debugRethrowError_set$},
  {
    'StreamBuilderBase': m.ClassMirror(
      'StreamBuilderBase',
      {
        'stream': _StreamBuilderBase_stream$,
        'initial': _StreamBuilderBase_initial$,
        'afterConnected': _StreamBuilderBase_afterConnected$,
        'afterData': _StreamBuilderBase_afterData$,
        'afterError': _StreamBuilderBase_afterError$,
        'afterDone': _StreamBuilderBase_afterDone$,
        'afterDisconnected': _StreamBuilderBase_afterDisconnected$,
        'build': _StreamBuilderBase_build$,
        'createState': _StreamBuilderBase_createState$,
      },
      {},
    ),
    'AsyncSnapshot': m.ClassMirror(
      'AsyncSnapshot',
      {
        'connectionState': _AsyncSnapshot_connectionState$,
        'data': _AsyncSnapshot_data$,
        'error': _AsyncSnapshot_error$,
        'stackTrace': _AsyncSnapshot_stackTrace$,
        'requireData': _AsyncSnapshot_requireData$,
        'hasData': _AsyncSnapshot_hasData$,
        'hasError': _AsyncSnapshot_hasError$,
        'hashCode': _AsyncSnapshot_hashCode$,
        'inState': _AsyncSnapshot_inState$,
        'toString': _AsyncSnapshot_toString$,
      },
      {},
    ),
    'StreamBuilder': m.ClassMirror(
      'StreamBuilder',
      {
        'builder': _StreamBuilder_builder$,
        'initialData': _StreamBuilder_initialData$,
        'initial': _StreamBuilder_initial$,
        'afterConnected': _StreamBuilder_afterConnected$,
        'afterData': _StreamBuilder_afterData$,
        'afterError': _StreamBuilder_afterError$,
        'afterDone': _StreamBuilder_afterDone$,
        'afterDisconnected': _StreamBuilder_afterDisconnected$,
        'build': _StreamBuilder_build$,
      },
      {},
    ),
    'FutureBuilder': m.ClassMirror(
      'FutureBuilder',
      {
        'future': _FutureBuilder_future$,
        'builder': _FutureBuilder_builder$,
        'initialData': _FutureBuilder_initialData$,
        'createState': _FutureBuilder_createState$,
      },
      {},
    ),
    'ConnectionState': m.ClassMirror(
      'ConnectionState',
      {},
      {},
    ),
  },
);
Stream<T>? _StreamBuilderBase_stream$<T, S>(StreamBuilderBase<T, S> target) {
  return target.stream;
}

Function _StreamBuilderBase_initial$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.initial;
Function _StreamBuilderBase_afterConnected$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.afterConnected;
Function _StreamBuilderBase_afterData$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.afterData;
Function _StreamBuilderBase_afterError$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.afterError;
Function _StreamBuilderBase_afterDone$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.afterDone;
Function _StreamBuilderBase_afterDisconnected$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.afterDisconnected;
Function _StreamBuilderBase_build$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.build;
Function _StreamBuilderBase_createState$<T, S>(
  m.Scope scope,
  StreamBuilderBase<T, S> target,
) =>
    target.createState;
ConnectionState _AsyncSnapshot_connectionState$<T>(AsyncSnapshot<T> target) {
  return target.connectionState;
}

T? _AsyncSnapshot_data$<T>(AsyncSnapshot<T> target) {
  return target.data;
}

Object? _AsyncSnapshot_error$<T>(AsyncSnapshot<T> target) {
  return target.error;
}

StackTrace? _AsyncSnapshot_stackTrace$<T>(AsyncSnapshot<T> target) {
  return target.stackTrace;
}

T _AsyncSnapshot_requireData$<T>(AsyncSnapshot<T> target) {
  return target.requireData;
}

bool _AsyncSnapshot_hasData$<T>(AsyncSnapshot<T> target) {
  return target.hasData;
}

bool _AsyncSnapshot_hasError$<T>(AsyncSnapshot<T> target) {
  return target.hasError;
}

int _AsyncSnapshot_hashCode$<T>(AsyncSnapshot<T> target) {
  return target.hashCode;
}

Function _AsyncSnapshot_inState$<T>(
  m.Scope scope,
  AsyncSnapshot<T> target,
) =>
    target.inState;
Function _AsyncSnapshot_toString$<T>(
  m.Scope scope,
  AsyncSnapshot<T> target,
) =>
    target.toString;
Widget Function(BuildContext, AsyncSnapshot<T>) _StreamBuilder_builder$<T>(
    StreamBuilder<T> target) {
  return target.builder;
}

T? _StreamBuilder_initialData$<T>(StreamBuilder<T> target) {
  return target.initialData;
}

Function _StreamBuilder_initial$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.initial;
Function _StreamBuilder_afterConnected$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.afterConnected;
Function _StreamBuilder_afterData$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.afterData;
Function _StreamBuilder_afterError$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.afterError;
Function _StreamBuilder_afterDone$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.afterDone;
Function _StreamBuilder_afterDisconnected$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.afterDisconnected;
Function _StreamBuilder_build$<T>(
  m.Scope scope,
  StreamBuilder<T> target,
) =>
    target.build;
Future<T>? _FutureBuilder_future$<T>(FutureBuilder<T> target) {
  return target.future;
}

Widget Function(BuildContext, AsyncSnapshot<T>) _FutureBuilder_builder$<T>(
    FutureBuilder<T> target) {
  return target.builder;
}

T? _FutureBuilder_initialData$<T>(FutureBuilder<T> target) {
  return target.initialData;
}

bool _FutureBuilder_debugRethrowError$() {
  return FutureBuilder.debugRethrowError;
}

void _FutureBuilder_debugRethrowError_set$(bool other) {
  FutureBuilder.debugRethrowError = other;
}

Function _FutureBuilder_createState$<T>(
  m.Scope scope,
  FutureBuilder<T> target,
) =>
    target.createState;
ConnectionState _ConnectionState_none$() {
  return ConnectionState.none;
}

ConnectionState _ConnectionState_waiting$() {
  return ConnectionState.waiting;
}

ConnectionState _ConnectionState_active$() {
  return ConnectionState.active;
}

ConnectionState _ConnectionState_done$() {
  return ConnectionState.done;
}

List<ConnectionState> _ConnectionState_values$() {
  return ConnectionState.values;
}
