// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/tap_and_drag_gestures.dart';
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart'
    show HardwareKeyboard, LogicalKeyboardKey;
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/tap_and_drag_gestures.dart',
  {},
  {},
  {
    'TapDragDownDetails': m.ClassMirror(
      'TapDragDownDetails',
      {
        'globalPosition': _TapDragDownDetails_globalPosition$,
        'localPosition': _TapDragDownDetails_localPosition$,
        'kind': _TapDragDownDetails_kind$,
        'consecutiveTapCount': _TapDragDownDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragDownDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragDownDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragUpDetails': m.ClassMirror(
      'TapDragUpDetails',
      {
        'globalPosition': _TapDragUpDetails_globalPosition$,
        'localPosition': _TapDragUpDetails_localPosition$,
        'kind': _TapDragUpDetails_kind$,
        'consecutiveTapCount': _TapDragUpDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragUpDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragUpDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragStartDetails': m.ClassMirror(
      'TapDragStartDetails',
      {
        'sourceTimeStamp': _TapDragStartDetails_sourceTimeStamp$,
        'globalPosition': _TapDragStartDetails_globalPosition$,
        'localPosition': _TapDragStartDetails_localPosition$,
        'kind': _TapDragStartDetails_kind$,
        'consecutiveTapCount': _TapDragStartDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragStartDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragStartDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragUpdateDetails': m.ClassMirror(
      'TapDragUpdateDetails',
      {
        'sourceTimeStamp': _TapDragUpdateDetails_sourceTimeStamp$,
        'delta': _TapDragUpdateDetails_delta$,
        'primaryDelta': _TapDragUpdateDetails_primaryDelta$,
        'globalPosition': _TapDragUpdateDetails_globalPosition$,
        'localPosition': _TapDragUpdateDetails_localPosition$,
        'kind': _TapDragUpdateDetails_kind$,
        'offsetFromOrigin': _TapDragUpdateDetails_offsetFromOrigin$,
        'localOffsetFromOrigin': _TapDragUpdateDetails_localOffsetFromOrigin$,
        'consecutiveTapCount': _TapDragUpdateDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragUpdateDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragUpdateDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragEndDetails': m.ClassMirror(
      'TapDragEndDetails',
      {
        'velocity': _TapDragEndDetails_velocity$,
        'primaryVelocity': _TapDragEndDetails_primaryVelocity$,
        'consecutiveTapCount': _TapDragEndDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragEndDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragEndDetails_debugFillProperties$,
      },
      {},
    ),
    'BaseTapAndDragGestureRecognizer': m.ClassMirror(
      'BaseTapAndDragGestureRecognizer',
      {
        'dragStartBehavior':
            _BaseTapAndDragGestureRecognizer_dragStartBehavior$,
        'dragUpdateThrottleFrequency':
            _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency$,
        'maxConsecutiveTap':
            _BaseTapAndDragGestureRecognizer_maxConsecutiveTap$,
        'onTapDown': _BaseTapAndDragGestureRecognizer_onTapDown$,
        'onTapUp': _BaseTapAndDragGestureRecognizer_onTapUp$,
        'onDragStart': _BaseTapAndDragGestureRecognizer_onDragStart$,
        'onDragUpdate': _BaseTapAndDragGestureRecognizer_onDragUpdate$,
        'onDragEnd': _BaseTapAndDragGestureRecognizer_onDragEnd$,
        'onCancel': _BaseTapAndDragGestureRecognizer_onCancel$,
        'debugDescription': _BaseTapAndDragGestureRecognizer_debugDescription$,
        'isPointerAllowed': _BaseTapAndDragGestureRecognizer_isPointerAllowed$,
        'addAllowedPointer':
            _BaseTapAndDragGestureRecognizer_addAllowedPointer$,
        'handleNonAllowedPointer':
            _BaseTapAndDragGestureRecognizer_handleNonAllowedPointer$,
        'acceptGesture': _BaseTapAndDragGestureRecognizer_acceptGesture$,
        'didStopTrackingLastPointer':
            _BaseTapAndDragGestureRecognizer_didStopTrackingLastPointer$,
        'handleEvent': _BaseTapAndDragGestureRecognizer_handleEvent$,
        'rejectGesture': _BaseTapAndDragGestureRecognizer_rejectGesture$,
        'dispose': _BaseTapAndDragGestureRecognizer_dispose$,
      },
      {
        'dragStartBehavior':
            _BaseTapAndDragGestureRecognizer_dragStartBehavior_set$,
        'dragUpdateThrottleFrequency':
            _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency_set$,
        'maxConsecutiveTap':
            _BaseTapAndDragGestureRecognizer_maxConsecutiveTap_set$,
        'onTapDown': _BaseTapAndDragGestureRecognizer_onTapDown_set$,
        'onTapUp': _BaseTapAndDragGestureRecognizer_onTapUp_set$,
        'onDragStart': _BaseTapAndDragGestureRecognizer_onDragStart_set$,
        'onDragUpdate': _BaseTapAndDragGestureRecognizer_onDragUpdate_set$,
        'onDragEnd': _BaseTapAndDragGestureRecognizer_onDragEnd_set$,
        'onCancel': _BaseTapAndDragGestureRecognizer_onCancel_set$,
      },
    ),
    'TapAndHorizontalDragGestureRecognizer': m.ClassMirror(
      'TapAndHorizontalDragGestureRecognizer',
      {
        'debugDescription':
            _TapAndHorizontalDragGestureRecognizer_debugDescription$
      },
      {},
    ),
    'TapAndPanGestureRecognizer': m.ClassMirror(
      'TapAndPanGestureRecognizer',
      {'debugDescription': _TapAndPanGestureRecognizer_debugDescription$},
      {},
    ),
  },
);
Offset _TapDragDownDetails_globalPosition$(TapDragDownDetails target) {
  return target.globalPosition;
}

Offset _TapDragDownDetails_localPosition$(TapDragDownDetails target) {
  return target.localPosition;
}

PointerDeviceKind? _TapDragDownDetails_kind$(TapDragDownDetails target) {
  return target.kind;
}

int _TapDragDownDetails_consecutiveTapCount$(TapDragDownDetails target) {
  return target.consecutiveTapCount;
}

Set<LogicalKeyboardKey> _TapDragDownDetails_keysPressedOnDown$(
    TapDragDownDetails target) {
  return target.keysPressedOnDown;
}

Function _TapDragDownDetails_debugFillProperties$(
  m.Scope scope,
  TapDragDownDetails target,
) =>
    target.debugFillProperties;
Offset _TapDragUpDetails_globalPosition$(TapDragUpDetails target) {
  return target.globalPosition;
}

Offset _TapDragUpDetails_localPosition$(TapDragUpDetails target) {
  return target.localPosition;
}

PointerDeviceKind _TapDragUpDetails_kind$(TapDragUpDetails target) {
  return target.kind;
}

int _TapDragUpDetails_consecutiveTapCount$(TapDragUpDetails target) {
  return target.consecutiveTapCount;
}

Set<LogicalKeyboardKey> _TapDragUpDetails_keysPressedOnDown$(
    TapDragUpDetails target) {
  return target.keysPressedOnDown;
}

Function _TapDragUpDetails_debugFillProperties$(
  m.Scope scope,
  TapDragUpDetails target,
) =>
    target.debugFillProperties;
Duration? _TapDragStartDetails_sourceTimeStamp$(TapDragStartDetails target) {
  return target.sourceTimeStamp;
}

Offset _TapDragStartDetails_globalPosition$(TapDragStartDetails target) {
  return target.globalPosition;
}

Offset _TapDragStartDetails_localPosition$(TapDragStartDetails target) {
  return target.localPosition;
}

PointerDeviceKind? _TapDragStartDetails_kind$(TapDragStartDetails target) {
  return target.kind;
}

int _TapDragStartDetails_consecutiveTapCount$(TapDragStartDetails target) {
  return target.consecutiveTapCount;
}

Set<LogicalKeyboardKey> _TapDragStartDetails_keysPressedOnDown$(
    TapDragStartDetails target) {
  return target.keysPressedOnDown;
}

Function _TapDragStartDetails_debugFillProperties$(
  m.Scope scope,
  TapDragStartDetails target,
) =>
    target.debugFillProperties;
Duration? _TapDragUpdateDetails_sourceTimeStamp$(TapDragUpdateDetails target) {
  return target.sourceTimeStamp;
}

Offset _TapDragUpdateDetails_delta$(TapDragUpdateDetails target) {
  return target.delta;
}

double? _TapDragUpdateDetails_primaryDelta$(TapDragUpdateDetails target) {
  return target.primaryDelta;
}

Offset _TapDragUpdateDetails_globalPosition$(TapDragUpdateDetails target) {
  return target.globalPosition;
}

Offset _TapDragUpdateDetails_localPosition$(TapDragUpdateDetails target) {
  return target.localPosition;
}

PointerDeviceKind? _TapDragUpdateDetails_kind$(TapDragUpdateDetails target) {
  return target.kind;
}

Offset _TapDragUpdateDetails_offsetFromOrigin$(TapDragUpdateDetails target) {
  return target.offsetFromOrigin;
}

Offset _TapDragUpdateDetails_localOffsetFromOrigin$(
    TapDragUpdateDetails target) {
  return target.localOffsetFromOrigin;
}

int _TapDragUpdateDetails_consecutiveTapCount$(TapDragUpdateDetails target) {
  return target.consecutiveTapCount;
}

Set<LogicalKeyboardKey> _TapDragUpdateDetails_keysPressedOnDown$(
    TapDragUpdateDetails target) {
  return target.keysPressedOnDown;
}

Function _TapDragUpdateDetails_debugFillProperties$(
  m.Scope scope,
  TapDragUpdateDetails target,
) =>
    target.debugFillProperties;
Velocity _TapDragEndDetails_velocity$(TapDragEndDetails target) {
  return target.velocity;
}

double? _TapDragEndDetails_primaryVelocity$(TapDragEndDetails target) {
  return target.primaryVelocity;
}

int _TapDragEndDetails_consecutiveTapCount$(TapDragEndDetails target) {
  return target.consecutiveTapCount;
}

Set<LogicalKeyboardKey> _TapDragEndDetails_keysPressedOnDown$(
    TapDragEndDetails target) {
  return target.keysPressedOnDown;
}

Function _TapDragEndDetails_debugFillProperties$(
  m.Scope scope,
  TapDragEndDetails target,
) =>
    target.debugFillProperties;
DragStartBehavior _BaseTapAndDragGestureRecognizer_dragStartBehavior$(
    BaseTapAndDragGestureRecognizer target) {
  return target.dragStartBehavior;
}

void _BaseTapAndDragGestureRecognizer_dragStartBehavior_set$(
  BaseTapAndDragGestureRecognizer target,
  DragStartBehavior other,
) {
  target.dragStartBehavior = other;
}

Duration? _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency$(
    BaseTapAndDragGestureRecognizer target) {
  return target.dragUpdateThrottleFrequency;
}

void _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency_set$(
  BaseTapAndDragGestureRecognizer target,
  Duration? other,
) {
  target.dragUpdateThrottleFrequency = other;
}

int? _BaseTapAndDragGestureRecognizer_maxConsecutiveTap$(
    BaseTapAndDragGestureRecognizer target) {
  return target.maxConsecutiveTap;
}

void _BaseTapAndDragGestureRecognizer_maxConsecutiveTap_set$(
  BaseTapAndDragGestureRecognizer target,
  int? other,
) {
  target.maxConsecutiveTap = other;
}

void Function(TapDragDownDetails)? _BaseTapAndDragGestureRecognizer_onTapDown$(
    BaseTapAndDragGestureRecognizer target) {
  return target.onTapDown;
}

Function _BaseTapAndDragGestureRecognizer_onTapDown_set$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onTapDown) {
      void _onTapDownProxy(TapDragDownDetails _onTapDown_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onTapDown!,
            [_onTapDown_details],
            {},
          );
      target.onTapDown = (_onTapDown == null ? null : _onTapDownProxy);
    };
void Function(TapDragUpDetails)? _BaseTapAndDragGestureRecognizer_onTapUp$(
    BaseTapAndDragGestureRecognizer target) {
  return target.onTapUp;
}

Function _BaseTapAndDragGestureRecognizer_onTapUp_set$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onTapUp) {
      void _onTapUpProxy(TapDragUpDetails _onTapUp_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onTapUp!,
            [_onTapUp_details],
            {},
          );
      target.onTapUp = (_onTapUp == null ? null : _onTapUpProxy);
    };
void Function(TapDragStartDetails)?
    _BaseTapAndDragGestureRecognizer_onDragStart$(
        BaseTapAndDragGestureRecognizer target) {
  return target.onDragStart;
}

Function _BaseTapAndDragGestureRecognizer_onDragStart_set$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onDragStart) {
      void _onDragStartProxy(TapDragStartDetails _onDragStart_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onDragStart!,
            [_onDragStart_details],
            {},
          );
      target.onDragStart = (_onDragStart == null ? null : _onDragStartProxy);
    };
void Function(TapDragUpdateDetails)?
    _BaseTapAndDragGestureRecognizer_onDragUpdate$(
        BaseTapAndDragGestureRecognizer target) {
  return target.onDragUpdate;
}

Function _BaseTapAndDragGestureRecognizer_onDragUpdate_set$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onDragUpdate) {
      void _onDragUpdateProxy(TapDragUpdateDetails _onDragUpdate_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onDragUpdate!,
            [_onDragUpdate_details],
            {},
          );
      target.onDragUpdate = (_onDragUpdate == null ? null : _onDragUpdateProxy);
    };
void Function(TapDragEndDetails)? _BaseTapAndDragGestureRecognizer_onDragEnd$(
    BaseTapAndDragGestureRecognizer target) {
  return target.onDragEnd;
}

Function _BaseTapAndDragGestureRecognizer_onDragEnd_set$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onDragEnd) {
      void _onDragEndProxy(TapDragEndDetails _onDragEnd_endDetails) =>
          scope.engine.callFunctionPointer(
            scope,
            _onDragEnd!,
            [_onDragEnd_endDetails],
            {},
          );
      target.onDragEnd = (_onDragEnd == null ? null : _onDragEndProxy);
    };
void Function()? _BaseTapAndDragGestureRecognizer_onCancel$(
    BaseTapAndDragGestureRecognizer target) {
  return target.onCancel;
}

Function _BaseTapAndDragGestureRecognizer_onCancel_set$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onCancel) {
      void _onCancelProxy() => scope.engine.callFunctionPointer(
            scope,
            _onCancel!,
            [],
            {},
          );
      target.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
String _BaseTapAndDragGestureRecognizer_debugDescription$(
    BaseTapAndDragGestureRecognizer target) {
  return target.debugDescription;
}

Function _BaseTapAndDragGestureRecognizer_isPointerAllowed$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.isPointerAllowed;
Function _BaseTapAndDragGestureRecognizer_addAllowedPointer$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.addAllowedPointer;
Function _BaseTapAndDragGestureRecognizer_handleNonAllowedPointer$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.handleNonAllowedPointer;
Function _BaseTapAndDragGestureRecognizer_acceptGesture$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.acceptGesture;
Function _BaseTapAndDragGestureRecognizer_didStopTrackingLastPointer$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.didStopTrackingLastPointer;
Function _BaseTapAndDragGestureRecognizer_handleEvent$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.handleEvent;
Function _BaseTapAndDragGestureRecognizer_rejectGesture$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.rejectGesture;
Function _BaseTapAndDragGestureRecognizer_dispose$(
  m.Scope scope,
  BaseTapAndDragGestureRecognizer target,
) =>
    target.dispose;
String _TapAndHorizontalDragGestureRecognizer_debugDescription$(
    TapAndHorizontalDragGestureRecognizer target) {
  return target.debugDescription;
}

String _TapAndPanGestureRecognizer_debugDescription$(
    TapAndPanGestureRecognizer target) {
  return target.debugDescription;
}
