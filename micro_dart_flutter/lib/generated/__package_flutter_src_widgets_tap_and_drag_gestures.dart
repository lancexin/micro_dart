// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/tap_and_drag_gestures.dart';
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart'
    show HardwareKeyboard, LogicalKeyboardKey;
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/tap_and_drag_gestures.dart',
  {
    'TapDragDownDetails.': _TapDragDownDetails__$,
    'TapDragUpDetails.': _TapDragUpDetails__$,
    'TapDragStartDetails.': _TapDragStartDetails__$,
    'TapDragUpdateDetails.': _TapDragUpdateDetails__$,
    'TapDragEndDetails.': _TapDragEndDetails__$,
    'TapAndHorizontalDragGestureRecognizer.':
        _TapAndHorizontalDragGestureRecognizer__$,
    'TapAndPanGestureRecognizer.': _TapAndPanGestureRecognizer__$,
  },
  {},
  {
    'TapDragDownDetails': m.ClassMirror(
      'TapDragDownDetails',
      {
        '#as': TapDragDownDetails_as$,
        '#is': TapDragDownDetails_is$,
        'globalPosition': _TapDragDownDetails_globalPosition$,
        'localPosition': _TapDragDownDetails_localPosition$,
        'kind': _TapDragDownDetails_kind$,
        'consecutiveTapCount': _TapDragDownDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragDownDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragDownDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragUpDetails': m.ClassMirror(
      'TapDragUpDetails',
      {
        '#as': TapDragUpDetails_as$,
        '#is': TapDragUpDetails_is$,
        'globalPosition': _TapDragUpDetails_globalPosition$,
        'localPosition': _TapDragUpDetails_localPosition$,
        'kind': _TapDragUpDetails_kind$,
        'consecutiveTapCount': _TapDragUpDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragUpDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragUpDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragStartDetails': m.ClassMirror(
      'TapDragStartDetails',
      {
        '#as': TapDragStartDetails_as$,
        '#is': TapDragStartDetails_is$,
        'sourceTimeStamp': _TapDragStartDetails_sourceTimeStamp$,
        'globalPosition': _TapDragStartDetails_globalPosition$,
        'localPosition': _TapDragStartDetails_localPosition$,
        'kind': _TapDragStartDetails_kind$,
        'consecutiveTapCount': _TapDragStartDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragStartDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragStartDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragUpdateDetails': m.ClassMirror(
      'TapDragUpdateDetails',
      {
        '#as': TapDragUpdateDetails_as$,
        '#is': TapDragUpdateDetails_is$,
        'sourceTimeStamp': _TapDragUpdateDetails_sourceTimeStamp$,
        'delta': _TapDragUpdateDetails_delta$,
        'primaryDelta': _TapDragUpdateDetails_primaryDelta$,
        'globalPosition': _TapDragUpdateDetails_globalPosition$,
        'localPosition': _TapDragUpdateDetails_localPosition$,
        'kind': _TapDragUpdateDetails_kind$,
        'offsetFromOrigin': _TapDragUpdateDetails_offsetFromOrigin$,
        'localOffsetFromOrigin': _TapDragUpdateDetails_localOffsetFromOrigin$,
        'consecutiveTapCount': _TapDragUpdateDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragUpdateDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragUpdateDetails_debugFillProperties$,
      },
      {},
    ),
    'TapDragEndDetails': m.ClassMirror(
      'TapDragEndDetails',
      {
        '#as': TapDragEndDetails_as$,
        '#is': TapDragEndDetails_is$,
        'velocity': _TapDragEndDetails_velocity$,
        'primaryVelocity': _TapDragEndDetails_primaryVelocity$,
        'consecutiveTapCount': _TapDragEndDetails_consecutiveTapCount$,
        'keysPressedOnDown': _TapDragEndDetails_keysPressedOnDown$,
        'debugFillProperties': _TapDragEndDetails_debugFillProperties$,
      },
      {},
    ),
    'BaseTapAndDragGestureRecognizer': m.ClassMirror(
      'BaseTapAndDragGestureRecognizer',
      {
        '#as': BaseTapAndDragGestureRecognizer_as$,
        '#is': BaseTapAndDragGestureRecognizer_is$,
        'dragStartBehavior':
            _BaseTapAndDragGestureRecognizer_dragStartBehavior$,
        'dragUpdateThrottleFrequency':
            _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency$,
        'maxConsecutiveTap':
            _BaseTapAndDragGestureRecognizer_maxConsecutiveTap$,
        'onTapDown': _BaseTapAndDragGestureRecognizer_onTapDown$,
        'onTapUp': _BaseTapAndDragGestureRecognizer_onTapUp$,
        'onDragStart': _BaseTapAndDragGestureRecognizer_onDragStart$,
        'onDragUpdate': _BaseTapAndDragGestureRecognizer_onDragUpdate$,
        'onDragEnd': _BaseTapAndDragGestureRecognizer_onDragEnd$,
        'onCancel': _BaseTapAndDragGestureRecognizer_onCancel$,
        'debugDescription': _BaseTapAndDragGestureRecognizer_debugDescription$,
        'isPointerAllowed': _BaseTapAndDragGestureRecognizer_isPointerAllowed$,
        'addAllowedPointer':
            _BaseTapAndDragGestureRecognizer_addAllowedPointer$,
        'handleNonAllowedPointer':
            _BaseTapAndDragGestureRecognizer_handleNonAllowedPointer$,
        'acceptGesture': _BaseTapAndDragGestureRecognizer_acceptGesture$,
        'didStopTrackingLastPointer':
            _BaseTapAndDragGestureRecognizer_didStopTrackingLastPointer$,
        'handleEvent': _BaseTapAndDragGestureRecognizer_handleEvent$,
        'rejectGesture': _BaseTapAndDragGestureRecognizer_rejectGesture$,
        'dispose': _BaseTapAndDragGestureRecognizer_dispose$,
      },
      {
        'dragStartBehavior':
            _BaseTapAndDragGestureRecognizer_dragStartBehavior_set$,
        'dragUpdateThrottleFrequency':
            _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency_set$,
        'maxConsecutiveTap':
            _BaseTapAndDragGestureRecognizer_maxConsecutiveTap_set$,
        'onTapDown': _BaseTapAndDragGestureRecognizer_onTapDown_set$,
        'onTapUp': _BaseTapAndDragGestureRecognizer_onTapUp_set$,
        'onDragStart': _BaseTapAndDragGestureRecognizer_onDragStart_set$,
        'onDragUpdate': _BaseTapAndDragGestureRecognizer_onDragUpdate_set$,
        'onDragEnd': _BaseTapAndDragGestureRecognizer_onDragEnd_set$,
        'onCancel': _BaseTapAndDragGestureRecognizer_onCancel_set$,
      },
    ),
    'TapAndHorizontalDragGestureRecognizer': m.ClassMirror(
      'TapAndHorizontalDragGestureRecognizer',
      {
        '#as': TapAndHorizontalDragGestureRecognizer_as$,
        '#is': TapAndHorizontalDragGestureRecognizer_is$,
        'debugDescription':
            _TapAndHorizontalDragGestureRecognizer_debugDescription$,
      },
      {},
    ),
    'TapAndPanGestureRecognizer': m.ClassMirror(
      'TapAndPanGestureRecognizer',
      {
        '#as': TapAndPanGestureRecognizer_as$,
        '#is': TapAndPanGestureRecognizer_is$,
        'debugDescription': _TapAndPanGestureRecognizer_debugDescription$,
      },
      {},
    ),
  },
);
Function TapDragDownDetails_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapDragDownDetails;
Function TapDragDownDetails_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapDragDownDetails;
Function _TapDragDownDetails_globalPosition$(
  m.Scope scope$,
  TapDragDownDetails target$,
) =>
    () {
      return target$.globalPosition;
    };
Function _TapDragDownDetails_localPosition$(
  m.Scope scope$,
  TapDragDownDetails target$,
) =>
    () {
      return target$.localPosition;
    };
Function _TapDragDownDetails_kind$(
  m.Scope scope$,
  TapDragDownDetails target$,
) =>
    () {
      return target$.kind;
    };
Function _TapDragDownDetails_consecutiveTapCount$(
  m.Scope scope$,
  TapDragDownDetails target$,
) =>
    () {
      return target$.consecutiveTapCount;
    };
Function _TapDragDownDetails_keysPressedOnDown$(
  m.Scope scope$,
  TapDragDownDetails target$,
) =>
    () {
      return target$.keysPressedOnDown;
    };
Function _TapDragDownDetails__$(m.Scope scope$) => ({
      required Offset globalPosition,
      required Offset localPosition,
      PointerDeviceKind? kind,
      required int consecutiveTapCount,
      required Set keysPressedOnDown,
    }) {
      return TapDragDownDetails(
        consecutiveTapCount: consecutiveTapCount,
        globalPosition: globalPosition,
        keysPressedOnDown: Set.from(keysPressedOnDown),
        kind: kind,
        localPosition: localPosition,
      );
    };
Function _TapDragDownDetails_debugFillProperties$(
  m.Scope scope$,
  TapDragDownDetails target$,
) =>
    target$.debugFillProperties;
Function TapDragUpDetails_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapDragUpDetails;
Function TapDragUpDetails_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapDragUpDetails;
Function _TapDragUpDetails_globalPosition$(
  m.Scope scope$,
  TapDragUpDetails target$,
) =>
    () {
      return target$.globalPosition;
    };
Function _TapDragUpDetails_localPosition$(
  m.Scope scope$,
  TapDragUpDetails target$,
) =>
    () {
      return target$.localPosition;
    };
Function _TapDragUpDetails_kind$(
  m.Scope scope$,
  TapDragUpDetails target$,
) =>
    () {
      return target$.kind;
    };
Function _TapDragUpDetails_consecutiveTapCount$(
  m.Scope scope$,
  TapDragUpDetails target$,
) =>
    () {
      return target$.consecutiveTapCount;
    };
Function _TapDragUpDetails_keysPressedOnDown$(
  m.Scope scope$,
  TapDragUpDetails target$,
) =>
    () {
      return target$.keysPressedOnDown;
    };
Function _TapDragUpDetails__$(m.Scope scope$) => ({
      required PointerDeviceKind kind,
      required Offset globalPosition,
      required Offset localPosition,
      required int consecutiveTapCount,
      required Set keysPressedOnDown,
    }) {
      return TapDragUpDetails(
        consecutiveTapCount: consecutiveTapCount,
        globalPosition: globalPosition,
        keysPressedOnDown: Set.from(keysPressedOnDown),
        kind: kind,
        localPosition: localPosition,
      );
    };
Function _TapDragUpDetails_debugFillProperties$(
  m.Scope scope$,
  TapDragUpDetails target$,
) =>
    target$.debugFillProperties;
Function TapDragStartDetails_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapDragStartDetails;
Function TapDragStartDetails_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapDragStartDetails;
Function _TapDragStartDetails_sourceTimeStamp$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    () {
      return target$.sourceTimeStamp;
    };
Function _TapDragStartDetails_globalPosition$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    () {
      return target$.globalPosition;
    };
Function _TapDragStartDetails_localPosition$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    () {
      return target$.localPosition;
    };
Function _TapDragStartDetails_kind$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    () {
      return target$.kind;
    };
Function _TapDragStartDetails_consecutiveTapCount$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    () {
      return target$.consecutiveTapCount;
    };
Function _TapDragStartDetails_keysPressedOnDown$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    () {
      return target$.keysPressedOnDown;
    };
Function _TapDragStartDetails__$(m.Scope scope$) => ({
      Duration? sourceTimeStamp,
      required Offset globalPosition,
      required Offset localPosition,
      PointerDeviceKind? kind,
      required int consecutiveTapCount,
      required Set keysPressedOnDown,
    }) {
      return TapDragStartDetails(
        consecutiveTapCount: consecutiveTapCount,
        globalPosition: globalPosition,
        keysPressedOnDown: Set.from(keysPressedOnDown),
        kind: kind,
        localPosition: localPosition,
        sourceTimeStamp: sourceTimeStamp,
      );
    };
Function _TapDragStartDetails_debugFillProperties$(
  m.Scope scope$,
  TapDragStartDetails target$,
) =>
    target$.debugFillProperties;
Function TapDragUpdateDetails_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapDragUpdateDetails;
Function TapDragUpdateDetails_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapDragUpdateDetails;
Function _TapDragUpdateDetails_sourceTimeStamp$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.sourceTimeStamp;
    };
Function _TapDragUpdateDetails_delta$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.delta;
    };
Function _TapDragUpdateDetails_primaryDelta$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.primaryDelta;
    };
Function _TapDragUpdateDetails_globalPosition$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.globalPosition;
    };
Function _TapDragUpdateDetails_localPosition$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.localPosition;
    };
Function _TapDragUpdateDetails_kind$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.kind;
    };
Function _TapDragUpdateDetails_offsetFromOrigin$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.offsetFromOrigin;
    };
Function _TapDragUpdateDetails_localOffsetFromOrigin$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.localOffsetFromOrigin;
    };
Function _TapDragUpdateDetails_consecutiveTapCount$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.consecutiveTapCount;
    };
Function _TapDragUpdateDetails_keysPressedOnDown$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    () {
      return target$.keysPressedOnDown;
    };
Function _TapDragUpdateDetails__$(m.Scope scope$) => ({
      Duration? sourceTimeStamp,
      Offset? delta,
      double? primaryDelta,
      required Offset globalPosition,
      PointerDeviceKind? kind,
      required Offset localPosition,
      required Offset offsetFromOrigin,
      required Offset localOffsetFromOrigin,
      required int consecutiveTapCount,
      required Set keysPressedOnDown,
    }) {
      return TapDragUpdateDetails(
        consecutiveTapCount: consecutiveTapCount,
        delta: delta ?? Offset.zero,
        globalPosition: globalPosition,
        keysPressedOnDown: Set.from(keysPressedOnDown),
        kind: kind,
        localOffsetFromOrigin: localOffsetFromOrigin,
        localPosition: localPosition,
        offsetFromOrigin: offsetFromOrigin,
        primaryDelta: primaryDelta,
        sourceTimeStamp: sourceTimeStamp,
      );
    };
Function _TapDragUpdateDetails_debugFillProperties$(
  m.Scope scope$,
  TapDragUpdateDetails target$,
) =>
    target$.debugFillProperties;
Function TapDragEndDetails_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapDragEndDetails;
Function TapDragEndDetails_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapDragEndDetails;
Function _TapDragEndDetails_velocity$(
  m.Scope scope$,
  TapDragEndDetails target$,
) =>
    () {
      return target$.velocity;
    };
Function _TapDragEndDetails_primaryVelocity$(
  m.Scope scope$,
  TapDragEndDetails target$,
) =>
    () {
      return target$.primaryVelocity;
    };
Function _TapDragEndDetails_consecutiveTapCount$(
  m.Scope scope$,
  TapDragEndDetails target$,
) =>
    () {
      return target$.consecutiveTapCount;
    };
Function _TapDragEndDetails_keysPressedOnDown$(
  m.Scope scope$,
  TapDragEndDetails target$,
) =>
    () {
      return target$.keysPressedOnDown;
    };
Function _TapDragEndDetails__$(m.Scope scope$) => ({
      Velocity? velocity,
      double? primaryVelocity,
      required int consecutiveTapCount,
      required Set keysPressedOnDown,
    }) {
      return TapDragEndDetails(
        consecutiveTapCount: consecutiveTapCount,
        keysPressedOnDown: Set.from(keysPressedOnDown),
        primaryVelocity: primaryVelocity,
        velocity: velocity ?? Velocity.zero,
      );
    };
Function _TapDragEndDetails_debugFillProperties$(
  m.Scope scope$,
  TapDragEndDetails target$,
) =>
    target$.debugFillProperties;
Function BaseTapAndDragGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BaseTapAndDragGestureRecognizer;
Function BaseTapAndDragGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BaseTapAndDragGestureRecognizer;
Function _BaseTapAndDragGestureRecognizer_dragStartBehavior$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.dragStartBehavior;
    };
void _BaseTapAndDragGestureRecognizer_dragStartBehavior_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.dragStartBehavior = other$;
    };
Function _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.dragUpdateThrottleFrequency;
    };
void _BaseTapAndDragGestureRecognizer_dragUpdateThrottleFrequency_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.dragUpdateThrottleFrequency = other$;
    };
Function _BaseTapAndDragGestureRecognizer_maxConsecutiveTap$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.maxConsecutiveTap;
    };
void _BaseTapAndDragGestureRecognizer_maxConsecutiveTap_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.maxConsecutiveTap = other$;
    };
Function _BaseTapAndDragGestureRecognizer_onTapDown$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.onTapDown;
    };
Function _BaseTapAndDragGestureRecognizer_onTapDown_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onTapDown) {
      void _onTapDownProxy(TapDragDownDetails _onTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onTapDown!,
            [_onTapDown_details$],
            {},
          );
      target$.onTapDown = (_onTapDown == null ? null : _onTapDownProxy);
    };
Function _BaseTapAndDragGestureRecognizer_onTapUp$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.onTapUp;
    };
Function _BaseTapAndDragGestureRecognizer_onTapUp_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onTapUp) {
      void _onTapUpProxy(TapDragUpDetails _onTapUp_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onTapUp!,
            [_onTapUp_details$],
            {},
          );
      target$.onTapUp = (_onTapUp == null ? null : _onTapUpProxy);
    };
Function _BaseTapAndDragGestureRecognizer_onDragStart$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.onDragStart;
    };
Function _BaseTapAndDragGestureRecognizer_onDragStart_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onDragStart) {
      void _onDragStartProxy(TapDragStartDetails _onDragStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onDragStart!,
            [_onDragStart_details$],
            {},
          );
      target$.onDragStart = (_onDragStart == null ? null : _onDragStartProxy);
    };
Function _BaseTapAndDragGestureRecognizer_onDragUpdate$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.onDragUpdate;
    };
Function _BaseTapAndDragGestureRecognizer_onDragUpdate_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onDragUpdate) {
      void _onDragUpdateProxy(TapDragUpdateDetails _onDragUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onDragUpdate!,
            [_onDragUpdate_details$],
            {},
          );
      target$.onDragUpdate =
          (_onDragUpdate == null ? null : _onDragUpdateProxy);
    };
Function _BaseTapAndDragGestureRecognizer_onDragEnd$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.onDragEnd;
    };
Function _BaseTapAndDragGestureRecognizer_onDragEnd_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onDragEnd) {
      void _onDragEndProxy(TapDragEndDetails _onDragEnd_endDetails$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onDragEnd!,
            [_onDragEnd_endDetails$],
            {},
          );
      target$.onDragEnd = (_onDragEnd == null ? null : _onDragEndProxy);
    };
Function _BaseTapAndDragGestureRecognizer_onCancel$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.onCancel;
    };
Function _BaseTapAndDragGestureRecognizer_onCancel_set$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onCancel) {
      void _onCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onCancel!,
            [],
            {},
          );
      target$.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
Function _BaseTapAndDragGestureRecognizer_debugDescription$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    () {
      return target$.debugDescription;
    };
Function _BaseTapAndDragGestureRecognizer_isPointerAllowed$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.isPointerAllowed;
Function _BaseTapAndDragGestureRecognizer_addAllowedPointer$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.addAllowedPointer;
Function _BaseTapAndDragGestureRecognizer_handleNonAllowedPointer$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.handleNonAllowedPointer;
Function _BaseTapAndDragGestureRecognizer_acceptGesture$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.acceptGesture;
Function _BaseTapAndDragGestureRecognizer_didStopTrackingLastPointer$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.didStopTrackingLastPointer;
Function _BaseTapAndDragGestureRecognizer_handleEvent$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.handleEvent;
Function _BaseTapAndDragGestureRecognizer_rejectGesture$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.rejectGesture;
Function _BaseTapAndDragGestureRecognizer_dispose$(
  m.Scope scope$,
  BaseTapAndDragGestureRecognizer target$,
) =>
    target$.dispose;
Function TapAndHorizontalDragGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapAndHorizontalDragGestureRecognizer;
Function TapAndHorizontalDragGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapAndHorizontalDragGestureRecognizer;
Function _TapAndHorizontalDragGestureRecognizer_debugDescription$(
  m.Scope scope$,
  TapAndHorizontalDragGestureRecognizer target$,
) =>
    () {
      return target$.debugDescription;
    };
Function _TapAndHorizontalDragGestureRecognizer__$(m.Scope scope$) => ({
      Object? debugOwner,
      Set? supportedDevices,
    }) {
      return TapAndHorizontalDragGestureRecognizer(
        debugOwner: debugOwner,
        supportedDevices:
            supportedDevices == null ? null : Set.from(supportedDevices),
      );
    };
Function TapAndPanGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TapAndPanGestureRecognizer;
Function TapAndPanGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TapAndPanGestureRecognizer;
Function _TapAndPanGestureRecognizer_debugDescription$(
  m.Scope scope$,
  TapAndPanGestureRecognizer target$,
) =>
    () {
      return target$.debugDescription;
    };
Function _TapAndPanGestureRecognizer__$(m.Scope scope$) => ({
      Object? debugOwner,
      Set? supportedDevices,
    }) {
      return TapAndPanGestureRecognizer(
        debugOwner: debugOwner,
        supportedDevices:
            supportedDevices == null ? null : Set.from(supportedDevices),
      );
    };
