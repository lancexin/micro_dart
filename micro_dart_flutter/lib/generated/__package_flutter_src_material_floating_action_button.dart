// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/floating_action_button.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/button.dart';
import 'package:flutter/src/material/color_scheme.dart';
import 'package:flutter/src/material/floating_action_button_theme.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/scaffold.dart';
import 'package:flutter/src/material/text_theme.dart';
import 'package:flutter/src/material/theme.dart';
import 'package:flutter/src/material/theme_data.dart';
import 'package:flutter/src/material/tooltip.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/floating_action_button.dart',
  {
    'FloatingActionButton.': _FloatingActionButton__$,
    'FloatingActionButton.small': _FloatingActionButton_small_$,
    'FloatingActionButton.large': _FloatingActionButton_large_$,
    'FloatingActionButton.extended': _FloatingActionButton_extended_$,
  },
  {},
  {
    'FloatingActionButton': m.ClassMirror(
      'FloatingActionButton',
      {
        '#as': FloatingActionButton_as$,
        '#is': FloatingActionButton_is$,
        'child': _FloatingActionButton_child$,
        'tooltip': _FloatingActionButton_tooltip$,
        'foregroundColor': _FloatingActionButton_foregroundColor$,
        'backgroundColor': _FloatingActionButton_backgroundColor$,
        'focusColor': _FloatingActionButton_focusColor$,
        'hoverColor': _FloatingActionButton_hoverColor$,
        'splashColor': _FloatingActionButton_splashColor$,
        'heroTag': _FloatingActionButton_heroTag$,
        'onPressed': _FloatingActionButton_onPressed$,
        'mouseCursor': _FloatingActionButton_mouseCursor$,
        'elevation': _FloatingActionButton_elevation$,
        'focusElevation': _FloatingActionButton_focusElevation$,
        'hoverElevation': _FloatingActionButton_hoverElevation$,
        'highlightElevation': _FloatingActionButton_highlightElevation$,
        'disabledElevation': _FloatingActionButton_disabledElevation$,
        'mini': _FloatingActionButton_mini$,
        'shape': _FloatingActionButton_shape$,
        'clipBehavior': _FloatingActionButton_clipBehavior$,
        'isExtended': _FloatingActionButton_isExtended$,
        'focusNode': _FloatingActionButton_focusNode$,
        'autofocus': _FloatingActionButton_autofocus$,
        'materialTapTargetSize': _FloatingActionButton_materialTapTargetSize$,
        'enableFeedback': _FloatingActionButton_enableFeedback$,
        'extendedIconLabelSpacing':
            _FloatingActionButton_extendedIconLabelSpacing$,
        'extendedPadding': _FloatingActionButton_extendedPadding$,
        'extendedTextStyle': _FloatingActionButton_extendedTextStyle$,
        'build': _FloatingActionButton_build$,
        'debugFillProperties': _FloatingActionButton_debugFillProperties$,
      },
      {},
    )
  },
);
Function FloatingActionButton_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FloatingActionButton;
Function FloatingActionButton_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FloatingActionButton;
Function _FloatingActionButton_child$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.child;
    };
Function _FloatingActionButton_tooltip$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.tooltip;
    };
Function _FloatingActionButton_foregroundColor$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.foregroundColor;
    };
Function _FloatingActionButton_backgroundColor$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.backgroundColor;
    };
Function _FloatingActionButton_focusColor$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.focusColor;
    };
Function _FloatingActionButton_hoverColor$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.hoverColor;
    };
Function _FloatingActionButton_splashColor$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.splashColor;
    };
Function _FloatingActionButton_heroTag$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.heroTag;
    };
Function _FloatingActionButton_onPressed$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.onPressed;
    };
Function _FloatingActionButton_mouseCursor$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.mouseCursor;
    };
Function _FloatingActionButton_elevation$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.elevation;
    };
Function _FloatingActionButton_focusElevation$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.focusElevation;
    };
Function _FloatingActionButton_hoverElevation$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.hoverElevation;
    };
Function _FloatingActionButton_highlightElevation$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.highlightElevation;
    };
Function _FloatingActionButton_disabledElevation$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.disabledElevation;
    };
Function _FloatingActionButton_mini$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.mini;
    };
Function _FloatingActionButton_shape$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.shape;
    };
Function _FloatingActionButton_clipBehavior$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _FloatingActionButton_isExtended$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.isExtended;
    };
Function _FloatingActionButton_focusNode$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.focusNode;
    };
Function _FloatingActionButton_autofocus$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.autofocus;
    };
Function _FloatingActionButton_materialTapTargetSize$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.materialTapTargetSize;
    };
Function _FloatingActionButton_enableFeedback$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.enableFeedback;
    };
Function _FloatingActionButton_extendedIconLabelSpacing$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.extendedIconLabelSpacing;
    };
Function _FloatingActionButton_extendedPadding$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.extendedPadding;
    };
Function _FloatingActionButton_extendedTextStyle$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    () {
      return target$.extendedTextStyle;
    };
Function _FloatingActionButton__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      String? tooltip,
      Color? foregroundColor,
      Color? backgroundColor,
      Color? focusColor,
      Color? hoverColor,
      Color? splashColor,
      Object? heroTag,
      double? elevation,
      double? focusElevation,
      double? hoverElevation,
      double? highlightElevation,
      double? disabledElevation,
      required m.FunctionPointer? onPressed,
      MouseCursor? mouseCursor,
      bool? mini,
      ShapeBorder? shape,
      Clip? clipBehavior,
      FocusNode? focusNode,
      bool? autofocus,
      MaterialTapTargetSize? materialTapTargetSize,
      bool? isExtended,
      bool? enableFeedback,
    }) {
      void onPressedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPressed!,
            [],
            {},
          );
      return FloatingActionButton(
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        disabledElevation: disabledElevation,
        elevation: elevation,
        enableFeedback: enableFeedback,
        focusColor: focusColor,
        focusElevation: focusElevation,
        focusNode: focusNode,
        foregroundColor: foregroundColor,
        heroTag: heroTag ?? const _DefaultHeroTag(),
        highlightElevation: highlightElevation,
        hoverColor: hoverColor,
        hoverElevation: hoverElevation,
        isExtended: isExtended ?? false,
        key: key,
        materialTapTargetSize: materialTapTargetSize,
        mini: mini ?? false,
        mouseCursor: mouseCursor,
        onPressed: onPressed == null ? null : onPressedProxy,
        shape: shape,
        splashColor: splashColor,
        tooltip: tooltip,
      );
    };
Function _FloatingActionButton_small_$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      String? tooltip,
      Color? foregroundColor,
      Color? backgroundColor,
      Color? focusColor,
      Color? hoverColor,
      Color? splashColor,
      Object? heroTag,
      double? elevation,
      double? focusElevation,
      double? hoverElevation,
      double? highlightElevation,
      double? disabledElevation,
      required m.FunctionPointer? onPressed,
      MouseCursor? mouseCursor,
      ShapeBorder? shape,
      Clip? clipBehavior,
      FocusNode? focusNode,
      bool? autofocus,
      MaterialTapTargetSize? materialTapTargetSize,
      bool? enableFeedback,
    }) {
      void onPressedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPressed!,
            [],
            {},
          );
      return FloatingActionButton.small(
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        disabledElevation: disabledElevation,
        elevation: elevation,
        enableFeedback: enableFeedback,
        focusColor: focusColor,
        focusElevation: focusElevation,
        focusNode: focusNode,
        foregroundColor: foregroundColor,
        heroTag: heroTag ?? const _DefaultHeroTag(),
        highlightElevation: highlightElevation,
        hoverColor: hoverColor,
        hoverElevation: hoverElevation,
        key: key,
        materialTapTargetSize: materialTapTargetSize,
        mouseCursor: mouseCursor,
        onPressed: onPressed == null ? null : onPressedProxy,
        shape: shape,
        splashColor: splashColor,
        tooltip: tooltip,
      );
    };
Function _FloatingActionButton_large_$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      String? tooltip,
      Color? foregroundColor,
      Color? backgroundColor,
      Color? focusColor,
      Color? hoverColor,
      Color? splashColor,
      Object? heroTag,
      double? elevation,
      double? focusElevation,
      double? hoverElevation,
      double? highlightElevation,
      double? disabledElevation,
      required m.FunctionPointer? onPressed,
      MouseCursor? mouseCursor,
      ShapeBorder? shape,
      Clip? clipBehavior,
      FocusNode? focusNode,
      bool? autofocus,
      MaterialTapTargetSize? materialTapTargetSize,
      bool? enableFeedback,
    }) {
      void onPressedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPressed!,
            [],
            {},
          );
      return FloatingActionButton.large(
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        disabledElevation: disabledElevation,
        elevation: elevation,
        enableFeedback: enableFeedback,
        focusColor: focusColor,
        focusElevation: focusElevation,
        focusNode: focusNode,
        foregroundColor: foregroundColor,
        heroTag: heroTag ?? const _DefaultHeroTag(),
        highlightElevation: highlightElevation,
        hoverColor: hoverColor,
        hoverElevation: hoverElevation,
        key: key,
        materialTapTargetSize: materialTapTargetSize,
        mouseCursor: mouseCursor,
        onPressed: onPressed == null ? null : onPressedProxy,
        shape: shape,
        splashColor: splashColor,
        tooltip: tooltip,
      );
    };
Function _FloatingActionButton_extended_$(m.Scope scope$) => ({
      Key? key,
      String? tooltip,
      Color? foregroundColor,
      Color? backgroundColor,
      Color? focusColor,
      Color? hoverColor,
      Object? heroTag,
      double? elevation,
      double? focusElevation,
      double? hoverElevation,
      Color? splashColor,
      double? highlightElevation,
      double? disabledElevation,
      required m.FunctionPointer? onPressed,
      MouseCursor? mouseCursor,
      ShapeBorder? shape,
      bool? isExtended,
      MaterialTapTargetSize? materialTapTargetSize,
      Clip? clipBehavior,
      FocusNode? focusNode,
      bool? autofocus,
      double? extendedIconLabelSpacing,
      EdgeInsetsGeometry? extendedPadding,
      TextStyle? extendedTextStyle,
      Widget? icon,
      required Widget label,
      bool? enableFeedback,
    }) {
      void onPressedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPressed!,
            [],
            {},
          );
      return FloatingActionButton.extended(
        autofocus: autofocus ?? false,
        backgroundColor: backgroundColor,
        clipBehavior: clipBehavior ?? Clip.none,
        disabledElevation: disabledElevation,
        elevation: elevation,
        enableFeedback: enableFeedback,
        extendedIconLabelSpacing: extendedIconLabelSpacing,
        extendedPadding: extendedPadding,
        extendedTextStyle: extendedTextStyle,
        focusColor: focusColor,
        focusElevation: focusElevation,
        focusNode: focusNode,
        foregroundColor: foregroundColor,
        heroTag: heroTag ?? const _DefaultHeroTag(),
        highlightElevation: highlightElevation,
        hoverColor: hoverColor,
        hoverElevation: hoverElevation,
        icon: icon,
        isExtended: isExtended ?? true,
        key: key,
        label: label,
        materialTapTargetSize: materialTapTargetSize,
        mouseCursor: mouseCursor ?? SystemMouseCursors.click,
        onPressed: onPressed == null ? null : onPressedProxy,
        shape: shape,
        splashColor: splashColor,
        tooltip: tooltip,
      );
    };
Function _FloatingActionButton_build$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    target$.build;
Function _FloatingActionButton_debugFillProperties$(
  m.Scope scope$,
  FloatingActionButton target$,
) =>
    target$.debugFillProperties;

class _DefaultHeroTag {
  const _DefaultHeroTag();
  @override
  String toString() => '<default FloatingActionButton tag>';
}
