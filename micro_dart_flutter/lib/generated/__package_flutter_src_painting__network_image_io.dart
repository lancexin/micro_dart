// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/_network_image_io.dart';
import 'dart:async';
import 'dart:io';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/binding.dart';
import 'package:flutter/src/painting/debug.dart';
import 'package:flutter/src/painting/image_stream.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/_network_image_io.dart',
  {'NetworkImage.': _NetworkImage__$},
  {},
  {
    'NetworkImage': m.ClassMirror(
      'NetworkImage',
      {
        '#as': NetworkImage_as$,
        '#is': NetworkImage_is$,
        'url': _NetworkImage_url$,
        'scale': _NetworkImage_scale$,
        'headers': _NetworkImage_headers$,
        'hashCode': _NetworkImage_hashCode$,
        'obtainKey': _NetworkImage_obtainKey$,
        'load': _NetworkImage_load$,
        'loadBuffer': _NetworkImage_loadBuffer$,
        'loadImage': _NetworkImage_loadImage$,
        '==': _NetworkImage_eq$$,
        'toString': _NetworkImage_toString$,
      },
      {},
    )
  },
);
Function NetworkImage_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as NetworkImage;
Function NetworkImage_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is NetworkImage;
Function _NetworkImage_url$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    () {
      return target$.url;
    };
Function _NetworkImage_scale$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    () {
      return target$.scale;
    };
Function _NetworkImage_headers$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    () {
      return target$.headers;
    };
Function _NetworkImage_hashCode$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    () {
      return target$.hashCode;
    };
Function _NetworkImage__$(m.Scope scope$) => (
      String url, {
      double? scale,
      Map? headers,
    }) {
      return NetworkImage(
        url,
        headers: headers == null ? null : Map.from(headers),
        scale: scale ?? 1.0,
      );
    };
Function _NetworkImage_obtainKey$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    target$.obtainKey;
Function _NetworkImage_load$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    (
      NetworkImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        Uint8List decode_buffer$, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            decode,
            [decode_buffer$],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target$.load(
        key,
        decodeProxy,
      );
    };
Function _NetworkImage_loadBuffer$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    (
      NetworkImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer$, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            decode,
            [decode_buffer$],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target$.loadBuffer(
        key,
        decodeProxy,
      );
    };
Function _NetworkImage_loadImage$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    (
      NetworkImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer$, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            decode,
            [decode_buffer$],
            {'getTargetSize': getTargetSize},
          );
      return target$.loadImage(
        key,
        decodeProxy,
      );
    };
Function _NetworkImage_eq$$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    (Object other$) => target$ == other$;
Function _NetworkImage_toString$(
  m.Scope scope$,
  NetworkImage target$,
) =>
    target$.toString;
