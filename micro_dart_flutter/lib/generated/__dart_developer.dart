// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:developer';
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:isolate' show Isolate, RawReceivePort, SendPort;

const libraryMirror = m.LibraryMirror(
  'dart:developer',
  {
    'reachabilityBarrier': _reachabilityBarrier$,
    'NativeRuntime.writeHeapSnapshotToFile':
        _NativeRuntime_writeHeapSnapshotToFile$,
    'debugger': _debugger$,
    'inspect': _inspect$,
    'log': _log$,
    'extensionStreamHasListener': _extensionStreamHasListener$,
    'ServiceExtensionResponse.invalidParams':
        _ServiceExtensionResponse_invalidParams$,
    'ServiceExtensionResponse.extensionError':
        _ServiceExtensionResponse_extensionError$,
    'ServiceExtensionResponse.extensionErrorMax':
        _ServiceExtensionResponse_extensionErrorMax$,
    'ServiceExtensionResponse.extensionErrorMin':
        _ServiceExtensionResponse_extensionErrorMin$,
    'registerExtension': _registerExtension$,
    'postEvent': _postEvent$,
    'UserTag.maxUserTags': _UserTag_maxUserTags$,
    'UserTag.defaultTag': _UserTag_defaultTag$,
    'getCurrentTag': _getCurrentTag$,
    'Service.getInfo': _Service_getInfo$,
    'Service.controlWebServer': _Service_controlWebServer$,
    'Service.getIsolateID': _Service_getIsolateID$,
    'Flow.begin': _Flow_begin$,
    'Flow.step': _Flow_step$,
    'Flow.end': _Flow_end$,
    'Timeline.now': _Timeline_now$,
    'Timeline.startSync': _Timeline_startSync$,
    'Timeline.finishSync': _Timeline_finishSync$,
    'Timeline.instantSync': _Timeline_instantSync$,
  },
  {},
  {
    'NativeRuntime': m.ClassMirror(
      'NativeRuntime',
      {},
      {},
    ),
    'ServiceExtensionResponse': m.ClassMirror(
      'ServiceExtensionResponse',
      {
        'result': _ServiceExtensionResponse_result$,
        'errorCode': _ServiceExtensionResponse_errorCode$,
        'errorDetail': _ServiceExtensionResponse_errorDetail$,
        'isError': _ServiceExtensionResponse_isError$,
      },
      {},
    ),
    'UserTag': m.ClassMirror(
      'UserTag',
      {
        'label': _UserTag_label$,
        'makeCurrent': _UserTag_makeCurrent$,
      },
      {},
    ),
    'ServiceProtocolInfo': m.ClassMirror(
      'ServiceProtocolInfo',
      {
        'majorVersion': _ServiceProtocolInfo_majorVersion$,
        'minorVersion': _ServiceProtocolInfo_minorVersion$,
        'serverUri': _ServiceProtocolInfo_serverUri$,
        'serverWebSocketUri': _ServiceProtocolInfo_serverWebSocketUri$,
        'toString': _ServiceProtocolInfo_toString$,
      },
      {},
    ),
    'Service': m.ClassMirror(
      'Service',
      {},
      {},
    ),
    'Flow': m.ClassMirror(
      'Flow',
      {'id': _Flow_id$},
      {},
    ),
    'Timeline': m.ClassMirror(
      'Timeline',
      {},
      {},
    ),
    'TimelineTask': m.ClassMirror(
      'TimelineTask',
      {
        'start': _TimelineTask_start$,
        'instant': _TimelineTask_instant$,
        'finish': _TimelineTask_finish$,
        'pass': _TimelineTask_pass$,
      },
      {},
    ),
  },
);
int _reachabilityBarrier$() {
  return reachabilityBarrier;
}

Function _NativeRuntime_writeHeapSnapshotToFile$(m.Scope scope) =>
    NativeRuntime.writeHeapSnapshotToFile;
Function _debugger$(m.Scope scope) => debugger;
Function _inspect$(m.Scope scope) => inspect;
Function _log$(m.Scope scope) => log;
bool _extensionStreamHasListener$() {
  return extensionStreamHasListener;
}

String? _ServiceExtensionResponse_result$(ServiceExtensionResponse target) {
  return target.result;
}

int? _ServiceExtensionResponse_errorCode$(ServiceExtensionResponse target) {
  return target.errorCode;
}

String? _ServiceExtensionResponse_errorDetail$(
    ServiceExtensionResponse target) {
  return target.errorDetail;
}

int _ServiceExtensionResponse_invalidParams$() {
  return ServiceExtensionResponse.invalidParams;
}

int _ServiceExtensionResponse_extensionError$() {
  return ServiceExtensionResponse.extensionError;
}

int _ServiceExtensionResponse_extensionErrorMax$() {
  return ServiceExtensionResponse.extensionErrorMax;
}

int _ServiceExtensionResponse_extensionErrorMin$() {
  return ServiceExtensionResponse.extensionErrorMin;
}

Function _ServiceExtensionResponse_isError$(
  m.Scope scope,
  ServiceExtensionResponse target,
) =>
    target.isError;
Function _registerExtension$(m.Scope scope) => (
      String method,
      m.FunctionPointer handler,
    ) {
      Future<ServiceExtensionResponse> handlerProxy(
        String handler_method,
        Map<String, String> handler_parameters,
      ) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            handler,
            [
              handler_method,
              handler_parameters,
            ],
            {},
          );
      registerExtension(
        method,
        handlerProxy,
      );
    };
Function _postEvent$(m.Scope scope) => postEvent;
int _UserTag_maxUserTags$() {
  return UserTag.maxUserTags;
}

String _UserTag_label$(UserTag target) {
  return target.label;
}

UserTag _UserTag_defaultTag$() {
  return UserTag.defaultTag;
}

Function _UserTag_makeCurrent$(
  m.Scope scope,
  UserTag target,
) =>
    target.makeCurrent;
Function _getCurrentTag$(m.Scope scope) => getCurrentTag;
int _ServiceProtocolInfo_majorVersion$(ServiceProtocolInfo target) {
  return target.majorVersion;
}

int _ServiceProtocolInfo_minorVersion$(ServiceProtocolInfo target) {
  return target.minorVersion;
}

Uri? _ServiceProtocolInfo_serverUri$(ServiceProtocolInfo target) {
  return target.serverUri;
}

Uri? _ServiceProtocolInfo_serverWebSocketUri$(ServiceProtocolInfo target) {
  return target.serverWebSocketUri;
}

Function _ServiceProtocolInfo_toString$(
  m.Scope scope,
  ServiceProtocolInfo target,
) =>
    target.toString;
Function _Service_getInfo$(m.Scope scope) => Service.getInfo;
Function _Service_controlWebServer$(m.Scope scope) => Service.controlWebServer;
Function _Service_getIsolateID$(m.Scope scope) => Service.getIsolateID;
int _Flow_id$(Flow target) {
  return target.id;
}

Function _Flow_begin$(m.Scope scope) => Flow.begin;
Function _Flow_step$(m.Scope scope) => Flow.step;
Function _Flow_end$(m.Scope scope) => Flow.end;
int _Timeline_now$() {
  return Timeline.now;
}

Function _Timeline_startSync$(m.Scope scope) => Timeline.startSync;
Function _Timeline_finishSync$(m.Scope scope) => Timeline.finishSync;
Function _Timeline_instantSync$(m.Scope scope) => Timeline.instantSync;
Function _TimelineTask_start$(
  m.Scope scope,
  TimelineTask target,
) =>
    target.start;
Function _TimelineTask_instant$(
  m.Scope scope,
  TimelineTask target,
) =>
    target.instant;
Function _TimelineTask_finish$(
  m.Scope scope,
  TimelineTask target,
) =>
    target.finish;
Function _TimelineTask_pass$(
  m.Scope scope,
  TimelineTask target,
) =>
    target.pass;
