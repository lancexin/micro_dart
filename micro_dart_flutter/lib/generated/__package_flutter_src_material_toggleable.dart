// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/toggleable.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/constants.dart';
import 'package:flutter/src/material/material_state.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/toggleable.dart',
  {},
  {},
  {
    'ToggleablePainter': m.ClassMirror(
      'ToggleablePainter',
      {
        '#as': ToggleablePainter_as$,
        '#is': ToggleablePainter_is$,
        'position': _ToggleablePainter_position$,
        'reaction': _ToggleablePainter_reaction$,
        'reactionFocusFade': _ToggleablePainter_reactionFocusFade$,
        'reactionHoverFade': _ToggleablePainter_reactionHoverFade$,
        'activeColor': _ToggleablePainter_activeColor$,
        'inactiveColor': _ToggleablePainter_inactiveColor$,
        'inactiveReactionColor': _ToggleablePainter_inactiveReactionColor$,
        'reactionColor': _ToggleablePainter_reactionColor$,
        'hoverColor': _ToggleablePainter_hoverColor$,
        'focusColor': _ToggleablePainter_focusColor$,
        'splashRadius': _ToggleablePainter_splashRadius$,
        'downPosition': _ToggleablePainter_downPosition$,
        'isFocused': _ToggleablePainter_isFocused$,
        'isHovered': _ToggleablePainter_isHovered$,
        'semanticsBuilder': _ToggleablePainter_semanticsBuilder$,
        'paintRadialReaction': _ToggleablePainter_paintRadialReaction$,
        'dispose': _ToggleablePainter_dispose$,
        'shouldRepaint': _ToggleablePainter_shouldRepaint$,
        'hitTest': _ToggleablePainter_hitTest$,
        'shouldRebuildSemantics': _ToggleablePainter_shouldRebuildSemantics$,
        'toString': _ToggleablePainter_toString$,
      },
      {
        'position': _ToggleablePainter_position_set$,
        'reaction': _ToggleablePainter_reaction_set$,
        'reactionFocusFade': _ToggleablePainter_reactionFocusFade_set$,
        'reactionHoverFade': _ToggleablePainter_reactionHoverFade_set$,
        'activeColor': _ToggleablePainter_activeColor_set$,
        'inactiveColor': _ToggleablePainter_inactiveColor_set$,
        'inactiveReactionColor': _ToggleablePainter_inactiveReactionColor_set$,
        'reactionColor': _ToggleablePainter_reactionColor_set$,
        'hoverColor': _ToggleablePainter_hoverColor_set$,
        'focusColor': _ToggleablePainter_focusColor_set$,
        'splashRadius': _ToggleablePainter_splashRadius_set$,
        'downPosition': _ToggleablePainter_downPosition_set$,
        'isFocused': _ToggleablePainter_isFocused_set$,
        'isHovered': _ToggleablePainter_isHovered_set$,
      },
    )
  },
);
Function ToggleablePainter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ToggleablePainter;
Function ToggleablePainter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ToggleablePainter;
Function _ToggleablePainter_position$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.position;
    };
void _ToggleablePainter_position_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.position = other$;
    };
Function _ToggleablePainter_reaction$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.reaction;
    };
void _ToggleablePainter_reaction_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.reaction = other$;
    };
Function _ToggleablePainter_reactionFocusFade$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.reactionFocusFade;
    };
void _ToggleablePainter_reactionFocusFade_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.reactionFocusFade = other$;
    };
Function _ToggleablePainter_reactionHoverFade$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.reactionHoverFade;
    };
void _ToggleablePainter_reactionHoverFade_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.reactionHoverFade = other$;
    };
Function _ToggleablePainter_activeColor$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.activeColor;
    };
void _ToggleablePainter_activeColor_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.activeColor = other$;
    };
Function _ToggleablePainter_inactiveColor$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.inactiveColor;
    };
void _ToggleablePainter_inactiveColor_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.inactiveColor = other$;
    };
Function _ToggleablePainter_inactiveReactionColor$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.inactiveReactionColor;
    };
void _ToggleablePainter_inactiveReactionColor_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.inactiveReactionColor = other$;
    };
Function _ToggleablePainter_reactionColor$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.reactionColor;
    };
void _ToggleablePainter_reactionColor_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.reactionColor = other$;
    };
Function _ToggleablePainter_hoverColor$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.hoverColor;
    };
void _ToggleablePainter_hoverColor_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.hoverColor = other$;
    };
Function _ToggleablePainter_focusColor$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.focusColor;
    };
void _ToggleablePainter_focusColor_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.focusColor = other$;
    };
Function _ToggleablePainter_splashRadius$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.splashRadius;
    };
void _ToggleablePainter_splashRadius_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.splashRadius = other$;
    };
Function _ToggleablePainter_downPosition$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.downPosition;
    };
void _ToggleablePainter_downPosition_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.downPosition = other$;
    };
Function _ToggleablePainter_isFocused$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.isFocused;
    };
void _ToggleablePainter_isFocused_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.isFocused = other$;
    };
Function _ToggleablePainter_isHovered$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.isHovered;
    };
void _ToggleablePainter_isHovered_set$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    (dynamic other$) {
      target$.isHovered = other$;
    };
Function _ToggleablePainter_semanticsBuilder$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    () {
      return target$.semanticsBuilder;
    };
Function _ToggleablePainter_paintRadialReaction$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    target$.paintRadialReaction;
Function _ToggleablePainter_dispose$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    target$.dispose;
Function _ToggleablePainter_shouldRepaint$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    target$.shouldRepaint;
Function _ToggleablePainter_hitTest$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    target$.hitTest;
Function _ToggleablePainter_shouldRebuildSemantics$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    target$.shouldRebuildSemantics;
Function _ToggleablePainter_toString$(
  m.Scope scope$,
  ToggleablePainter target$,
) =>
    target$.toString;
