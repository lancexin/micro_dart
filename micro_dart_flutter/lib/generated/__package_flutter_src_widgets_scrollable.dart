// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/scrollable.dart';
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';
import 'package:flutter/src/widgets/media_query.dart';
import 'package:flutter/src/widgets/notification_listener.dart';
import 'package:flutter/src/widgets/restoration.dart';
import 'package:flutter/src/widgets/restoration_properties.dart';
import 'package:flutter/src/widgets/scroll_activity.dart';
import 'package:flutter/src/widgets/scroll_configuration.dart';
import 'package:flutter/src/widgets/scroll_context.dart';
import 'package:flutter/src/widgets/scroll_controller.dart';
import 'package:flutter/src/widgets/scroll_physics.dart';
import 'package:flutter/src/widgets/scroll_position.dart';
import 'package:flutter/src/widgets/scrollable_helpers.dart';
import 'package:flutter/src/widgets/selectable_region.dart';
import 'package:flutter/src/widgets/selection_container.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';
import 'package:flutter/src/widgets/viewport.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/scrollable.dart',
  {
    'Scrollable.': _Scrollable__$,
    'Scrollable.maybeOf': _Scrollable_maybeOf$,
    'Scrollable.of': _Scrollable_of$,
    'Scrollable.recommendDeferredLoadingForContext':
        _Scrollable_recommendDeferredLoadingForContext$,
    'Scrollable.ensureVisible': _Scrollable_ensureVisible$,
    'ScrollableState.': _ScrollableState__$,
  },
  {},
  {
    'Scrollable': m.ClassMirror(
      'Scrollable',
      {
        '#as': Scrollable_as$,
        '#is': Scrollable_is$,
        'axisDirection': _Scrollable_axisDirection$,
        'controller': _Scrollable_controller$,
        'physics': _Scrollable_physics$,
        'viewportBuilder': _Scrollable_viewportBuilder$,
        'incrementCalculator': _Scrollable_incrementCalculator$,
        'excludeFromSemantics': _Scrollable_excludeFromSemantics$,
        'semanticChildCount': _Scrollable_semanticChildCount$,
        'dragStartBehavior': _Scrollable_dragStartBehavior$,
        'restorationId': _Scrollable_restorationId$,
        'scrollBehavior': _Scrollable_scrollBehavior$,
        'clipBehavior': _Scrollable_clipBehavior$,
        'axis': _Scrollable_axis$,
        'createState': _Scrollable_createState$,
        'debugFillProperties': _Scrollable_debugFillProperties$,
      },
      {},
    ),
    'ScrollableState': m.ClassMirror(
      'ScrollableState',
      {
        '#as': ScrollableState_as$,
        '#is': ScrollableState_is$,
        'position': _ScrollableState_position$,
        'resolvedPhysics': _ScrollableState_resolvedPhysics$,
        'deltaToScrollOrigin': _ScrollableState_deltaToScrollOrigin$,
        'axisDirection': _ScrollableState_axisDirection$,
        'vsync': _ScrollableState_vsync$,
        'notificationContext': _ScrollableState_notificationContext$,
        'storageContext': _ScrollableState_storageContext$,
        'restorationId': _ScrollableState_restorationId$,
        'restoreState': _ScrollableState_restoreState$,
        'saveOffset': _ScrollableState_saveOffset$,
        'initState': _ScrollableState_initState$,
        'didChangeDependencies': _ScrollableState_didChangeDependencies$,
        'didUpdateWidget': _ScrollableState_didUpdateWidget$,
        'dispose': _ScrollableState_dispose$,
        'setSemanticsActions': _ScrollableState_setSemanticsActions$,
        'setCanDrag': _ScrollableState_setCanDrag$,
        'setIgnorePointer': _ScrollableState_setIgnorePointer$,
        'build': _ScrollableState_build$,
        'debugFillProperties': _ScrollableState_debugFillProperties$,
      },
      {},
    ),
  },
);
Function Scrollable_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Scrollable;
Function Scrollable_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Scrollable;
Function _Scrollable_axisDirection$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.axisDirection;
    };
Function _Scrollable_controller$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.controller;
    };
Function _Scrollable_physics$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.physics;
    };
Function _Scrollable_viewportBuilder$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.viewportBuilder;
    };
Function _Scrollable_incrementCalculator$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.incrementCalculator;
    };
Function _Scrollable_excludeFromSemantics$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.excludeFromSemantics;
    };
Function _Scrollable_semanticChildCount$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.semanticChildCount;
    };
Function _Scrollable_dragStartBehavior$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.dragStartBehavior;
    };
Function _Scrollable_restorationId$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.restorationId;
    };
Function _Scrollable_scrollBehavior$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.scrollBehavior;
    };
Function _Scrollable_clipBehavior$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _Scrollable_axis$(
  m.Scope scope$,
  Scrollable target$,
) =>
    () {
      return target$.axis;
    };
Function _Scrollable__$(m.Scope scope$) => ({
      Key? key,
      AxisDirection? axisDirection,
      ScrollController? controller,
      ScrollPhysics? physics,
      required m.FunctionPointer viewportBuilder,
      m.FunctionPointer? incrementCalculator,
      bool? excludeFromSemantics,
      int? semanticChildCount,
      DragStartBehavior? dragStartBehavior,
      String? restorationId,
      ScrollBehavior? scrollBehavior,
      Clip? clipBehavior,
    }) {
      double incrementCalculatorProxy(
              ScrollIncrementDetails incrementCalculator_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            incrementCalculator!,
            [incrementCalculator_details$],
            {},
          );
      Widget viewportBuilderProxy(
        BuildContext viewportBuilder_context$,
        ViewportOffset viewportBuilder_position$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            viewportBuilder,
            [
              viewportBuilder_context$,
              viewportBuilder_position$,
            ],
            {},
          );
      return Scrollable(
        axisDirection: axisDirection ?? AxisDirection.down,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        controller: controller,
        dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
        excludeFromSemantics: excludeFromSemantics ?? false,
        incrementCalculator:
            incrementCalculator == null ? null : incrementCalculatorProxy,
        key: key,
        physics: physics,
        restorationId: restorationId,
        scrollBehavior: scrollBehavior,
        semanticChildCount: semanticChildCount,
        viewportBuilder: viewportBuilderProxy,
      );
    };
Function _Scrollable_createState$(
  m.Scope scope$,
  Scrollable target$,
) =>
    target$.createState;
Function _Scrollable_debugFillProperties$(
  m.Scope scope$,
  Scrollable target$,
) =>
    target$.debugFillProperties;
Function _Scrollable_maybeOf$(m.Scope scope$) => Scrollable.maybeOf;
Function _Scrollable_of$(m.Scope scope$) => Scrollable.of;
Function _Scrollable_recommendDeferredLoadingForContext$(m.Scope scope$) =>
    Scrollable.recommendDeferredLoadingForContext;
Function _Scrollable_ensureVisible$(m.Scope scope$) => Scrollable.ensureVisible;
Function ScrollableState_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ScrollableState;
Function ScrollableState_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ScrollableState;
Function _ScrollableState_position$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.position;
    };
Function _ScrollableState_resolvedPhysics$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.resolvedPhysics;
    };
Function _ScrollableState_deltaToScrollOrigin$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.deltaToScrollOrigin;
    };
Function _ScrollableState_axisDirection$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.axisDirection;
    };
Function _ScrollableState_vsync$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.vsync;
    };
Function _ScrollableState_notificationContext$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.notificationContext;
    };
Function _ScrollableState_storageContext$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.storageContext;
    };
Function _ScrollableState_restorationId$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    () {
      return target$.restorationId;
    };
Function _ScrollableState__$(m.Scope scope$) => () {
      return ScrollableState();
    };
Function _ScrollableState_restoreState$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.restoreState;
Function _ScrollableState_saveOffset$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.saveOffset;
Function _ScrollableState_initState$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.initState;
Function _ScrollableState_didChangeDependencies$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.didChangeDependencies;
Function _ScrollableState_didUpdateWidget$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.didUpdateWidget;
Function _ScrollableState_dispose$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.dispose;
Function _ScrollableState_setSemanticsActions$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.setSemanticsActions;
Function _ScrollableState_setCanDrag$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.setCanDrag;
Function _ScrollableState_setIgnorePointer$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.setIgnorePointer;
Function _ScrollableState_build$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.build;
Function _ScrollableState_debugFillProperties$(
  m.Scope scope$,
  ScrollableState target$,
) =>
    target$.debugFillProperties;
