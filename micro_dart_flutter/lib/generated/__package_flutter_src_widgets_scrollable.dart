// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/scrollable.dart';
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';
import 'package:flutter/src/widgets/media_query.dart';
import 'package:flutter/src/widgets/notification_listener.dart';
import 'package:flutter/src/widgets/restoration.dart';
import 'package:flutter/src/widgets/restoration_properties.dart';
import 'package:flutter/src/widgets/scroll_activity.dart';
import 'package:flutter/src/widgets/scroll_configuration.dart';
import 'package:flutter/src/widgets/scroll_context.dart';
import 'package:flutter/src/widgets/scroll_controller.dart';
import 'package:flutter/src/widgets/scroll_physics.dart';
import 'package:flutter/src/widgets/scroll_position.dart';
import 'package:flutter/src/widgets/scrollable_helpers.dart';
import 'package:flutter/src/widgets/selectable_region.dart';
import 'package:flutter/src/widgets/selection_container.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';
import 'package:flutter/src/widgets/viewport.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/scrollable.dart',
  {
    'Scrollable.maybeOf': _Scrollable_maybeOf$,
    'Scrollable.of': _Scrollable_of$,
    'Scrollable.recommendDeferredLoadingForContext':
        _Scrollable_recommendDeferredLoadingForContext$,
    'Scrollable.ensureVisible': _Scrollable_ensureVisible$,
  },
  {},
  {
    'Scrollable': m.ClassMirror(
      'Scrollable',
      {
        '#as': Scrollable_as$,
        '#is': Scrollable_is$,
        'axisDirection': _Scrollable_axisDirection$,
        'controller': _Scrollable_controller$,
        'physics': _Scrollable_physics$,
        'viewportBuilder': _Scrollable_viewportBuilder$,
        'incrementCalculator': _Scrollable_incrementCalculator$,
        'excludeFromSemantics': _Scrollable_excludeFromSemantics$,
        'semanticChildCount': _Scrollable_semanticChildCount$,
        'dragStartBehavior': _Scrollable_dragStartBehavior$,
        'restorationId': _Scrollable_restorationId$,
        'scrollBehavior': _Scrollable_scrollBehavior$,
        'clipBehavior': _Scrollable_clipBehavior$,
        'axis': _Scrollable_axis$,
        'createState': _Scrollable_createState$,
        'debugFillProperties': _Scrollable_debugFillProperties$,
      },
      {},
    ),
    'ScrollableState': m.ClassMirror(
      'ScrollableState',
      {
        '#as': ScrollableState_as$,
        '#is': ScrollableState_is$,
        'position': _ScrollableState_position$,
        'resolvedPhysics': _ScrollableState_resolvedPhysics$,
        'deltaToScrollOrigin': _ScrollableState_deltaToScrollOrigin$,
        'axisDirection': _ScrollableState_axisDirection$,
        'vsync': _ScrollableState_vsync$,
        'notificationContext': _ScrollableState_notificationContext$,
        'storageContext': _ScrollableState_storageContext$,
        'restorationId': _ScrollableState_restorationId$,
        'restoreState': _ScrollableState_restoreState$,
        'saveOffset': _ScrollableState_saveOffset$,
        'initState': _ScrollableState_initState$,
        'didChangeDependencies': _ScrollableState_didChangeDependencies$,
        'didUpdateWidget': _ScrollableState_didUpdateWidget$,
        'dispose': _ScrollableState_dispose$,
        'setSemanticsActions': _ScrollableState_setSemanticsActions$,
        'setCanDrag': _ScrollableState_setCanDrag$,
        'setIgnorePointer': _ScrollableState_setIgnorePointer$,
        'build': _ScrollableState_build$,
        'debugFillProperties': _ScrollableState_debugFillProperties$,
      },
      {},
    ),
  },
);
Function Scrollable_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as Scrollable;
Function Scrollable_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is Scrollable;
AxisDirection _Scrollable_axisDirection$(Scrollable target) {
  return target.axisDirection;
}

ScrollController? _Scrollable_controller$(Scrollable target) {
  return target.controller;
}

ScrollPhysics? _Scrollable_physics$(Scrollable target) {
  return target.physics;
}

Widget Function(BuildContext, ViewportOffset) _Scrollable_viewportBuilder$(
    Scrollable target) {
  return target.viewportBuilder;
}

double Function(ScrollIncrementDetails)? _Scrollable_incrementCalculator$(
    Scrollable target) {
  return target.incrementCalculator;
}

bool _Scrollable_excludeFromSemantics$(Scrollable target) {
  return target.excludeFromSemantics;
}

int? _Scrollable_semanticChildCount$(Scrollable target) {
  return target.semanticChildCount;
}

DragStartBehavior _Scrollable_dragStartBehavior$(Scrollable target) {
  return target.dragStartBehavior;
}

String? _Scrollable_restorationId$(Scrollable target) {
  return target.restorationId;
}

ScrollBehavior? _Scrollable_scrollBehavior$(Scrollable target) {
  return target.scrollBehavior;
}

Clip _Scrollable_clipBehavior$(Scrollable target) {
  return target.clipBehavior;
}

Axis _Scrollable_axis$(Scrollable target) {
  return target.axis;
}

Function _Scrollable_createState$(
  m.Scope scope,
  Scrollable target,
) =>
    target.createState;
Function _Scrollable_debugFillProperties$(
  m.Scope scope,
  Scrollable target,
) =>
    target.debugFillProperties;
Function _Scrollable_maybeOf$(m.Scope scope) => Scrollable.maybeOf;
Function _Scrollable_of$(m.Scope scope) => Scrollable.of;
Function _Scrollable_recommendDeferredLoadingForContext$(m.Scope scope) =>
    Scrollable.recommendDeferredLoadingForContext;
Function _Scrollable_ensureVisible$(m.Scope scope) => Scrollable.ensureVisible;
Function ScrollableState_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ScrollableState;
Function ScrollableState_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ScrollableState;
ScrollPosition _ScrollableState_position$(ScrollableState target) {
  return target.position;
}

ScrollPhysics? _ScrollableState_resolvedPhysics$(ScrollableState target) {
  return target.resolvedPhysics;
}

Offset _ScrollableState_deltaToScrollOrigin$(ScrollableState target) {
  return target.deltaToScrollOrigin;
}

AxisDirection _ScrollableState_axisDirection$(ScrollableState target) {
  return target.axisDirection;
}

TickerProvider _ScrollableState_vsync$(ScrollableState target) {
  return target.vsync;
}

BuildContext? _ScrollableState_notificationContext$(ScrollableState target) {
  return target.notificationContext;
}

BuildContext _ScrollableState_storageContext$(ScrollableState target) {
  return target.storageContext;
}

String? _ScrollableState_restorationId$(ScrollableState target) {
  return target.restorationId;
}

Function _ScrollableState_restoreState$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.restoreState;
Function _ScrollableState_saveOffset$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.saveOffset;
Function _ScrollableState_initState$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.initState;
Function _ScrollableState_didChangeDependencies$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.didChangeDependencies;
Function _ScrollableState_didUpdateWidget$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.didUpdateWidget;
Function _ScrollableState_dispose$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.dispose;
Function _ScrollableState_setSemanticsActions$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.setSemanticsActions;
Function _ScrollableState_setCanDrag$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.setCanDrag;
Function _ScrollableState_setIgnorePointer$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.setIgnorePointer;
Function _ScrollableState_build$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.build;
Function _ScrollableState_debugFillProperties$(
  m.Scope scope,
  ScrollableState target,
) =>
    target.debugFillProperties;
