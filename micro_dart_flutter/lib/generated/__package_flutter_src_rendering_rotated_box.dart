// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/rendering/rotated_box.dart';
import 'dart:math';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/rendering/object.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/rendering/rotated_box.dart',
  {'RenderRotatedBox.': _RenderRotatedBox__$},
  {},
  {
    'RenderRotatedBox': m.ClassMirror(
      'RenderRotatedBox',
      {
        '#as': RenderRotatedBox_as$,
        '#is': RenderRotatedBox_is$,
        'quarterTurns': _RenderRotatedBox_quarterTurns$,
        'computeMinIntrinsicWidth': _RenderRotatedBox_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth': _RenderRotatedBox_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight':
            _RenderRotatedBox_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight':
            _RenderRotatedBox_computeMaxIntrinsicHeight$,
        'computeDryLayout': _RenderRotatedBox_computeDryLayout$,
        'performLayout': _RenderRotatedBox_performLayout$,
        'hitTestChildren': _RenderRotatedBox_hitTestChildren$,
        'paint': _RenderRotatedBox_paint$,
        'dispose': _RenderRotatedBox_dispose$,
        'applyPaintTransform': _RenderRotatedBox_applyPaintTransform$,
      },
      {'quarterTurns': _RenderRotatedBox_quarterTurns_set$},
    )
  },
);
Function RenderRotatedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderRotatedBox;
Function RenderRotatedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderRotatedBox;
Function _RenderRotatedBox_quarterTurns$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    () {
      return target$.quarterTurns;
    };
void _RenderRotatedBox_quarterTurns_set$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    (dynamic other$) {
      target$.quarterTurns = other$;
    };
Function _RenderRotatedBox__$(m.Scope scope$) => ({
      required int quarterTurns,
      RenderBox? child,
    }) {
      return RenderRotatedBox(
        child: child,
        quarterTurns: quarterTurns,
      );
    };
Function _RenderRotatedBox_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderRotatedBox_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderRotatedBox_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderRotatedBox_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderRotatedBox_computeDryLayout$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.computeDryLayout;
Function _RenderRotatedBox_performLayout$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.performLayout;
Function _RenderRotatedBox_hitTestChildren$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.hitTestChildren;
Function _RenderRotatedBox_paint$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.paint;
Function _RenderRotatedBox_dispose$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.dispose;
Function _RenderRotatedBox_applyPaintTransform$(
  m.Scope scope$,
  RenderRotatedBox target$,
) =>
    target$.applyPaintTransform;
