// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/gestures/monodrag.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/gestures/constants.dart';
import 'package:flutter/src/gestures/drag_details.dart';
import 'package:flutter/src/gestures/events.dart';
import 'package:flutter/src/gestures/recognizer.dart';
import 'package:flutter/src/gestures/velocity_tracker.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/gestures/monodrag.dart',
  {
    'VerticalDragGestureRecognizer.': _VerticalDragGestureRecognizer__$,
    'HorizontalDragGestureRecognizer.': _HorizontalDragGestureRecognizer__$,
    'PanGestureRecognizer.': _PanGestureRecognizer__$,
  },
  {},
  {
    'DragGestureRecognizer': m.ClassMirror(
      'DragGestureRecognizer',
      {
        '#as': DragGestureRecognizer_as$,
        '#is': DragGestureRecognizer_is$,
        'dragStartBehavior': _DragGestureRecognizer_dragStartBehavior$,
        'onDown': _DragGestureRecognizer_onDown$,
        'onStart': _DragGestureRecognizer_onStart$,
        'onUpdate': _DragGestureRecognizer_onUpdate$,
        'onEnd': _DragGestureRecognizer_onEnd$,
        'onCancel': _DragGestureRecognizer_onCancel$,
        'minFlingDistance': _DragGestureRecognizer_minFlingDistance$,
        'minFlingVelocity': _DragGestureRecognizer_minFlingVelocity$,
        'maxFlingVelocity': _DragGestureRecognizer_maxFlingVelocity$,
        'velocityTrackerBuilder':
            _DragGestureRecognizer_velocityTrackerBuilder$,
        'debugLastPendingEventTimestamp':
            _DragGestureRecognizer_debugLastPendingEventTimestamp$,
        'isFlingGesture': _DragGestureRecognizer_isFlingGesture$,
        'isPointerAllowed': _DragGestureRecognizer_isPointerAllowed$,
        'addAllowedPointer': _DragGestureRecognizer_addAllowedPointer$,
        'addAllowedPointerPanZoom':
            _DragGestureRecognizer_addAllowedPointerPanZoom$,
        'handleEvent': _DragGestureRecognizer_handleEvent$,
        'acceptGesture': _DragGestureRecognizer_acceptGesture$,
        'rejectGesture': _DragGestureRecognizer_rejectGesture$,
        'didStopTrackingLastPointer':
            _DragGestureRecognizer_didStopTrackingLastPointer$,
        'dispose': _DragGestureRecognizer_dispose$,
        'debugFillProperties': _DragGestureRecognizer_debugFillProperties$,
      },
      {
        'dragStartBehavior': _DragGestureRecognizer_dragStartBehavior_set$,
        'onDown': _DragGestureRecognizer_onDown_set$,
        'onStart': _DragGestureRecognizer_onStart_set$,
        'onUpdate': _DragGestureRecognizer_onUpdate_set$,
        'onEnd': _DragGestureRecognizer_onEnd_set$,
        'onCancel': _DragGestureRecognizer_onCancel_set$,
        'minFlingDistance': _DragGestureRecognizer_minFlingDistance_set$,
        'minFlingVelocity': _DragGestureRecognizer_minFlingVelocity_set$,
        'maxFlingVelocity': _DragGestureRecognizer_maxFlingVelocity_set$,
        'velocityTrackerBuilder':
            _DragGestureRecognizer_velocityTrackerBuilder_set$,
      },
    ),
    'VerticalDragGestureRecognizer': m.ClassMirror(
      'VerticalDragGestureRecognizer',
      {
        '#as': VerticalDragGestureRecognizer_as$,
        '#is': VerticalDragGestureRecognizer_is$,
        'debugDescription': _VerticalDragGestureRecognizer_debugDescription$,
        'isFlingGesture': _VerticalDragGestureRecognizer_isFlingGesture$,
      },
      {},
    ),
    'HorizontalDragGestureRecognizer': m.ClassMirror(
      'HorizontalDragGestureRecognizer',
      {
        '#as': HorizontalDragGestureRecognizer_as$,
        '#is': HorizontalDragGestureRecognizer_is$,
        'debugDescription': _HorizontalDragGestureRecognizer_debugDescription$,
        'isFlingGesture': _HorizontalDragGestureRecognizer_isFlingGesture$,
      },
      {},
    ),
    'PanGestureRecognizer': m.ClassMirror(
      'PanGestureRecognizer',
      {
        '#as': PanGestureRecognizer_as$,
        '#is': PanGestureRecognizer_is$,
        'debugDescription': _PanGestureRecognizer_debugDescription$,
        'isFlingGesture': _PanGestureRecognizer_isFlingGesture$,
      },
      {},
    ),
  },
);
Function DragGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DragGestureRecognizer;
Function DragGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DragGestureRecognizer;
Function _DragGestureRecognizer_dragStartBehavior$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.dragStartBehavior;
    };
void _DragGestureRecognizer_dragStartBehavior_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.dragStartBehavior = other$;
    };
Function _DragGestureRecognizer_onDown$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.onDown;
    };
Function _DragGestureRecognizer_onDown_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onDown) {
      void _onDownProxy(DragDownDetails _onDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onDown!,
            [_onDown_details$],
            {},
          );
      target$.onDown = (_onDown == null ? null : _onDownProxy);
    };
Function _DragGestureRecognizer_onStart$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.onStart;
    };
Function _DragGestureRecognizer_onStart_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onStart) {
      void _onStartProxy(DragStartDetails _onStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onStart!,
            [_onStart_details$],
            {},
          );
      target$.onStart = (_onStart == null ? null : _onStartProxy);
    };
Function _DragGestureRecognizer_onUpdate$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.onUpdate;
    };
Function _DragGestureRecognizer_onUpdate_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onUpdate) {
      void _onUpdateProxy(DragUpdateDetails _onUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onUpdate!,
            [_onUpdate_details$],
            {},
          );
      target$.onUpdate = (_onUpdate == null ? null : _onUpdateProxy);
    };
Function _DragGestureRecognizer_onEnd$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.onEnd;
    };
Function _DragGestureRecognizer_onEnd_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onEnd) {
      void _onEndProxy(DragEndDetails _onEnd_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onEnd!,
            [_onEnd_details$],
            {},
          );
      target$.onEnd = (_onEnd == null ? null : _onEndProxy);
    };
Function _DragGestureRecognizer_onCancel$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.onCancel;
    };
Function _DragGestureRecognizer_onCancel_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (m.FunctionPointer? _onCancel) {
      void _onCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onCancel!,
            [],
            {},
          );
      target$.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
Function _DragGestureRecognizer_minFlingDistance$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.minFlingDistance;
    };
void _DragGestureRecognizer_minFlingDistance_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.minFlingDistance = other$;
    };
Function _DragGestureRecognizer_minFlingVelocity$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.minFlingVelocity;
    };
void _DragGestureRecognizer_minFlingVelocity_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.minFlingVelocity = other$;
    };
Function _DragGestureRecognizer_maxFlingVelocity$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.maxFlingVelocity;
    };
void _DragGestureRecognizer_maxFlingVelocity_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (dynamic other$) {
      target$.maxFlingVelocity = other$;
    };
Function _DragGestureRecognizer_velocityTrackerBuilder$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.velocityTrackerBuilder;
    };
Function _DragGestureRecognizer_velocityTrackerBuilder_set$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    (m.FunctionPointer _velocityTrackerBuilder) {
      VelocityTracker _velocityTrackerBuilderProxy(
              PointerEvent _velocityTrackerBuilder_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _velocityTrackerBuilder,
            [_velocityTrackerBuilder_event$],
            {},
          );
      target$.velocityTrackerBuilder = (_velocityTrackerBuilderProxy);
    };
Function _DragGestureRecognizer_debugLastPendingEventTimestamp$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    () {
      return target$.debugLastPendingEventTimestamp;
    };
Function _DragGestureRecognizer_isFlingGesture$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.isFlingGesture;
Function _DragGestureRecognizer_isPointerAllowed$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.isPointerAllowed;
Function _DragGestureRecognizer_addAllowedPointer$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.addAllowedPointer;
Function _DragGestureRecognizer_addAllowedPointerPanZoom$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.addAllowedPointerPanZoom;
Function _DragGestureRecognizer_handleEvent$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.handleEvent;
Function _DragGestureRecognizer_acceptGesture$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.acceptGesture;
Function _DragGestureRecognizer_rejectGesture$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.rejectGesture;
Function _DragGestureRecognizer_didStopTrackingLastPointer$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.didStopTrackingLastPointer;
Function _DragGestureRecognizer_dispose$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.dispose;
Function _DragGestureRecognizer_debugFillProperties$(
  m.Scope scope$,
  DragGestureRecognizer target$,
) =>
    target$.debugFillProperties;
Function VerticalDragGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as VerticalDragGestureRecognizer;
Function VerticalDragGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is VerticalDragGestureRecognizer;
Function _VerticalDragGestureRecognizer_debugDescription$(
  m.Scope scope$,
  VerticalDragGestureRecognizer target$,
) =>
    () {
      return target$.debugDescription;
    };
Function _VerticalDragGestureRecognizer__$(m.Scope scope$) => ({
      Object? debugOwner,
      Set? supportedDevices,
      m.FunctionPointer? allowedButtonsFilter,
    }) {
      bool allowedButtonsFilterProxy(int allowedButtonsFilter_buttons$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            allowedButtonsFilter!,
            [allowedButtonsFilter_buttons$],
            {},
          );
      return VerticalDragGestureRecognizer(
        allowedButtonsFilter:
            allowedButtonsFilter == null ? null : allowedButtonsFilterProxy,
        debugOwner: debugOwner,
        supportedDevices:
            supportedDevices == null ? null : Set.from(supportedDevices),
      );
    };
Function _VerticalDragGestureRecognizer_isFlingGesture$(
  m.Scope scope$,
  VerticalDragGestureRecognizer target$,
) =>
    target$.isFlingGesture;
Function HorizontalDragGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as HorizontalDragGestureRecognizer;
Function HorizontalDragGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is HorizontalDragGestureRecognizer;
Function _HorizontalDragGestureRecognizer_debugDescription$(
  m.Scope scope$,
  HorizontalDragGestureRecognizer target$,
) =>
    () {
      return target$.debugDescription;
    };
Function _HorizontalDragGestureRecognizer__$(m.Scope scope$) => ({
      Object? debugOwner,
      Set? supportedDevices,
      m.FunctionPointer? allowedButtonsFilter,
    }) {
      bool allowedButtonsFilterProxy(int allowedButtonsFilter_buttons$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            allowedButtonsFilter!,
            [allowedButtonsFilter_buttons$],
            {},
          );
      return HorizontalDragGestureRecognizer(
        allowedButtonsFilter:
            allowedButtonsFilter == null ? null : allowedButtonsFilterProxy,
        debugOwner: debugOwner,
        supportedDevices:
            supportedDevices == null ? null : Set.from(supportedDevices),
      );
    };
Function _HorizontalDragGestureRecognizer_isFlingGesture$(
  m.Scope scope$,
  HorizontalDragGestureRecognizer target$,
) =>
    target$.isFlingGesture;
Function PanGestureRecognizer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PanGestureRecognizer;
Function PanGestureRecognizer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PanGestureRecognizer;
Function _PanGestureRecognizer_debugDescription$(
  m.Scope scope$,
  PanGestureRecognizer target$,
) =>
    () {
      return target$.debugDescription;
    };
Function _PanGestureRecognizer__$(m.Scope scope$) => ({
      Object? debugOwner,
      Set? supportedDevices,
      m.FunctionPointer? allowedButtonsFilter,
    }) {
      bool allowedButtonsFilterProxy(int allowedButtonsFilter_buttons$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            allowedButtonsFilter!,
            [allowedButtonsFilter_buttons$],
            {},
          );
      return PanGestureRecognizer(
        allowedButtonsFilter:
            allowedButtonsFilter == null ? null : allowedButtonsFilterProxy,
        debugOwner: debugOwner,
        supportedDevices:
            supportedDevices == null ? null : Set.from(supportedDevices),
      );
    };
Function _PanGestureRecognizer_isFlingGesture$(
  m.Scope scope$,
  PanGestureRecognizer target$,
) =>
    target$.isFlingGesture;
