// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/gestures/monodrag.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/gestures/constants.dart';
import 'package:flutter/src/gestures/drag_details.dart';
import 'package:flutter/src/gestures/events.dart';
import 'package:flutter/src/gestures/recognizer.dart';
import 'package:flutter/src/gestures/velocity_tracker.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/gestures/monodrag.dart',
  {},
  {},
  {
    'DragGestureRecognizer': m.ClassMirror(
      'DragGestureRecognizer',
      {
        'dragStartBehavior': _DragGestureRecognizer_dragStartBehavior$,
        'onDown': _DragGestureRecognizer_onDown$,
        'onStart': _DragGestureRecognizer_onStart$,
        'onUpdate': _DragGestureRecognizer_onUpdate$,
        'onEnd': _DragGestureRecognizer_onEnd$,
        'onCancel': _DragGestureRecognizer_onCancel$,
        'minFlingDistance': _DragGestureRecognizer_minFlingDistance$,
        'minFlingVelocity': _DragGestureRecognizer_minFlingVelocity$,
        'maxFlingVelocity': _DragGestureRecognizer_maxFlingVelocity$,
        'velocityTrackerBuilder':
            _DragGestureRecognizer_velocityTrackerBuilder$,
        'debugLastPendingEventTimestamp':
            _DragGestureRecognizer_debugLastPendingEventTimestamp$,
        'isFlingGesture': _DragGestureRecognizer_isFlingGesture$,
        'isPointerAllowed': _DragGestureRecognizer_isPointerAllowed$,
        'addAllowedPointer': _DragGestureRecognizer_addAllowedPointer$,
        'addAllowedPointerPanZoom':
            _DragGestureRecognizer_addAllowedPointerPanZoom$,
        'handleEvent': _DragGestureRecognizer_handleEvent$,
        'acceptGesture': _DragGestureRecognizer_acceptGesture$,
        'rejectGesture': _DragGestureRecognizer_rejectGesture$,
        'didStopTrackingLastPointer':
            _DragGestureRecognizer_didStopTrackingLastPointer$,
        'dispose': _DragGestureRecognizer_dispose$,
        'debugFillProperties': _DragGestureRecognizer_debugFillProperties$,
      },
      {
        'dragStartBehavior': _DragGestureRecognizer_dragStartBehavior_set$,
        'onDown': _DragGestureRecognizer_onDown_set$,
        'onStart': _DragGestureRecognizer_onStart_set$,
        'onUpdate': _DragGestureRecognizer_onUpdate_set$,
        'onEnd': _DragGestureRecognizer_onEnd_set$,
        'onCancel': _DragGestureRecognizer_onCancel_set$,
        'minFlingDistance': _DragGestureRecognizer_minFlingDistance_set$,
        'minFlingVelocity': _DragGestureRecognizer_minFlingVelocity_set$,
        'maxFlingVelocity': _DragGestureRecognizer_maxFlingVelocity_set$,
        'velocityTrackerBuilder':
            _DragGestureRecognizer_velocityTrackerBuilder_set$,
      },
    ),
    'VerticalDragGestureRecognizer': m.ClassMirror(
      'VerticalDragGestureRecognizer',
      {
        'debugDescription': _VerticalDragGestureRecognizer_debugDescription$,
        'isFlingGesture': _VerticalDragGestureRecognizer_isFlingGesture$,
      },
      {},
    ),
    'HorizontalDragGestureRecognizer': m.ClassMirror(
      'HorizontalDragGestureRecognizer',
      {
        'debugDescription': _HorizontalDragGestureRecognizer_debugDescription$,
        'isFlingGesture': _HorizontalDragGestureRecognizer_isFlingGesture$,
      },
      {},
    ),
    'PanGestureRecognizer': m.ClassMirror(
      'PanGestureRecognizer',
      {
        'debugDescription': _PanGestureRecognizer_debugDescription$,
        'isFlingGesture': _PanGestureRecognizer_isFlingGesture$,
      },
      {},
    ),
  },
);
DragStartBehavior _DragGestureRecognizer_dragStartBehavior$(
    DragGestureRecognizer target) {
  return target.dragStartBehavior;
}

void _DragGestureRecognizer_dragStartBehavior_set$(
  DragGestureRecognizer target,
  DragStartBehavior other,
) {
  target.dragStartBehavior = other;
}

void Function(DragDownDetails)? _DragGestureRecognizer_onDown$(
    DragGestureRecognizer target) {
  return target.onDown;
}

Function _DragGestureRecognizer_onDown_set$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onDown) {
      void _onDownProxy(DragDownDetails _onDown_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onDown!,
            [_onDown_details],
            {},
          );
      target.onDown = (_onDown == null ? null : _onDownProxy);
    };
void Function(DragStartDetails)? _DragGestureRecognizer_onStart$(
    DragGestureRecognizer target) {
  return target.onStart;
}

Function _DragGestureRecognizer_onStart_set$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onStart) {
      void _onStartProxy(DragStartDetails _onStart_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onStart!,
            [_onStart_details],
            {},
          );
      target.onStart = (_onStart == null ? null : _onStartProxy);
    };
void Function(DragUpdateDetails)? _DragGestureRecognizer_onUpdate$(
    DragGestureRecognizer target) {
  return target.onUpdate;
}

Function _DragGestureRecognizer_onUpdate_set$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onUpdate) {
      void _onUpdateProxy(DragUpdateDetails _onUpdate_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onUpdate!,
            [_onUpdate_details],
            {},
          );
      target.onUpdate = (_onUpdate == null ? null : _onUpdateProxy);
    };
void Function(DragEndDetails)? _DragGestureRecognizer_onEnd$(
    DragGestureRecognizer target) {
  return target.onEnd;
}

Function _DragGestureRecognizer_onEnd_set$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onEnd) {
      void _onEndProxy(DragEndDetails _onEnd_details) =>
          scope.engine.callFunctionPointer(
            scope,
            _onEnd!,
            [_onEnd_details],
            {},
          );
      target.onEnd = (_onEnd == null ? null : _onEndProxy);
    };
void Function()? _DragGestureRecognizer_onCancel$(
    DragGestureRecognizer target) {
  return target.onCancel;
}

Function _DragGestureRecognizer_onCancel_set$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    (m.FunctionPointer? _onCancel) {
      void _onCancelProxy() => scope.engine.callFunctionPointer(
            scope,
            _onCancel!,
            [],
            {},
          );
      target.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
double? _DragGestureRecognizer_minFlingDistance$(DragGestureRecognizer target) {
  return target.minFlingDistance;
}

void _DragGestureRecognizer_minFlingDistance_set$(
  DragGestureRecognizer target,
  double? other,
) {
  target.minFlingDistance = other;
}

double? _DragGestureRecognizer_minFlingVelocity$(DragGestureRecognizer target) {
  return target.minFlingVelocity;
}

void _DragGestureRecognizer_minFlingVelocity_set$(
  DragGestureRecognizer target,
  double? other,
) {
  target.minFlingVelocity = other;
}

double? _DragGestureRecognizer_maxFlingVelocity$(DragGestureRecognizer target) {
  return target.maxFlingVelocity;
}

void _DragGestureRecognizer_maxFlingVelocity_set$(
  DragGestureRecognizer target,
  double? other,
) {
  target.maxFlingVelocity = other;
}

VelocityTracker Function(PointerEvent)
    _DragGestureRecognizer_velocityTrackerBuilder$(
        DragGestureRecognizer target) {
  return target.velocityTrackerBuilder;
}

Function _DragGestureRecognizer_velocityTrackerBuilder_set$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    (m.FunctionPointer _velocityTrackerBuilder) {
      VelocityTracker _velocityTrackerBuilderProxy(
              PointerEvent _velocityTrackerBuilder_event) =>
          scope.engine.callFunctionPointer(
            scope,
            _velocityTrackerBuilder,
            [_velocityTrackerBuilder_event],
            {},
          );
      target.velocityTrackerBuilder = (_velocityTrackerBuilderProxy);
    };
Duration? _DragGestureRecognizer_debugLastPendingEventTimestamp$(
    DragGestureRecognizer target) {
  return target.debugLastPendingEventTimestamp;
}

Function _DragGestureRecognizer_isFlingGesture$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.isFlingGesture;
Function _DragGestureRecognizer_isPointerAllowed$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.isPointerAllowed;
Function _DragGestureRecognizer_addAllowedPointer$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.addAllowedPointer;
Function _DragGestureRecognizer_addAllowedPointerPanZoom$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.addAllowedPointerPanZoom;
Function _DragGestureRecognizer_handleEvent$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.handleEvent;
Function _DragGestureRecognizer_acceptGesture$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.acceptGesture;
Function _DragGestureRecognizer_rejectGesture$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.rejectGesture;
Function _DragGestureRecognizer_didStopTrackingLastPointer$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.didStopTrackingLastPointer;
Function _DragGestureRecognizer_dispose$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.dispose;
Function _DragGestureRecognizer_debugFillProperties$(
  m.Scope scope,
  DragGestureRecognizer target,
) =>
    target.debugFillProperties;
String _VerticalDragGestureRecognizer_debugDescription$(
    VerticalDragGestureRecognizer target) {
  return target.debugDescription;
}

Function _VerticalDragGestureRecognizer_isFlingGesture$(
  m.Scope scope,
  VerticalDragGestureRecognizer target,
) =>
    target.isFlingGesture;
String _HorizontalDragGestureRecognizer_debugDescription$(
    HorizontalDragGestureRecognizer target) {
  return target.debugDescription;
}

Function _HorizontalDragGestureRecognizer_isFlingGesture$(
  m.Scope scope,
  HorizontalDragGestureRecognizer target,
) =>
    target.isFlingGesture;
String _PanGestureRecognizer_debugDescription$(PanGestureRecognizer target) {
  return target.debugDescription;
}

Function _PanGestureRecognizer_isFlingGesture$(
  m.Scope scope,
  PanGestureRecognizer target,
) =>
    target.isFlingGesture;
