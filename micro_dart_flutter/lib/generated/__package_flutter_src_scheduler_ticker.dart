// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/scheduler/ticker.dart';
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/scheduler/binding.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/scheduler/ticker.dart',
  {},
  {},
  {
    'TickerProvider': m.ClassMirror(
      'TickerProvider',
      {},
      {},
    ),
    'Ticker': m.ClassMirror(
      'Ticker',
      {
        'debugLabel': _Ticker_debugLabel$,
        'muted': _Ticker_muted$,
        'isTicking': _Ticker_isTicking$,
        'isActive': _Ticker_isActive$,
        'scheduled': _Ticker_scheduled$,
        'shouldScheduleTick': _Ticker_shouldScheduleTick$,
        'start': _Ticker_start$,
        'describeForError': _Ticker_describeForError$,
        'stop': _Ticker_stop$,
        'scheduleTick': _Ticker_scheduleTick$,
        'unscheduleTick': _Ticker_unscheduleTick$,
        'absorbTicker': _Ticker_absorbTicker$,
        'dispose': _Ticker_dispose$,
        'toString': _Ticker_toString$,
      },
      {'muted': _Ticker_muted_set$},
    ),
    'TickerFuture': m.ClassMirror(
      'TickerFuture',
      {
        'orCancel': _TickerFuture_orCancel$,
        'asStream': _TickerFuture_asStream$,
        'toString': _TickerFuture_toString$,
      },
      {},
    ),
    'TickerCanceled': m.ClassMirror(
      'TickerCanceled',
      {
        'ticker': _TickerCanceled_ticker$,
        'toString': _TickerCanceled_toString$,
      },
      {},
    ),
  },
);
String? _Ticker_debugLabel$(Ticker target) {
  return target.debugLabel;
}

bool _Ticker_muted$(Ticker target) {
  return target.muted;
}

void _Ticker_muted_set$(
  Ticker target,
  bool other,
) {
  target.muted = other;
}

bool _Ticker_isTicking$(Ticker target) {
  return target.isTicking;
}

bool _Ticker_isActive$(Ticker target) {
  return target.isActive;
}

bool _Ticker_scheduled$(Ticker target) {
  return target.scheduled;
}

bool _Ticker_shouldScheduleTick$(Ticker target) {
  return target.shouldScheduleTick;
}

Function _Ticker_start$(
  m.Scope scope,
  Ticker target,
) =>
    target.start;
Function _Ticker_describeForError$(
  m.Scope scope,
  Ticker target,
) =>
    target.describeForError;
Function _Ticker_stop$(
  m.Scope scope,
  Ticker target,
) =>
    target.stop;
Function _Ticker_scheduleTick$(
  m.Scope scope,
  Ticker target,
) =>
    target.scheduleTick;
Function _Ticker_unscheduleTick$(
  m.Scope scope,
  Ticker target,
) =>
    target.unscheduleTick;
Function _Ticker_absorbTicker$(
  m.Scope scope,
  Ticker target,
) =>
    target.absorbTicker;
Function _Ticker_dispose$(
  m.Scope scope,
  Ticker target,
) =>
    target.dispose;
Function _Ticker_toString$(
  m.Scope scope,
  Ticker target,
) =>
    target.toString;
Future<void> _TickerFuture_orCancel$(TickerFuture target) {
  return target.orCancel;
}

Function _TickerFuture_asStream$(
  m.Scope scope,
  TickerFuture target,
) =>
    target.asStream;
Function _TickerFuture_toString$(
  m.Scope scope,
  TickerFuture target,
) =>
    target.toString;
Ticker? _TickerCanceled_ticker$(TickerCanceled target) {
  return target.ticker;
}

Function _TickerCanceled_toString$(
  m.Scope scope,
  TickerCanceled target,
) =>
    target.toString;
