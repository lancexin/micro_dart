// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/rendering/box.dart';
import 'dart:developer' show Timeline;
import 'dart:math';
import 'dart:ui' show lerpDouble;
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/rendering/debug.dart';
import 'package:flutter/src/rendering/object.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/rendering/box.dart',
  {
    'BoxConstraints.lerp': _BoxConstraints_lerp$,
    'BoxConstraints.debugAssertIsValid': _BoxConstraints_debugAssertIsValid$,
    'BoxHitTestResult.addWithPaintTransform':
        _BoxHitTestResult_addWithPaintTransform$,
    'BoxHitTestResult.addWithPaintOffset':
        _BoxHitTestResult_addWithPaintOffset$,
    'BoxHitTestResult.addWithRawTransform':
        _BoxHitTestResult_addWithRawTransform$,
    'BoxHitTestResult.addWithOutOfBandPosition':
        _BoxHitTestResult_addWithOutOfBandPosition$,
  },
  {},
  {
    'BoxConstraints': m.ClassMirror(
      'BoxConstraints',
      {
        '#as': BoxConstraints_as$,
        '#is': BoxConstraints_is$,
        'minWidth': _BoxConstraints_minWidth$,
        'maxWidth': _BoxConstraints_maxWidth$,
        'minHeight': _BoxConstraints_minHeight$,
        'maxHeight': _BoxConstraints_maxHeight$,
        'flipped': _BoxConstraints_flipped$,
        'biggest': _BoxConstraints_biggest$,
        'smallest': _BoxConstraints_smallest$,
        'hasTightWidth': _BoxConstraints_hasTightWidth$,
        'hasTightHeight': _BoxConstraints_hasTightHeight$,
        'isTight': _BoxConstraints_isTight$,
        'hasBoundedWidth': _BoxConstraints_hasBoundedWidth$,
        'hasBoundedHeight': _BoxConstraints_hasBoundedHeight$,
        'hasInfiniteWidth': _BoxConstraints_hasInfiniteWidth$,
        'hasInfiniteHeight': _BoxConstraints_hasInfiniteHeight$,
        'isNormalized': _BoxConstraints_isNormalized$,
        'hashCode': _BoxConstraints_hashCode$,
        'copyWith': _BoxConstraints_copyWith$,
        'deflate': _BoxConstraints_deflate$,
        'loosen': _BoxConstraints_loosen$,
        'enforce': _BoxConstraints_enforce$,
        'tighten': _BoxConstraints_tighten$,
        'widthConstraints': _BoxConstraints_widthConstraints$,
        'heightConstraints': _BoxConstraints_heightConstraints$,
        'constrainWidth': _BoxConstraints_constrainWidth$,
        'constrainHeight': _BoxConstraints_constrainHeight$,
        'constrain': _BoxConstraints_constrain$,
        'constrainDimensions': _BoxConstraints_constrainDimensions$,
        'constrainSizeAndAttemptToPreserveAspectRatio':
            _BoxConstraints_constrainSizeAndAttemptToPreserveAspectRatio$,
        'isSatisfiedBy': _BoxConstraints_isSatisfiedBy$,
        '*': _BoxConstraints_times$$,
        '/': _BoxConstraints_over$$,
        '~/': _BoxConstraints_division$$,
        '%': _BoxConstraints_surplus$$,
        'normalize': _BoxConstraints_normalize$,
        '==': _BoxConstraints_eq$$,
        'toString': _BoxConstraints_toString$,
      },
      {},
    ),
    'BoxHitTestResult': m.ClassMirror(
      'BoxHitTestResult',
      {
        '#as': BoxHitTestResult_as$,
        '#is': BoxHitTestResult_is$,
      },
      {},
    ),
    'BoxHitTestEntry': m.ClassMirror(
      'BoxHitTestEntry',
      {
        '#as': BoxHitTestEntry_as$,
        '#is': BoxHitTestEntry_is$,
        'localPosition': _BoxHitTestEntry_localPosition$,
        'toString': _BoxHitTestEntry_toString$,
      },
      {},
    ),
    'BoxParentData': m.ClassMirror(
      'BoxParentData',
      {
        '#as': BoxParentData_as$,
        '#is': BoxParentData_is$,
        'offset': _BoxParentData_offset$,
        'toString': _BoxParentData_toString$,
      },
      {'offset': _BoxParentData_offset_set$},
    ),
    'ContainerBoxParentData': m.ClassMirror(
      'ContainerBoxParentData',
      {
        '#as': ContainerBoxParentData_as$,
        '#is': ContainerBoxParentData_is$,
      },
      {},
    ),
    'RenderBox': m.ClassMirror(
      'RenderBox',
      {
        '#as': RenderBox_as$,
        '#is': RenderBox_is$,
        'hasSize': _RenderBox_hasSize$,
        'size': _RenderBox_size$,
        'semanticBounds': _RenderBox_semanticBounds$,
        'constraints': _RenderBox_constraints$,
        'paintBounds': _RenderBox_paintBounds$,
        'setupParentData': _RenderBox_setupParentData$,
        'getMinIntrinsicWidth': _RenderBox_getMinIntrinsicWidth$,
        'computeMinIntrinsicWidth': _RenderBox_computeMinIntrinsicWidth$,
        'getMaxIntrinsicWidth': _RenderBox_getMaxIntrinsicWidth$,
        'computeMaxIntrinsicWidth': _RenderBox_computeMaxIntrinsicWidth$,
        'getMinIntrinsicHeight': _RenderBox_getMinIntrinsicHeight$,
        'computeMinIntrinsicHeight': _RenderBox_computeMinIntrinsicHeight$,
        'getMaxIntrinsicHeight': _RenderBox_getMaxIntrinsicHeight$,
        'computeMaxIntrinsicHeight': _RenderBox_computeMaxIntrinsicHeight$,
        'getDryLayout': _RenderBox_getDryLayout$,
        'computeDryLayout': _RenderBox_computeDryLayout$,
        'debugCannotComputeDryLayout': _RenderBox_debugCannotComputeDryLayout$,
        'debugAdoptSize': _RenderBox_debugAdoptSize$,
        'debugResetSize': _RenderBox_debugResetSize$,
        'getDistanceToBaseline': _RenderBox_getDistanceToBaseline$,
        'getDistanceToActualBaseline': _RenderBox_getDistanceToActualBaseline$,
        'computeDistanceToActualBaseline':
            _RenderBox_computeDistanceToActualBaseline$,
        'debugAssertDoesMeetConstraints':
            _RenderBox_debugAssertDoesMeetConstraints$,
        'markNeedsLayout': _RenderBox_markNeedsLayout$,
        'layout': _RenderBox_layout$,
        'performResize': _RenderBox_performResize$,
        'performLayout': _RenderBox_performLayout$,
        'hitTest': _RenderBox_hitTest$,
        'hitTestSelf': _RenderBox_hitTestSelf$,
        'hitTestChildren': _RenderBox_hitTestChildren$,
        'applyPaintTransform': _RenderBox_applyPaintTransform$,
        'globalToLocal': _RenderBox_globalToLocal$,
        'localToGlobal': _RenderBox_localToGlobal$,
        'handleEvent': _RenderBox_handleEvent$,
        'debugHandleEvent': _RenderBox_debugHandleEvent$,
        'debugPaint': _RenderBox_debugPaint$,
        'debugPaintSize': _RenderBox_debugPaintSize$,
        'debugPaintBaselines': _RenderBox_debugPaintBaselines$,
        'debugPaintPointers': _RenderBox_debugPaintPointers$,
        'debugFillProperties': _RenderBox_debugFillProperties$,
      },
      {'size': _RenderBox_size_set$},
    ),
  },
);
Function BoxConstraints_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BoxConstraints;
Function BoxConstraints_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BoxConstraints;
double _BoxConstraints_minWidth$(BoxConstraints target) {
  return target.minWidth;
}

double _BoxConstraints_maxWidth$(BoxConstraints target) {
  return target.maxWidth;
}

double _BoxConstraints_minHeight$(BoxConstraints target) {
  return target.minHeight;
}

double _BoxConstraints_maxHeight$(BoxConstraints target) {
  return target.maxHeight;
}

BoxConstraints _BoxConstraints_flipped$(BoxConstraints target) {
  return target.flipped;
}

Size _BoxConstraints_biggest$(BoxConstraints target) {
  return target.biggest;
}

Size _BoxConstraints_smallest$(BoxConstraints target) {
  return target.smallest;
}

bool _BoxConstraints_hasTightWidth$(BoxConstraints target) {
  return target.hasTightWidth;
}

bool _BoxConstraints_hasTightHeight$(BoxConstraints target) {
  return target.hasTightHeight;
}

bool _BoxConstraints_isTight$(BoxConstraints target) {
  return target.isTight;
}

bool _BoxConstraints_hasBoundedWidth$(BoxConstraints target) {
  return target.hasBoundedWidth;
}

bool _BoxConstraints_hasBoundedHeight$(BoxConstraints target) {
  return target.hasBoundedHeight;
}

bool _BoxConstraints_hasInfiniteWidth$(BoxConstraints target) {
  return target.hasInfiniteWidth;
}

bool _BoxConstraints_hasInfiniteHeight$(BoxConstraints target) {
  return target.hasInfiniteHeight;
}

bool _BoxConstraints_isNormalized$(BoxConstraints target) {
  return target.isNormalized;
}

int _BoxConstraints_hashCode$(BoxConstraints target) {
  return target.hashCode;
}

Function _BoxConstraints_copyWith$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.copyWith;
Function _BoxConstraints_deflate$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.deflate;
Function _BoxConstraints_loosen$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.loosen;
Function _BoxConstraints_enforce$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.enforce;
Function _BoxConstraints_tighten$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.tighten;
Function _BoxConstraints_widthConstraints$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.widthConstraints;
Function _BoxConstraints_heightConstraints$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.heightConstraints;
Function _BoxConstraints_constrainWidth$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.constrainWidth;
Function _BoxConstraints_constrainHeight$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.constrainHeight;
Function _BoxConstraints_constrain$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.constrain;
Function _BoxConstraints_constrainDimensions$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.constrainDimensions;
Function _BoxConstraints_constrainSizeAndAttemptToPreserveAspectRatio$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.constrainSizeAndAttemptToPreserveAspectRatio;
Function _BoxConstraints_isSatisfiedBy$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.isSatisfiedBy;
Function _BoxConstraints_times$$(
  m.Scope scope,
  BoxConstraints target,
) =>
    (double other) => target * other;
Function _BoxConstraints_over$$(
  m.Scope scope,
  BoxConstraints target,
) =>
    (double other) => target / other;
Function _BoxConstraints_division$$(
  m.Scope scope,
  BoxConstraints target,
) =>
    (double other) => target ~/ other;
Function _BoxConstraints_surplus$$(
  m.Scope scope,
  BoxConstraints target,
) =>
    (double other) => target % other;
Function _BoxConstraints_lerp$(m.Scope scope) => BoxConstraints.lerp;
Function _BoxConstraints_debugAssertIsValid$(
  m.Scope scope,
  BoxConstraints target,
) =>
    ({
      m.FunctionPointer? informationCollector,
      bool? isAppliedConstraint,
    }) {
      Iterable<DiagnosticsNode> informationCollectorProxy() =>
          scope.engine.callFunctionPointer(
            scope,
            informationCollector!,
            [],
            {},
          );
      return target.debugAssertIsValid(
        informationCollector:
            informationCollector == null ? null : informationCollectorProxy,
        isAppliedConstraint:
            isAppliedConstraint == null ? false : isAppliedConstraint,
      );
    };
Function _BoxConstraints_normalize$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.normalize;
Function _BoxConstraints_eq$$(
  m.Scope scope,
  BoxConstraints target,
) =>
    (Object other) => target == other;
Function _BoxConstraints_toString$(
  m.Scope scope,
  BoxConstraints target,
) =>
    target.toString;
Function BoxHitTestResult_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BoxHitTestResult;
Function BoxHitTestResult_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BoxHitTestResult;
Function _BoxHitTestResult_addWithPaintTransform$(
  m.Scope scope,
  BoxHitTestResult target,
) =>
    ({
      required m.FunctionPointer hitTest,
      required Offset position,
      required Matrix4? transform,
    }) {
      bool hitTestProxy(
        BoxHitTestResult hitTest_result,
        Offset hitTest_position,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            hitTest,
            [
              hitTest_result,
              hitTest_position,
            ],
            {},
          );
      return target.addWithPaintTransform(
        hitTest: hitTestProxy,
        position: position,
        transform: transform,
      );
    };
Function _BoxHitTestResult_addWithPaintOffset$(
  m.Scope scope,
  BoxHitTestResult target,
) =>
    ({
      required m.FunctionPointer hitTest,
      required Offset? offset,
      required Offset position,
    }) {
      bool hitTestProxy(
        BoxHitTestResult hitTest_result,
        Offset hitTest_position,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            hitTest,
            [
              hitTest_result,
              hitTest_position,
            ],
            {},
          );
      return target.addWithPaintOffset(
        hitTest: hitTestProxy,
        offset: offset,
        position: position,
      );
    };
Function _BoxHitTestResult_addWithRawTransform$(
  m.Scope scope,
  BoxHitTestResult target,
) =>
    ({
      required m.FunctionPointer hitTest,
      required Offset position,
      required Matrix4? transform,
    }) {
      bool hitTestProxy(
        BoxHitTestResult hitTest_result,
        Offset hitTest_position,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            hitTest,
            [
              hitTest_result,
              hitTest_position,
            ],
            {},
          );
      return target.addWithRawTransform(
        hitTest: hitTestProxy,
        position: position,
        transform: transform,
      );
    };
Function _BoxHitTestResult_addWithOutOfBandPosition$(
  m.Scope scope,
  BoxHitTestResult target,
) =>
    ({
      required m.FunctionPointer hitTest,
      Offset? paintOffset,
      Matrix4? paintTransform,
      Matrix4? rawTransform,
    }) {
      bool hitTestProxy(BoxHitTestResult hitTest_result) =>
          scope.engine.callFunctionPointer(
            scope,
            hitTest,
            [hitTest_result],
            {},
          );
      return target.addWithOutOfBandPosition(
        hitTest: hitTestProxy,
        paintOffset: paintOffset,
        paintTransform: paintTransform,
        rawTransform: rawTransform,
      );
    };
Function BoxHitTestEntry_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BoxHitTestEntry;
Function BoxHitTestEntry_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BoxHitTestEntry;
Offset _BoxHitTestEntry_localPosition$(BoxHitTestEntry target) {
  return target.localPosition;
}

Function _BoxHitTestEntry_toString$(
  m.Scope scope,
  BoxHitTestEntry target,
) =>
    target.toString;
Function BoxParentData_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BoxParentData;
Function BoxParentData_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BoxParentData;
Offset _BoxParentData_offset$(BoxParentData target) {
  return target.offset;
}

void _BoxParentData_offset_set$(
  BoxParentData target,
  Offset other,
) {
  target.offset = other;
}

Function _BoxParentData_toString$(
  m.Scope scope,
  BoxParentData target,
) =>
    target.toString;
Function ContainerBoxParentData_as$<ChildType extends RenderObject>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ContainerBoxParentData<ChildType>;
Function ContainerBoxParentData_is$<ChildType extends RenderObject>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ContainerBoxParentData<ChildType>;
Function RenderBox_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as RenderBox;
Function RenderBox_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is RenderBox;
bool _RenderBox_hasSize$(RenderBox target) {
  return target.hasSize;
}

Size _RenderBox_size$(RenderBox target) {
  return target.size;
}

void _RenderBox_size_set$(
  RenderBox target,
  Size other,
) {
  target.size = other;
}

Rect _RenderBox_semanticBounds$(RenderBox target) {
  return target.semanticBounds;
}

BoxConstraints _RenderBox_constraints$(RenderBox target) {
  return target.constraints;
}

Rect _RenderBox_paintBounds$(RenderBox target) {
  return target.paintBounds;
}

Function _RenderBox_setupParentData$(
  m.Scope scope,
  RenderBox target,
) =>
    target.setupParentData;
Function _RenderBox_getMinIntrinsicWidth$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getMinIntrinsicWidth;
Function _RenderBox_computeMinIntrinsicWidth$(
  m.Scope scope,
  RenderBox target,
) =>
    target.computeMinIntrinsicWidth;
Function _RenderBox_getMaxIntrinsicWidth$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getMaxIntrinsicWidth;
Function _RenderBox_computeMaxIntrinsicWidth$(
  m.Scope scope,
  RenderBox target,
) =>
    target.computeMaxIntrinsicWidth;
Function _RenderBox_getMinIntrinsicHeight$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getMinIntrinsicHeight;
Function _RenderBox_computeMinIntrinsicHeight$(
  m.Scope scope,
  RenderBox target,
) =>
    target.computeMinIntrinsicHeight;
Function _RenderBox_getMaxIntrinsicHeight$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getMaxIntrinsicHeight;
Function _RenderBox_computeMaxIntrinsicHeight$(
  m.Scope scope,
  RenderBox target,
) =>
    target.computeMaxIntrinsicHeight;
Function _RenderBox_getDryLayout$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getDryLayout;
Function _RenderBox_computeDryLayout$(
  m.Scope scope,
  RenderBox target,
) =>
    target.computeDryLayout;
Function _RenderBox_debugCannotComputeDryLayout$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugCannotComputeDryLayout;
Function _RenderBox_debugAdoptSize$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugAdoptSize;
Function _RenderBox_debugResetSize$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugResetSize;
Function _RenderBox_getDistanceToBaseline$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getDistanceToBaseline;
Function _RenderBox_getDistanceToActualBaseline$(
  m.Scope scope,
  RenderBox target,
) =>
    target.getDistanceToActualBaseline;
Function _RenderBox_computeDistanceToActualBaseline$(
  m.Scope scope,
  RenderBox target,
) =>
    target.computeDistanceToActualBaseline;
Function _RenderBox_debugAssertDoesMeetConstraints$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugAssertDoesMeetConstraints;
Function _RenderBox_markNeedsLayout$(
  m.Scope scope,
  RenderBox target,
) =>
    target.markNeedsLayout;
Function _RenderBox_layout$(
  m.Scope scope,
  RenderBox target,
) =>
    target.layout;
Function _RenderBox_performResize$(
  m.Scope scope,
  RenderBox target,
) =>
    target.performResize;
Function _RenderBox_performLayout$(
  m.Scope scope,
  RenderBox target,
) =>
    target.performLayout;
Function _RenderBox_hitTest$(
  m.Scope scope,
  RenderBox target,
) =>
    target.hitTest;
Function _RenderBox_hitTestSelf$(
  m.Scope scope,
  RenderBox target,
) =>
    target.hitTestSelf;
Function _RenderBox_hitTestChildren$(
  m.Scope scope,
  RenderBox target,
) =>
    target.hitTestChildren;
Function _RenderBox_applyPaintTransform$(
  m.Scope scope,
  RenderBox target,
) =>
    target.applyPaintTransform;
Function _RenderBox_globalToLocal$(
  m.Scope scope,
  RenderBox target,
) =>
    target.globalToLocal;
Function _RenderBox_localToGlobal$(
  m.Scope scope,
  RenderBox target,
) =>
    target.localToGlobal;
Function _RenderBox_handleEvent$(
  m.Scope scope,
  RenderBox target,
) =>
    target.handleEvent;
Function _RenderBox_debugHandleEvent$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugHandleEvent;
Function _RenderBox_debugPaint$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugPaint;
Function _RenderBox_debugPaintSize$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugPaintSize;
Function _RenderBox_debugPaintBaselines$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugPaintBaselines;
Function _RenderBox_debugPaintPointers$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugPaintPointers;
Function _RenderBox_debugFillProperties$(
  m.Scope scope,
  RenderBox target,
) =>
    target.debugFillProperties;
