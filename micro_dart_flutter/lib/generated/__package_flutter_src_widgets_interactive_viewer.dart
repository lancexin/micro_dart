// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/interactive_viewer.dart';
import 'dart:math';
import 'package:flutter/foundation.dart' show clampDouble;
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:vector_math/vector_math_64.dart' show Matrix4, Quad, Vector3;
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';
import 'package:flutter/src/widgets/layout_builder.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/interactive_viewer.dart',
  {
    'InteractiveViewer.': _InteractiveViewer__$,
    'InteractiveViewer.builder': _InteractiveViewer_builder_$,
    'InteractiveViewer.getNearestPointOnLine':
        _InteractiveViewer_getNearestPointOnLine$,
    'InteractiveViewer.getAxisAlignedBoundingBox':
        _InteractiveViewer_getAxisAlignedBoundingBox$,
    'InteractiveViewer.pointIsInside': _InteractiveViewer_pointIsInside$,
    'InteractiveViewer.getNearestPointInside':
        _InteractiveViewer_getNearestPointInside$,
    'TransformationController.': _TransformationController__$,
    'PanAxis.horizontal': _PanAxis_horizontal$,
    'PanAxis.vertical': _PanAxis_vertical$,
    'PanAxis.aligned': _PanAxis_aligned$,
    'PanAxis.free': _PanAxis_free$,
    'PanAxis.values': _PanAxis_values$,
  },
  {},
  {
    'InteractiveViewer': m.ClassMirror(
      'InteractiveViewer',
      {
        '#as': InteractiveViewer_as$,
        '#is': InteractiveViewer_is$,
        'alignment': _InteractiveViewer_alignment$,
        'clipBehavior': _InteractiveViewer_clipBehavior$,
        'alignPanAxis': _InteractiveViewer_alignPanAxis$,
        'panAxis': _InteractiveViewer_panAxis$,
        'boundaryMargin': _InteractiveViewer_boundaryMargin$,
        'builder': _InteractiveViewer_builder$,
        'child': _InteractiveViewer_child$,
        'constrained': _InteractiveViewer_constrained$,
        'panEnabled': _InteractiveViewer_panEnabled$,
        'scaleEnabled': _InteractiveViewer_scaleEnabled$,
        'trackpadScrollCausesScale':
            _InteractiveViewer_trackpadScrollCausesScale$,
        'scaleFactor': _InteractiveViewer_scaleFactor$,
        'maxScale': _InteractiveViewer_maxScale$,
        'minScale': _InteractiveViewer_minScale$,
        'interactionEndFrictionCoefficient':
            _InteractiveViewer_interactionEndFrictionCoefficient$,
        'onInteractionEnd': _InteractiveViewer_onInteractionEnd$,
        'onInteractionStart': _InteractiveViewer_onInteractionStart$,
        'onInteractionUpdate': _InteractiveViewer_onInteractionUpdate$,
        'transformationController':
            _InteractiveViewer_transformationController$,
        'createState': _InteractiveViewer_createState$,
      },
      {},
    ),
    'TransformationController': m.ClassMirror(
      'TransformationController',
      {
        '#as': TransformationController_as$,
        '#is': TransformationController_is$,
        'toScene': _TransformationController_toScene$,
      },
      {},
    ),
    'PanAxis': m.ClassMirror(
      'PanAxis',
      {},
      {},
    ),
  },
);
Function InteractiveViewer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as InteractiveViewer;
Function InteractiveViewer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is InteractiveViewer;
Function _InteractiveViewer_alignment$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.alignment;
    };
Function _InteractiveViewer_clipBehavior$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _InteractiveViewer_alignPanAxis$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.alignPanAxis;
    };
Function _InteractiveViewer_panAxis$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.panAxis;
    };
Function _InteractiveViewer_boundaryMargin$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.boundaryMargin;
    };
Function _InteractiveViewer_builder$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.builder;
    };
Function _InteractiveViewer_child$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.child;
    };
Function _InteractiveViewer_constrained$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.constrained;
    };
Function _InteractiveViewer_panEnabled$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.panEnabled;
    };
Function _InteractiveViewer_scaleEnabled$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.scaleEnabled;
    };
Function _InteractiveViewer_trackpadScrollCausesScale$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.trackpadScrollCausesScale;
    };
Function _InteractiveViewer_scaleFactor$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.scaleFactor;
    };
Function _InteractiveViewer_maxScale$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.maxScale;
    };
Function _InteractiveViewer_minScale$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.minScale;
    };
Function _InteractiveViewer_interactionEndFrictionCoefficient$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.interactionEndFrictionCoefficient;
    };
Function _InteractiveViewer_onInteractionEnd$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.onInteractionEnd;
    };
Function _InteractiveViewer_onInteractionStart$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.onInteractionStart;
    };
Function _InteractiveViewer_onInteractionUpdate$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.onInteractionUpdate;
    };
Function _InteractiveViewer_transformationController$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    () {
      return target$.transformationController;
    };
Function _InteractiveViewer__$(m.Scope scope$) => ({
      Key? key,
      Clip? clipBehavior,
      bool? alignPanAxis,
      PanAxis? panAxis,
      EdgeInsets? boundaryMargin,
      bool? constrained,
      double? maxScale,
      double? minScale,
      double? interactionEndFrictionCoefficient,
      m.FunctionPointer? onInteractionEnd,
      m.FunctionPointer? onInteractionStart,
      m.FunctionPointer? onInteractionUpdate,
      bool? panEnabled,
      bool? scaleEnabled,
      double? scaleFactor,
      TransformationController? transformationController,
      Alignment? alignment,
      bool? trackpadScrollCausesScale,
      required Widget child,
    }) {
      void onInteractionEndProxy(ScaleEndDetails onInteractionEnd_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionEnd!,
            [onInteractionEnd_details$],
            {},
          );
      void onInteractionStartProxy(
              ScaleStartDetails onInteractionStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionStart!,
            [onInteractionStart_details$],
            {},
          );
      void onInteractionUpdateProxy(
              ScaleUpdateDetails onInteractionUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionUpdate!,
            [onInteractionUpdate_details$],
            {},
          );
      return InteractiveViewer(
        alignPanAxis: alignPanAxis ?? false,
        alignment: alignment,
        boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
        child: child,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        constrained: constrained ?? true,
        interactionEndFrictionCoefficient:
            interactionEndFrictionCoefficient ?? 0.0000135,
        key: key,
        maxScale: maxScale ?? 2.5,
        minScale: minScale ?? 0.8,
        onInteractionEnd:
            onInteractionEnd == null ? null : onInteractionEndProxy,
        onInteractionStart:
            onInteractionStart == null ? null : onInteractionStartProxy,
        onInteractionUpdate:
            onInteractionUpdate == null ? null : onInteractionUpdateProxy,
        panAxis: panAxis ?? PanAxis.free,
        panEnabled: panEnabled ?? true,
        scaleEnabled: scaleEnabled ?? true,
        scaleFactor: scaleFactor ?? kDefaultMouseScrollToScaleFactor,
        trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
        transformationController: transformationController,
      );
    };

const double _kDrag = 0.0000135;
Function _InteractiveViewer_builder_$(m.Scope scope$) => ({
      Key? key,
      Clip? clipBehavior,
      bool? alignPanAxis,
      PanAxis? panAxis,
      EdgeInsets? boundaryMargin,
      double? maxScale,
      double? minScale,
      double? interactionEndFrictionCoefficient,
      m.FunctionPointer? onInteractionEnd,
      m.FunctionPointer? onInteractionStart,
      m.FunctionPointer? onInteractionUpdate,
      bool? panEnabled,
      bool? scaleEnabled,
      double? scaleFactor,
      TransformationController? transformationController,
      Alignment? alignment,
      bool? trackpadScrollCausesScale,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        Quad builder_viewport$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [
              builder_context$,
              builder_viewport$,
            ],
            {},
          );
      void onInteractionEndProxy(ScaleEndDetails onInteractionEnd_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionEnd!,
            [onInteractionEnd_details$],
            {},
          );
      void onInteractionStartProxy(
              ScaleStartDetails onInteractionStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionStart!,
            [onInteractionStart_details$],
            {},
          );
      void onInteractionUpdateProxy(
              ScaleUpdateDetails onInteractionUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onInteractionUpdate!,
            [onInteractionUpdate_details$],
            {},
          );
      return InteractiveViewer.builder(
        alignPanAxis: alignPanAxis ?? false,
        alignment: alignment,
        boundaryMargin: boundaryMargin ?? EdgeInsets.zero,
        builder: builderProxy,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        interactionEndFrictionCoefficient:
            interactionEndFrictionCoefficient ?? _kDrag,
        key: key,
        maxScale: maxScale ?? 2.5,
        minScale: minScale ?? 0.8,
        onInteractionEnd:
            onInteractionEnd == null ? null : onInteractionEndProxy,
        onInteractionStart:
            onInteractionStart == null ? null : onInteractionStartProxy,
        onInteractionUpdate:
            onInteractionUpdate == null ? null : onInteractionUpdateProxy,
        panAxis: panAxis ?? PanAxis.free,
        panEnabled: panEnabled ?? true,
        scaleEnabled: scaleEnabled ?? true,
        scaleFactor: scaleFactor ?? 200.0,
        trackpadScrollCausesScale: trackpadScrollCausesScale ?? false,
        transformationController: transformationController,
      );
    };
Function _InteractiveViewer_getNearestPointOnLine$(m.Scope scope$) =>
    InteractiveViewer.getNearestPointOnLine;
Function _InteractiveViewer_getAxisAlignedBoundingBox$(m.Scope scope$) =>
    InteractiveViewer.getAxisAlignedBoundingBox;
Function _InteractiveViewer_pointIsInside$(m.Scope scope$) =>
    InteractiveViewer.pointIsInside;
Function _InteractiveViewer_getNearestPointInside$(m.Scope scope$) =>
    InteractiveViewer.getNearestPointInside;
Function _InteractiveViewer_createState$(
  m.Scope scope$,
  InteractiveViewer target$,
) =>
    target$.createState;
Function TransformationController_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TransformationController;
Function TransformationController_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TransformationController;
Function _TransformationController__$(m.Scope scope$) => ([Matrix4? value]) {
      if (value == null) {
        return TransformationController();
      }
      return TransformationController(value!);
    };
Function _TransformationController_toScene$(
  m.Scope scope$,
  TransformationController target$,
) =>
    target$.toScene;
PanAxis _PanAxis_horizontal$() {
  return PanAxis.horizontal;
}

PanAxis _PanAxis_vertical$() {
  return PanAxis.vertical;
}

PanAxis _PanAxis_aligned$() {
  return PanAxis.aligned;
}

PanAxis _PanAxis_free$() {
  return PanAxis.free;
}

List<PanAxis> _PanAxis_values$() {
  return PanAxis.values;
}
