// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/editable_text.dart';
import 'dart:async';
import 'dart:math';
import 'dart:ui' hide TextStyle;
import 'package:characters/characters.dart'
    show CharacterRange, StringCharacters;
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart' show DragStartBehavior;
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/actions.dart';
import 'package:flutter/src/widgets/autofill.dart';
import 'package:flutter/src/widgets/automatic_keep_alive.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/constants.dart';
import 'package:flutter/src/widgets/context_menu_button_item.dart';
import 'package:flutter/src/widgets/debug.dart';
import 'package:flutter/src/widgets/default_selection_style.dart';
import 'package:flutter/src/widgets/default_text_editing_shortcuts.dart';
import 'package:flutter/src/widgets/focus_manager.dart';
import 'package:flutter/src/widgets/focus_scope.dart';
import 'package:flutter/src/widgets/focus_traversal.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/localizations.dart';
import 'package:flutter/src/widgets/magnifier.dart';
import 'package:flutter/src/widgets/media_query.dart';
import 'package:flutter/src/widgets/scroll_configuration.dart';
import 'package:flutter/src/widgets/scroll_controller.dart';
import 'package:flutter/src/widgets/scroll_physics.dart';
import 'package:flutter/src/widgets/scroll_position.dart';
import 'package:flutter/src/widgets/scrollable.dart';
import 'package:flutter/src/widgets/scrollable_helpers.dart';
import 'package:flutter/src/widgets/shortcuts.dart';
import 'package:flutter/src/widgets/spell_check.dart';
import 'package:flutter/src/widgets/tap_region.dart';
import 'package:flutter/src/widgets/text.dart';
import 'package:flutter/src/widgets/text_editing_intents.dart';
import 'package:flutter/src/widgets/text_selection.dart';
import 'package:flutter/src/widgets/text_selection_toolbar_anchors.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';
import 'package:flutter/src/widgets/undo_history.dart';
import 'package:flutter/src/widgets/view.dart';
import 'package:flutter/src/widgets/widget_span.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/editable_text.dart',
  {
    'kDefaultContentInsertionMimeTypes': _kDefaultContentInsertionMimeTypes$,
    'EditableText.debugDeterministicCursor':
        _EditableText_debugDeterministicCursor$,
    'EditableText.getEditableButtonItems':
        _EditableText_getEditableButtonItems$,
  },
  {
    'EditableText.debugDeterministicCursor':
        _EditableText_debugDeterministicCursor_set$
  },
  {
    'TextEditingController': m.ClassMirror(
      'TextEditingController',
      {
        '#as': TextEditingController_as$,
        '#is': TextEditingController_is$,
        'text': _TextEditingController_text$,
        'selection': _TextEditingController_selection$,
        'buildTextSpan': _TextEditingController_buildTextSpan$,
        'clear': _TextEditingController_clear$,
        'clearComposing': _TextEditingController_clearComposing$,
        'isSelectionWithinTextBounds':
            _TextEditingController_isSelectionWithinTextBounds$,
      },
      {
        'text': _TextEditingController_text_set$,
        'value': _TextEditingController_value_set$,
        'selection': _TextEditingController_selection_set$,
      },
    ),
    'ContentInsertionConfiguration': m.ClassMirror(
      'ContentInsertionConfiguration',
      {
        '#as': ContentInsertionConfiguration_as$,
        '#is': ContentInsertionConfiguration_is$,
        'onContentInserted': _ContentInsertionConfiguration_onContentInserted$,
        'allowedMimeTypes': _ContentInsertionConfiguration_allowedMimeTypes$,
      },
      {},
    ),
    'EditableText': m.ClassMirror(
      'EditableText',
      {
        '#as': EditableText_as$,
        '#is': EditableText_is$,
        'controller': _EditableText_controller$,
        'focusNode': _EditableText_focusNode$,
        'obscuringCharacter': _EditableText_obscuringCharacter$,
        'obscureText': _EditableText_obscureText$,
        'textHeightBehavior': _EditableText_textHeightBehavior$,
        'textWidthBasis': _EditableText_textWidthBasis$,
        'readOnly': _EditableText_readOnly$,
        'forceLine': _EditableText_forceLine$,
        'toolbarOptions': _EditableText_toolbarOptions$,
        'showSelectionHandles': _EditableText_showSelectionHandles$,
        'showCursor': _EditableText_showCursor$,
        'autocorrect': _EditableText_autocorrect$,
        'smartDashesType': _EditableText_smartDashesType$,
        'smartQuotesType': _EditableText_smartQuotesType$,
        'enableSuggestions': _EditableText_enableSuggestions$,
        'style': _EditableText_style$,
        'undoController': _EditableText_undoController$,
        'textAlign': _EditableText_textAlign$,
        'textDirection': _EditableText_textDirection$,
        'textCapitalization': _EditableText_textCapitalization$,
        'locale': _EditableText_locale$,
        'textScaleFactor': _EditableText_textScaleFactor$,
        'cursorColor': _EditableText_cursorColor$,
        'autocorrectionTextRectColor':
            _EditableText_autocorrectionTextRectColor$,
        'backgroundCursorColor': _EditableText_backgroundCursorColor$,
        'maxLines': _EditableText_maxLines$,
        'minLines': _EditableText_minLines$,
        'expands': _EditableText_expands$,
        'autofocus': _EditableText_autofocus$,
        'selectionColor': _EditableText_selectionColor$,
        'selectionControls': _EditableText_selectionControls$,
        'keyboardType': _EditableText_keyboardType$,
        'textInputAction': _EditableText_textInputAction$,
        'onChanged': _EditableText_onChanged$,
        'onEditingComplete': _EditableText_onEditingComplete$,
        'onSubmitted': _EditableText_onSubmitted$,
        'onAppPrivateCommand': _EditableText_onAppPrivateCommand$,
        'onSelectionChanged': _EditableText_onSelectionChanged$,
        'onSelectionHandleTapped': _EditableText_onSelectionHandleTapped$,
        'onTapOutside': _EditableText_onTapOutside$,
        'inputFormatters': _EditableText_inputFormatters$,
        'mouseCursor': _EditableText_mouseCursor$,
        'rendererIgnoresPointer': _EditableText_rendererIgnoresPointer$,
        'cursorWidth': _EditableText_cursorWidth$,
        'cursorHeight': _EditableText_cursorHeight$,
        'cursorRadius': _EditableText_cursorRadius$,
        'cursorOpacityAnimates': _EditableText_cursorOpacityAnimates$,
        'cursorOffset': _EditableText_cursorOffset$,
        'paintCursorAboveText': _EditableText_paintCursorAboveText$,
        'selectionHeightStyle': _EditableText_selectionHeightStyle$,
        'selectionWidthStyle': _EditableText_selectionWidthStyle$,
        'keyboardAppearance': _EditableText_keyboardAppearance$,
        'scrollPadding': _EditableText_scrollPadding$,
        'enableInteractiveSelection': _EditableText_enableInteractiveSelection$,
        'dragStartBehavior': _EditableText_dragStartBehavior$,
        'scrollController': _EditableText_scrollController$,
        'scrollPhysics': _EditableText_scrollPhysics$,
        'scribbleEnabled': _EditableText_scribbleEnabled$,
        'autofillHints': _EditableText_autofillHints$,
        'autofillClient': _EditableText_autofillClient$,
        'clipBehavior': _EditableText_clipBehavior$,
        'restorationId': _EditableText_restorationId$,
        'scrollBehavior': _EditableText_scrollBehavior$,
        'enableIMEPersonalizedLearning':
            _EditableText_enableIMEPersonalizedLearning$,
        'contentInsertionConfiguration':
            _EditableText_contentInsertionConfiguration$,
        'contextMenuBuilder': _EditableText_contextMenuBuilder$,
        'spellCheckConfiguration': _EditableText_spellCheckConfiguration$,
        'magnifierConfiguration': _EditableText_magnifierConfiguration$,
        'strutStyle': _EditableText_strutStyle$,
        'selectionEnabled': _EditableText_selectionEnabled$,
        'createState': _EditableText_createState$,
        'debugFillProperties': _EditableText_debugFillProperties$,
      },
      {},
    ),
    'EditableTextState': m.ClassMirror(
      'EditableTextState',
      {
        '#as': EditableTextState_as$,
        '#is': EditableTextState_is$,
        'clipboardStatus': _EditableTextState_clipboardStatus$,
        'spellCheckResults': _EditableTextState_spellCheckResults$,
        'renderEditable': _EditableTextState_renderEditable$,
        'currentAutofillScope': _EditableTextState_currentAutofillScope$,
        'spellCheckConfiguration': _EditableTextState_spellCheckConfiguration$,
        'spellCheckEnabled': _EditableTextState_spellCheckEnabled$,
        'wantKeepAlive': _EditableTextState_wantKeepAlive$,
        'cutEnabled': _EditableTextState_cutEnabled$,
        'copyEnabled': _EditableTextState_copyEnabled$,
        'pasteEnabled': _EditableTextState_pasteEnabled$,
        'selectAllEnabled': _EditableTextState_selectAllEnabled$,
        'contextMenuAnchors': _EditableTextState_contextMenuAnchors$,
        'contextMenuButtonItems': _EditableTextState_contextMenuButtonItems$,
        'currentTextEditingValue': _EditableTextState_currentTextEditingValue$,
        'cursorCurrentlyVisible': _EditableTextState_cursorCurrentlyVisible$,
        'cursorBlinkInterval': _EditableTextState_cursorBlinkInterval$,
        'selectionOverlay': _EditableTextState_selectionOverlay$,
        'textEditingValue': _EditableTextState_textEditingValue$,
        'autofillId': _EditableTextState_autofillId$,
        'textInputConfiguration': _EditableTextState_textInputConfiguration$,
        'copySelection': _EditableTextState_copySelection$,
        'cutSelection': _EditableTextState_cutSelection$,
        'pasteText': _EditableTextState_pasteText$,
        'selectAll': _EditableTextState_selectAll$,
        'findSuggestionSpanAtCursorIndex':
            _EditableTextState_findSuggestionSpanAtCursorIndex$,
        'initState': _EditableTextState_initState$,
        'didChangeDependencies': _EditableTextState_didChangeDependencies$,
        'didUpdateWidget': _EditableTextState_didUpdateWidget$,
        'dispose': _EditableTextState_dispose$,
        'updateEditingValue': _EditableTextState_updateEditingValue$,
        'performAction': _EditableTextState_performAction$,
        'performPrivateCommand': _EditableTextState_performPrivateCommand$,
        'insertContent': _EditableTextState_insertContent$,
        'updateFloatingCursor': _EditableTextState_updateFloatingCursor$,
        'beginBatchEdit': _EditableTextState_beginBatchEdit$,
        'endBatchEdit': _EditableTextState_endBatchEdit$,
        'didChangeInputControl': _EditableTextState_didChangeInputControl$,
        'connectionClosed': _EditableTextState_connectionClosed$,
        'requestKeyboard': _EditableTextState_requestKeyboard$,
        'didChangeMetrics': _EditableTextState_didChangeMetrics$,
        'userUpdateTextEditingValue':
            _EditableTextState_userUpdateTextEditingValue$,
        'bringIntoView': _EditableTextState_bringIntoView$,
        'showToolbar': _EditableTextState_showToolbar$,
        'hideToolbar': _EditableTextState_hideToolbar$,
        'toggleToolbar': _EditableTextState_toggleToolbar$,
        'showSpellCheckSuggestionsToolbar':
            _EditableTextState_showSpellCheckSuggestionsToolbar$,
        'showMagnifier': _EditableTextState_showMagnifier$,
        'hideMagnifier': _EditableTextState_hideMagnifier$,
        'insertTextPlaceholder': _EditableTextState_insertTextPlaceholder$,
        'removeTextPlaceholder': _EditableTextState_removeTextPlaceholder$,
        'performSelector': _EditableTextState_performSelector$,
        'autofill': _EditableTextState_autofill$,
        'showAutocorrectionPromptRect':
            _EditableTextState_showAutocorrectionPromptRect$,
        'build': _EditableTextState_build$,
        'buildTextSpan': _EditableTextState_buildTextSpan$,
      },
      {'spellCheckResults': _EditableTextState_spellCheckResults_set$},
    ),
  },
);
List<String> _kDefaultContentInsertionMimeTypes$() {
  return kDefaultContentInsertionMimeTypes;
}

Function TextEditingController_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as TextEditingController;
Function TextEditingController_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is TextEditingController;
String _TextEditingController_text$(TextEditingController target) {
  return target.text;
}

void _TextEditingController_text_set$(
  TextEditingController target,
  String other,
) {
  target.text = other;
}

void _TextEditingController_value_set$(
  TextEditingController target,
  TextEditingValue other,
) {
  target.value = other;
}

TextSelection _TextEditingController_selection$(TextEditingController target) {
  return target.selection;
}

void _TextEditingController_selection_set$(
  TextEditingController target,
  TextSelection other,
) {
  target.selection = other;
}

Function _TextEditingController_buildTextSpan$(
  m.Scope scope,
  TextEditingController target,
) =>
    target.buildTextSpan;
Function _TextEditingController_clear$(
  m.Scope scope,
  TextEditingController target,
) =>
    target.clear;
Function _TextEditingController_clearComposing$(
  m.Scope scope,
  TextEditingController target,
) =>
    target.clearComposing;
Function _TextEditingController_isSelectionWithinTextBounds$(
  m.Scope scope,
  TextEditingController target,
) =>
    target.isSelectionWithinTextBounds;
Function ContentInsertionConfiguration_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ContentInsertionConfiguration;
Function ContentInsertionConfiguration_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ContentInsertionConfiguration;
void Function(KeyboardInsertedContent)
    _ContentInsertionConfiguration_onContentInserted$(
        ContentInsertionConfiguration target) {
  return target.onContentInserted;
}

List<String> _ContentInsertionConfiguration_allowedMimeTypes$(
    ContentInsertionConfiguration target) {
  return target.allowedMimeTypes;
}

Function EditableText_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as EditableText;
Function EditableText_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is EditableText;
TextEditingController _EditableText_controller$(EditableText target) {
  return target.controller;
}

FocusNode _EditableText_focusNode$(EditableText target) {
  return target.focusNode;
}

String _EditableText_obscuringCharacter$(EditableText target) {
  return target.obscuringCharacter;
}

bool _EditableText_obscureText$(EditableText target) {
  return target.obscureText;
}

TextHeightBehavior? _EditableText_textHeightBehavior$(EditableText target) {
  return target.textHeightBehavior;
}

TextWidthBasis _EditableText_textWidthBasis$(EditableText target) {
  return target.textWidthBasis;
}

bool _EditableText_readOnly$(EditableText target) {
  return target.readOnly;
}

bool _EditableText_forceLine$(EditableText target) {
  return target.forceLine;
}

ToolbarOptions _EditableText_toolbarOptions$(EditableText target) {
  return target.toolbarOptions;
}

bool _EditableText_showSelectionHandles$(EditableText target) {
  return target.showSelectionHandles;
}

bool _EditableText_showCursor$(EditableText target) {
  return target.showCursor;
}

bool _EditableText_autocorrect$(EditableText target) {
  return target.autocorrect;
}

SmartDashesType _EditableText_smartDashesType$(EditableText target) {
  return target.smartDashesType;
}

SmartQuotesType _EditableText_smartQuotesType$(EditableText target) {
  return target.smartQuotesType;
}

bool _EditableText_enableSuggestions$(EditableText target) {
  return target.enableSuggestions;
}

TextStyle _EditableText_style$(EditableText target) {
  return target.style;
}

UndoHistoryController? _EditableText_undoController$(EditableText target) {
  return target.undoController;
}

TextAlign _EditableText_textAlign$(EditableText target) {
  return target.textAlign;
}

TextDirection? _EditableText_textDirection$(EditableText target) {
  return target.textDirection;
}

TextCapitalization _EditableText_textCapitalization$(EditableText target) {
  return target.textCapitalization;
}

Locale? _EditableText_locale$(EditableText target) {
  return target.locale;
}

double? _EditableText_textScaleFactor$(EditableText target) {
  return target.textScaleFactor;
}

Color _EditableText_cursorColor$(EditableText target) {
  return target.cursorColor;
}

Color? _EditableText_autocorrectionTextRectColor$(EditableText target) {
  return target.autocorrectionTextRectColor;
}

Color _EditableText_backgroundCursorColor$(EditableText target) {
  return target.backgroundCursorColor;
}

int? _EditableText_maxLines$(EditableText target) {
  return target.maxLines;
}

int? _EditableText_minLines$(EditableText target) {
  return target.minLines;
}

bool _EditableText_expands$(EditableText target) {
  return target.expands;
}

bool _EditableText_autofocus$(EditableText target) {
  return target.autofocus;
}

Color? _EditableText_selectionColor$(EditableText target) {
  return target.selectionColor;
}

TextSelectionControls? _EditableText_selectionControls$(EditableText target) {
  return target.selectionControls;
}

TextInputType _EditableText_keyboardType$(EditableText target) {
  return target.keyboardType;
}

TextInputAction? _EditableText_textInputAction$(EditableText target) {
  return target.textInputAction;
}

void Function(String)? _EditableText_onChanged$(EditableText target) {
  return target.onChanged;
}

void Function()? _EditableText_onEditingComplete$(EditableText target) {
  return target.onEditingComplete;
}

void Function(String)? _EditableText_onSubmitted$(EditableText target) {
  return target.onSubmitted;
}

void Function(String, Map<String, dynamic>)? _EditableText_onAppPrivateCommand$(
    EditableText target) {
  return target.onAppPrivateCommand;
}

void Function(TextSelection, SelectionChangedCause?)?
    _EditableText_onSelectionChanged$(EditableText target) {
  return target.onSelectionChanged;
}

void Function()? _EditableText_onSelectionHandleTapped$(EditableText target) {
  return target.onSelectionHandleTapped;
}

void Function(PointerDownEvent)? _EditableText_onTapOutside$(
    EditableText target) {
  return target.onTapOutside;
}

List<TextInputFormatter>? _EditableText_inputFormatters$(EditableText target) {
  return target.inputFormatters;
}

MouseCursor? _EditableText_mouseCursor$(EditableText target) {
  return target.mouseCursor;
}

bool _EditableText_rendererIgnoresPointer$(EditableText target) {
  return target.rendererIgnoresPointer;
}

double _EditableText_cursorWidth$(EditableText target) {
  return target.cursorWidth;
}

double? _EditableText_cursorHeight$(EditableText target) {
  return target.cursorHeight;
}

Radius? _EditableText_cursorRadius$(EditableText target) {
  return target.cursorRadius;
}

bool _EditableText_cursorOpacityAnimates$(EditableText target) {
  return target.cursorOpacityAnimates;
}

Offset? _EditableText_cursorOffset$(EditableText target) {
  return target.cursorOffset;
}

bool _EditableText_paintCursorAboveText$(EditableText target) {
  return target.paintCursorAboveText;
}

BoxHeightStyle _EditableText_selectionHeightStyle$(EditableText target) {
  return target.selectionHeightStyle;
}

BoxWidthStyle _EditableText_selectionWidthStyle$(EditableText target) {
  return target.selectionWidthStyle;
}

Brightness _EditableText_keyboardAppearance$(EditableText target) {
  return target.keyboardAppearance;
}

EdgeInsets _EditableText_scrollPadding$(EditableText target) {
  return target.scrollPadding;
}

bool _EditableText_enableInteractiveSelection$(EditableText target) {
  return target.enableInteractiveSelection;
}

bool _EditableText_debugDeterministicCursor$() {
  return EditableText.debugDeterministicCursor;
}

void _EditableText_debugDeterministicCursor_set$(bool other) {
  EditableText.debugDeterministicCursor = other;
}

DragStartBehavior _EditableText_dragStartBehavior$(EditableText target) {
  return target.dragStartBehavior;
}

ScrollController? _EditableText_scrollController$(EditableText target) {
  return target.scrollController;
}

ScrollPhysics? _EditableText_scrollPhysics$(EditableText target) {
  return target.scrollPhysics;
}

bool _EditableText_scribbleEnabled$(EditableText target) {
  return target.scribbleEnabled;
}

Iterable<String>? _EditableText_autofillHints$(EditableText target) {
  return target.autofillHints;
}

AutofillClient? _EditableText_autofillClient$(EditableText target) {
  return target.autofillClient;
}

Clip _EditableText_clipBehavior$(EditableText target) {
  return target.clipBehavior;
}

String? _EditableText_restorationId$(EditableText target) {
  return target.restorationId;
}

ScrollBehavior? _EditableText_scrollBehavior$(EditableText target) {
  return target.scrollBehavior;
}

bool _EditableText_enableIMEPersonalizedLearning$(EditableText target) {
  return target.enableIMEPersonalizedLearning;
}

ContentInsertionConfiguration? _EditableText_contentInsertionConfiguration$(
    EditableText target) {
  return target.contentInsertionConfiguration;
}

Widget Function(BuildContext, EditableTextState)?
    _EditableText_contextMenuBuilder$(EditableText target) {
  return target.contextMenuBuilder;
}

SpellCheckConfiguration? _EditableText_spellCheckConfiguration$(
    EditableText target) {
  return target.spellCheckConfiguration;
}

TextMagnifierConfiguration _EditableText_magnifierConfiguration$(
    EditableText target) {
  return target.magnifierConfiguration;
}

StrutStyle _EditableText_strutStyle$(EditableText target) {
  return target.strutStyle;
}

bool _EditableText_selectionEnabled$(EditableText target) {
  return target.selectionEnabled;
}

Function _EditableText_getEditableButtonItems$(m.Scope scope) => ({
      required ClipboardStatus? clipboardStatus,
      required m.FunctionPointer? onCopy,
      required m.FunctionPointer? onCut,
      required m.FunctionPointer? onPaste,
      required m.FunctionPointer? onSelectAll,
    }) {
      void onCopyProxy() => scope.engine.callFunctionPointer(
            scope,
            onCopy!,
            [],
            {},
          );
      void onCutProxy() => scope.engine.callFunctionPointer(
            scope,
            onCut!,
            [],
            {},
          );
      void onPasteProxy() => scope.engine.callFunctionPointer(
            scope,
            onPaste!,
            [],
            {},
          );
      void onSelectAllProxy() => scope.engine.callFunctionPointer(
            scope,
            onSelectAll!,
            [],
            {},
          );
      return EditableText.getEditableButtonItems(
        clipboardStatus: clipboardStatus,
        onCopy: onCopy == null ? null : onCopyProxy,
        onCut: onCut == null ? null : onCutProxy,
        onPaste: onPaste == null ? null : onPasteProxy,
        onSelectAll: onSelectAll == null ? null : onSelectAllProxy,
      );
    };
Function _EditableText_createState$(
  m.Scope scope,
  EditableText target,
) =>
    target.createState;
Function _EditableText_debugFillProperties$(
  m.Scope scope,
  EditableText target,
) =>
    target.debugFillProperties;
Function EditableTextState_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as EditableTextState;
Function EditableTextState_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is EditableTextState;
ClipboardStatusNotifier _EditableTextState_clipboardStatus$(
    EditableTextState target) {
  return target.clipboardStatus;
}

SpellCheckResults? _EditableTextState_spellCheckResults$(
    EditableTextState target) {
  return target.spellCheckResults;
}

void _EditableTextState_spellCheckResults_set$(
  EditableTextState target,
  SpellCheckResults? other,
) {
  target.spellCheckResults = other;
}

RenderEditable _EditableTextState_renderEditable$(EditableTextState target) {
  return target.renderEditable;
}

AutofillScope? _EditableTextState_currentAutofillScope$(
    EditableTextState target) {
  return target.currentAutofillScope;
}

SpellCheckConfiguration _EditableTextState_spellCheckConfiguration$(
    EditableTextState target) {
  return target.spellCheckConfiguration;
}

bool _EditableTextState_spellCheckEnabled$(EditableTextState target) {
  return target.spellCheckEnabled;
}

bool _EditableTextState_wantKeepAlive$(EditableTextState target) {
  return target.wantKeepAlive;
}

bool _EditableTextState_cutEnabled$(EditableTextState target) {
  return target.cutEnabled;
}

bool _EditableTextState_copyEnabled$(EditableTextState target) {
  return target.copyEnabled;
}

bool _EditableTextState_pasteEnabled$(EditableTextState target) {
  return target.pasteEnabled;
}

bool _EditableTextState_selectAllEnabled$(EditableTextState target) {
  return target.selectAllEnabled;
}

TextSelectionToolbarAnchors _EditableTextState_contextMenuAnchors$(
    EditableTextState target) {
  return target.contextMenuAnchors;
}

List<ContextMenuButtonItem> _EditableTextState_contextMenuButtonItems$(
    EditableTextState target) {
  return target.contextMenuButtonItems;
}

TextEditingValue _EditableTextState_currentTextEditingValue$(
    EditableTextState target) {
  return target.currentTextEditingValue;
}

bool _EditableTextState_cursorCurrentlyVisible$(EditableTextState target) {
  return target.cursorCurrentlyVisible;
}

Duration _EditableTextState_cursorBlinkInterval$(EditableTextState target) {
  return target.cursorBlinkInterval;
}

TextSelectionOverlay? _EditableTextState_selectionOverlay$(
    EditableTextState target) {
  return target.selectionOverlay;
}

TextEditingValue _EditableTextState_textEditingValue$(
    EditableTextState target) {
  return target.textEditingValue;
}

String _EditableTextState_autofillId$(EditableTextState target) {
  return target.autofillId;
}

TextInputConfiguration _EditableTextState_textInputConfiguration$(
    EditableTextState target) {
  return target.textInputConfiguration;
}

Function _EditableTextState_copySelection$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.copySelection;
Function _EditableTextState_cutSelection$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.cutSelection;
Function _EditableTextState_pasteText$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.pasteText;
Function _EditableTextState_selectAll$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.selectAll;
Function _EditableTextState_findSuggestionSpanAtCursorIndex$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.findSuggestionSpanAtCursorIndex;
Function _EditableTextState_initState$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.initState;
Function _EditableTextState_didChangeDependencies$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.didChangeDependencies;
Function _EditableTextState_didUpdateWidget$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.didUpdateWidget;
Function _EditableTextState_dispose$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.dispose;
Function _EditableTextState_updateEditingValue$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.updateEditingValue;
Function _EditableTextState_performAction$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.performAction;
Function _EditableTextState_performPrivateCommand$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.performPrivateCommand;
Function _EditableTextState_insertContent$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.insertContent;
Function _EditableTextState_updateFloatingCursor$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.updateFloatingCursor;
Function _EditableTextState_beginBatchEdit$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.beginBatchEdit;
Function _EditableTextState_endBatchEdit$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.endBatchEdit;
Function _EditableTextState_didChangeInputControl$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.didChangeInputControl;
Function _EditableTextState_connectionClosed$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.connectionClosed;
Function _EditableTextState_requestKeyboard$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.requestKeyboard;
Function _EditableTextState_didChangeMetrics$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.didChangeMetrics;
Function _EditableTextState_userUpdateTextEditingValue$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.userUpdateTextEditingValue;
Function _EditableTextState_bringIntoView$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.bringIntoView;
Function _EditableTextState_showToolbar$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.showToolbar;
Function _EditableTextState_hideToolbar$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.hideToolbar;
Function _EditableTextState_toggleToolbar$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.toggleToolbar;
Function _EditableTextState_showSpellCheckSuggestionsToolbar$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.showSpellCheckSuggestionsToolbar;
Function _EditableTextState_showMagnifier$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.showMagnifier;
Function _EditableTextState_hideMagnifier$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.hideMagnifier;
Function _EditableTextState_insertTextPlaceholder$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.insertTextPlaceholder;
Function _EditableTextState_removeTextPlaceholder$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.removeTextPlaceholder;
Function _EditableTextState_performSelector$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.performSelector;
Function _EditableTextState_autofill$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.autofill;
Function _EditableTextState_showAutocorrectionPromptRect$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.showAutocorrectionPromptRect;
Function _EditableTextState_build$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.build;
Function _EditableTextState_buildTextSpan$(
  m.Scope scope,
  EditableTextState target,
) =>
    target.buildTextSpan;
