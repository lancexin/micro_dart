// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/rendering/editable.dart';
import 'dart:collection';
import 'dart:math';
import 'dart:ui'
    show
        BoxHeightStyle,
        BoxWidthStyle,
        LineMetrics,
        PlaceholderAlignment,
        TextBox;
import 'package:characters/characters.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/rendering/object.dart';
import 'package:flutter/src/rendering/paragraph.dart';
import 'package:flutter/src/rendering/viewport_offset.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/rendering/editable.dart',
  {
    'TextSelectionPoint.': _TextSelectionPoint__$,
    'RenderEditable.': _RenderEditable__$,
    'RenderEditable.visitChildren': _RenderEditable_visitChildren$,
  },
  {},
  {
    'TextSelectionPoint': m.ClassMirror(
      'TextSelectionPoint',
      {
        '#as': TextSelectionPoint_as$,
        '#is': TextSelectionPoint_is$,
        'point': _TextSelectionPoint_point$,
        'direction': _TextSelectionPoint_direction$,
        'hashCode': _TextSelectionPoint_hashCode$,
        '==': _TextSelectionPoint_eq$$,
        'toString': _TextSelectionPoint_toString$,
      },
      {},
    ),
    'VerticalCaretMovementRun': m.ClassMirror(
      'VerticalCaretMovementRun',
      {
        '#as': VerticalCaretMovementRun_as$,
        '#is': VerticalCaretMovementRun_is$,
        'isValid': _VerticalCaretMovementRun_isValid$,
        'current': _VerticalCaretMovementRun_current$,
        'moveNext': _VerticalCaretMovementRun_moveNext$,
        'movePrevious': _VerticalCaretMovementRun_movePrevious$,
        'moveByOffset': _VerticalCaretMovementRun_moveByOffset$,
      },
      {},
    ),
    'RenderEditable': m.ClassMirror(
      'RenderEditable',
      {
        '#as': RenderEditable_as$,
        '#is': RenderEditable_is$,
        'onCaretChanged': _RenderEditable_onCaretChanged$,
        'ignorePointer': _RenderEditable_ignorePointer$,
        'textSelectionDelegate': _RenderEditable_textSelectionDelegate$,
        'floatingCursorAddedMargin': _RenderEditable_floatingCursorAddedMargin$,
        'foregroundPainter': _RenderEditable_foregroundPainter$,
        'painter': _RenderEditable_painter$,
        'textHeightBehavior': _RenderEditable_textHeightBehavior$,
        'textWidthBasis': _RenderEditable_textWidthBasis$,
        'devicePixelRatio': _RenderEditable_devicePixelRatio$,
        'obscuringCharacter': _RenderEditable_obscuringCharacter$,
        'obscureText': _RenderEditable_obscureText$,
        'selectionHeightStyle': _RenderEditable_selectionHeightStyle$,
        'selectionWidthStyle': _RenderEditable_selectionWidthStyle$,
        'selectionStartInViewport': _RenderEditable_selectionStartInViewport$,
        'selectionEndInViewport': _RenderEditable_selectionEndInViewport$,
        'plainText': _RenderEditable_plainText$,
        'text': _RenderEditable_text$,
        'textAlign': _RenderEditable_textAlign$,
        'textDirection': _RenderEditable_textDirection$,
        'locale': _RenderEditable_locale$,
        'strutStyle': _RenderEditable_strutStyle$,
        'cursorColor': _RenderEditable_cursorColor$,
        'backgroundCursorColor': _RenderEditable_backgroundCursorColor$,
        'showCursor': _RenderEditable_showCursor$,
        'hasFocus': _RenderEditable_hasFocus$,
        'forceLine': _RenderEditable_forceLine$,
        'readOnly': _RenderEditable_readOnly$,
        'maxLines': _RenderEditable_maxLines$,
        'minLines': _RenderEditable_minLines$,
        'expands': _RenderEditable_expands$,
        'selectionColor': _RenderEditable_selectionColor$,
        'textScaleFactor': _RenderEditable_textScaleFactor$,
        'selection': _RenderEditable_selection$,
        'offset': _RenderEditable_offset$,
        'cursorWidth': _RenderEditable_cursorWidth$,
        'cursorHeight': _RenderEditable_cursorHeight$,
        'paintCursorAboveText': _RenderEditable_paintCursorAboveText$,
        'cursorOffset': _RenderEditable_cursorOffset$,
        'cursorRadius': _RenderEditable_cursorRadius$,
        'startHandleLayerLink': _RenderEditable_startHandleLayerLink$,
        'endHandleLayerLink': _RenderEditable_endHandleLayerLink$,
        'enableInteractiveSelection':
            _RenderEditable_enableInteractiveSelection$,
        'selectionEnabled': _RenderEditable_selectionEnabled$,
        'promptRectColor': _RenderEditable_promptRectColor$,
        'maxScrollExtent': _RenderEditable_maxScrollExtent$,
        'clipBehavior': _RenderEditable_clipBehavior$,
        'preferredLineHeight': _RenderEditable_preferredLineHeight$,
        'lastSecondaryTapDownPosition':
            _RenderEditable_lastSecondaryTapDownPosition$,
        'wordBoundaries': _RenderEditable_wordBoundaries$,
        'setupParentData': _RenderEditable_setupParentData$,
        'dispose': _RenderEditable_dispose$,
        'debugAssertLayoutUpToDate': _RenderEditable_debugAssertLayoutUpToDate$,
        'getLineAtOffset': _RenderEditable_getLineAtOffset$,
        'getWordBoundary': _RenderEditable_getWordBoundary$,
        'getTextPositionAbove': _RenderEditable_getTextPositionAbove$,
        'getTextPositionBelow': _RenderEditable_getTextPositionBelow$,
        'markNeedsPaint': _RenderEditable_markNeedsPaint$,
        'markNeedsTextLayout': _RenderEditable_markNeedsTextLayout$,
        'systemFontsDidChange': _RenderEditable_systemFontsDidChange$,
        'setPromptRectRange': _RenderEditable_setPromptRectRange$,
        'getBoxesForSelection': _RenderEditable_getBoxesForSelection$,
        'describeSemanticsConfiguration':
            _RenderEditable_describeSemanticsConfiguration$,
        'assembleSemanticsNode': _RenderEditable_assembleSemanticsNode$,
        'attach': _RenderEditable_attach$,
        'detach': _RenderEditable_detach$,
        'redepthChildren': _RenderEditable_redepthChildren$,
        'getEndpointsForSelection': _RenderEditable_getEndpointsForSelection$,
        'getRectForComposingRange': _RenderEditable_getRectForComposingRange$,
        'getPositionForPoint': _RenderEditable_getPositionForPoint$,
        'getLocalRectForCaret': _RenderEditable_getLocalRectForCaret$,
        'computeMinIntrinsicWidth': _RenderEditable_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth': _RenderEditable_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight': _RenderEditable_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight': _RenderEditable_computeMaxIntrinsicHeight$,
        'computeDistanceToActualBaseline':
            _RenderEditable_computeDistanceToActualBaseline$,
        'hitTestSelf': _RenderEditable_hitTestSelf$,
        'hitTestChildren': _RenderEditable_hitTestChildren$,
        'handleEvent': _RenderEditable_handleEvent$,
        'handleSecondaryTapDown': _RenderEditable_handleSecondaryTapDown$,
        'handleTapDown': _RenderEditable_handleTapDown$,
        'handleTap': _RenderEditable_handleTap$,
        'handleDoubleTap': _RenderEditable_handleDoubleTap$,
        'handleLongPress': _RenderEditable_handleLongPress$,
        'selectPosition': _RenderEditable_selectPosition$,
        'selectPositionAt': _RenderEditable_selectPositionAt$,
        'selectWord': _RenderEditable_selectWord$,
        'selectWordsInRange': _RenderEditable_selectWordsInRange$,
        'selectWordEdge': _RenderEditable_selectWordEdge$,
        'computeDryLayout': _RenderEditable_computeDryLayout$,
        'performLayout': _RenderEditable_performLayout$,
        'calculateBoundedFloatingCursorOffset':
            _RenderEditable_calculateBoundedFloatingCursorOffset$,
        'setFloatingCursor': _RenderEditable_setFloatingCursor$,
        'startVerticalCaretMovement':
            _RenderEditable_startVerticalCaretMovement$,
        'paint': _RenderEditable_paint$,
        'describeApproximatePaintClip':
            _RenderEditable_describeApproximatePaintClip$,
        'debugFillProperties': _RenderEditable_debugFillProperties$,
        'debugDescribeChildren': _RenderEditable_debugDescribeChildren$,
      },
      {
        'onCaretChanged': _RenderEditable_onCaretChanged_set$,
        'ignorePointer': _RenderEditable_ignorePointer_set$,
        'textSelectionDelegate': _RenderEditable_textSelectionDelegate_set$,
        'floatingCursorAddedMargin':
            _RenderEditable_floatingCursorAddedMargin_set$,
        'foregroundPainter': _RenderEditable_foregroundPainter_set$,
        'painter': _RenderEditable_painter_set$,
        'textHeightBehavior': _RenderEditable_textHeightBehavior_set$,
        'textWidthBasis': _RenderEditable_textWidthBasis_set$,
        'devicePixelRatio': _RenderEditable_devicePixelRatio_set$,
        'obscuringCharacter': _RenderEditable_obscuringCharacter_set$,
        'obscureText': _RenderEditable_obscureText_set$,
        'selectionHeightStyle': _RenderEditable_selectionHeightStyle_set$,
        'selectionWidthStyle': _RenderEditable_selectionWidthStyle_set$,
        'text': _RenderEditable_text_set$,
        'textAlign': _RenderEditable_textAlign_set$,
        'textDirection': _RenderEditable_textDirection_set$,
        'locale': _RenderEditable_locale_set$,
        'strutStyle': _RenderEditable_strutStyle_set$,
        'cursorColor': _RenderEditable_cursorColor_set$,
        'backgroundCursorColor': _RenderEditable_backgroundCursorColor_set$,
        'showCursor': _RenderEditable_showCursor_set$,
        'hasFocus': _RenderEditable_hasFocus_set$,
        'forceLine': _RenderEditable_forceLine_set$,
        'readOnly': _RenderEditable_readOnly_set$,
        'maxLines': _RenderEditable_maxLines_set$,
        'minLines': _RenderEditable_minLines_set$,
        'expands': _RenderEditable_expands_set$,
        'selectionColor': _RenderEditable_selectionColor_set$,
        'textScaleFactor': _RenderEditable_textScaleFactor_set$,
        'selection': _RenderEditable_selection_set$,
        'offset': _RenderEditable_offset_set$,
        'cursorWidth': _RenderEditable_cursorWidth_set$,
        'cursorHeight': _RenderEditable_cursorHeight_set$,
        'paintCursorAboveText': _RenderEditable_paintCursorAboveText_set$,
        'cursorOffset': _RenderEditable_cursorOffset_set$,
        'cursorRadius': _RenderEditable_cursorRadius_set$,
        'startHandleLayerLink': _RenderEditable_startHandleLayerLink_set$,
        'endHandleLayerLink': _RenderEditable_endHandleLayerLink_set$,
        'enableInteractiveSelection':
            _RenderEditable_enableInteractiveSelection_set$,
        'promptRectColor': _RenderEditable_promptRectColor_set$,
        'clipBehavior': _RenderEditable_clipBehavior_set$,
      },
    ),
    'RenderEditablePainter': m.ClassMirror(
      'RenderEditablePainter',
      {
        '#as': RenderEditablePainter_as$,
        '#is': RenderEditablePainter_is$,
        'shouldRepaint': _RenderEditablePainter_shouldRepaint$,
        'paint': _RenderEditablePainter_paint$,
      },
      {},
    ),
  },
);
Function TextSelectionPoint_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSelectionPoint;
Function TextSelectionPoint_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSelectionPoint;
Function _TextSelectionPoint_point$(
  m.Scope scope$,
  TextSelectionPoint target$,
) =>
    () {
      return target$.point;
    };
Function _TextSelectionPoint_direction$(
  m.Scope scope$,
  TextSelectionPoint target$,
) =>
    () {
      return target$.direction;
    };
Function _TextSelectionPoint_hashCode$(
  m.Scope scope$,
  TextSelectionPoint target$,
) =>
    () {
      return target$.hashCode;
    };
Function _TextSelectionPoint__$(m.Scope scope$) => (
      Offset point,
      TextDirection? direction,
    ) {
      return TextSelectionPoint(
        point,
        direction,
      );
    };
Function _TextSelectionPoint_eq$$(
  m.Scope scope$,
  TextSelectionPoint target$,
) =>
    (Object other$) => target$ == other$;
Function _TextSelectionPoint_toString$(
  m.Scope scope$,
  TextSelectionPoint target$,
) =>
    target$.toString;
Function VerticalCaretMovementRun_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as VerticalCaretMovementRun;
Function VerticalCaretMovementRun_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is VerticalCaretMovementRun;
Function _VerticalCaretMovementRun_isValid$(
  m.Scope scope$,
  VerticalCaretMovementRun target$,
) =>
    () {
      return target$.isValid;
    };
Function _VerticalCaretMovementRun_current$(
  m.Scope scope$,
  VerticalCaretMovementRun target$,
) =>
    () {
      return target$.current;
    };
Function _VerticalCaretMovementRun_moveNext$(
  m.Scope scope$,
  VerticalCaretMovementRun target$,
) =>
    target$.moveNext;
Function _VerticalCaretMovementRun_movePrevious$(
  m.Scope scope$,
  VerticalCaretMovementRun target$,
) =>
    target$.movePrevious;
Function _VerticalCaretMovementRun_moveByOffset$(
  m.Scope scope$,
  VerticalCaretMovementRun target$,
) =>
    target$.moveByOffset;
Function RenderEditable_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderEditable;
Function RenderEditable_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderEditable;
Function _RenderEditable_onCaretChanged$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.onCaretChanged;
    };
Function _RenderEditable_onCaretChanged_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (m.FunctionPointer? _onCaretChanged) {
      void _onCaretChangedProxy(Rect _onCaretChanged_caretRect$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onCaretChanged!,
            [_onCaretChanged_caretRect$],
            {},
          );
      target$.onCaretChanged =
          (_onCaretChanged == null ? null : _onCaretChangedProxy);
    };
Function _RenderEditable_ignorePointer$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.ignorePointer;
    };
void _RenderEditable_ignorePointer_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.ignorePointer = other$;
    };
Function _RenderEditable_textSelectionDelegate$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.textSelectionDelegate;
    };
void _RenderEditable_textSelectionDelegate_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.textSelectionDelegate = other$;
    };
Function _RenderEditable_floatingCursorAddedMargin$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.floatingCursorAddedMargin;
    };
void _RenderEditable_floatingCursorAddedMargin_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.floatingCursorAddedMargin = other$;
    };
Function _RenderEditable_foregroundPainter$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.foregroundPainter;
    };
void _RenderEditable_foregroundPainter_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.foregroundPainter = other$;
    };
Function _RenderEditable_painter$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.painter;
    };
void _RenderEditable_painter_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.painter = other$;
    };
Function _RenderEditable_textHeightBehavior$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.textHeightBehavior;
    };
void _RenderEditable_textHeightBehavior_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.textHeightBehavior = other$;
    };
Function _RenderEditable_textWidthBasis$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.textWidthBasis;
    };
void _RenderEditable_textWidthBasis_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.textWidthBasis = other$;
    };
Function _RenderEditable_devicePixelRatio$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.devicePixelRatio;
    };
void _RenderEditable_devicePixelRatio_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.devicePixelRatio = other$;
    };
Function _RenderEditable_obscuringCharacter$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.obscuringCharacter;
    };
void _RenderEditable_obscuringCharacter_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.obscuringCharacter = other$;
    };
Function _RenderEditable_obscureText$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.obscureText;
    };
void _RenderEditable_obscureText_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.obscureText = other$;
    };
Function _RenderEditable_selectionHeightStyle$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selectionHeightStyle;
    };
void _RenderEditable_selectionHeightStyle_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.selectionHeightStyle = other$;
    };
Function _RenderEditable_selectionWidthStyle$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selectionWidthStyle;
    };
void _RenderEditable_selectionWidthStyle_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.selectionWidthStyle = other$;
    };
Function _RenderEditable_selectionStartInViewport$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selectionStartInViewport;
    };
Function _RenderEditable_selectionEndInViewport$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selectionEndInViewport;
    };
Function _RenderEditable_plainText$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.plainText;
    };
Function _RenderEditable_text$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.text;
    };
void _RenderEditable_text_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.text = other$;
    };
Function _RenderEditable_textAlign$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.textAlign;
    };
void _RenderEditable_textAlign_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.textAlign = other$;
    };
Function _RenderEditable_textDirection$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.textDirection;
    };
void _RenderEditable_textDirection_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _RenderEditable_locale$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.locale;
    };
void _RenderEditable_locale_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.locale = other$;
    };
Function _RenderEditable_strutStyle$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.strutStyle;
    };
void _RenderEditable_strutStyle_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.strutStyle = other$;
    };
Function _RenderEditable_cursorColor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.cursorColor;
    };
void _RenderEditable_cursorColor_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.cursorColor = other$;
    };
Function _RenderEditable_backgroundCursorColor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.backgroundCursorColor;
    };
void _RenderEditable_backgroundCursorColor_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.backgroundCursorColor = other$;
    };
Function _RenderEditable_showCursor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.showCursor;
    };
void _RenderEditable_showCursor_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.showCursor = other$;
    };
Function _RenderEditable_hasFocus$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.hasFocus;
    };
void _RenderEditable_hasFocus_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.hasFocus = other$;
    };
Function _RenderEditable_forceLine$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.forceLine;
    };
void _RenderEditable_forceLine_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.forceLine = other$;
    };
Function _RenderEditable_readOnly$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.readOnly;
    };
void _RenderEditable_readOnly_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.readOnly = other$;
    };
Function _RenderEditable_maxLines$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.maxLines;
    };
void _RenderEditable_maxLines_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.maxLines = other$;
    };
Function _RenderEditable_minLines$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.minLines;
    };
void _RenderEditable_minLines_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.minLines = other$;
    };
Function _RenderEditable_expands$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.expands;
    };
void _RenderEditable_expands_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.expands = other$;
    };
Function _RenderEditable_selectionColor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selectionColor;
    };
void _RenderEditable_selectionColor_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.selectionColor = other$;
    };
Function _RenderEditable_textScaleFactor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.textScaleFactor;
    };
void _RenderEditable_textScaleFactor_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.textScaleFactor = other$;
    };
Function _RenderEditable_selection$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selection;
    };
void _RenderEditable_selection_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.selection = other$;
    };
Function _RenderEditable_offset$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.offset;
    };
void _RenderEditable_offset_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.offset = other$;
    };
Function _RenderEditable_cursorWidth$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.cursorWidth;
    };
void _RenderEditable_cursorWidth_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.cursorWidth = other$;
    };
Function _RenderEditable_cursorHeight$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.cursorHeight;
    };
void _RenderEditable_cursorHeight_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.cursorHeight = other$;
    };
Function _RenderEditable_paintCursorAboveText$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.paintCursorAboveText;
    };
void _RenderEditable_paintCursorAboveText_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.paintCursorAboveText = other$;
    };
Function _RenderEditable_cursorOffset$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.cursorOffset;
    };
void _RenderEditable_cursorOffset_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.cursorOffset = other$;
    };
Function _RenderEditable_cursorRadius$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.cursorRadius;
    };
void _RenderEditable_cursorRadius_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.cursorRadius = other$;
    };
Function _RenderEditable_startHandleLayerLink$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.startHandleLayerLink;
    };
void _RenderEditable_startHandleLayerLink_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.startHandleLayerLink = other$;
    };
Function _RenderEditable_endHandleLayerLink$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.endHandleLayerLink;
    };
void _RenderEditable_endHandleLayerLink_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.endHandleLayerLink = other$;
    };
Function _RenderEditable_enableInteractiveSelection$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.enableInteractiveSelection;
    };
void _RenderEditable_enableInteractiveSelection_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.enableInteractiveSelection = other$;
    };
Function _RenderEditable_selectionEnabled$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.selectionEnabled;
    };
Function _RenderEditable_promptRectColor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.promptRectColor;
    };
void _RenderEditable_promptRectColor_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.promptRectColor = other$;
    };
Function _RenderEditable_maxScrollExtent$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.maxScrollExtent;
    };
Function _RenderEditable_clipBehavior$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.clipBehavior;
    };
void _RenderEditable_clipBehavior_set$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (dynamic other$) {
      target$.clipBehavior = other$;
    };
Function _RenderEditable_preferredLineHeight$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.preferredLineHeight;
    };
Function _RenderEditable_lastSecondaryTapDownPosition$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.lastSecondaryTapDownPosition;
    };
Function _RenderEditable_wordBoundaries$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    () {
      return target$.wordBoundaries;
    };
Function _RenderEditable__$(m.Scope scope$) => ({
      InlineSpan? text,
      required TextDirection textDirection,
      TextAlign? textAlign,
      Color? cursorColor,
      Color? backgroundCursorColor,
      ValueNotifier<bool>? showCursor,
      bool? hasFocus,
      required LayerLink startHandleLayerLink,
      required LayerLink endHandleLayerLink,
      int? maxLines,
      int? minLines,
      bool? expands,
      StrutStyle? strutStyle,
      Color? selectionColor,
      double? textScaleFactor,
      TextSelection? selection,
      required ViewportOffset offset,
      m.FunctionPointer? onCaretChanged,
      bool? ignorePointer,
      bool? readOnly,
      bool? forceLine,
      TextHeightBehavior? textHeightBehavior,
      TextWidthBasis? textWidthBasis,
      String? obscuringCharacter,
      bool? obscureText,
      Locale? locale,
      double? cursorWidth,
      double? cursorHeight,
      Radius? cursorRadius,
      bool? paintCursorAboveText,
      Offset? cursorOffset,
      double? devicePixelRatio,
      BoxHeightStyle? selectionHeightStyle,
      BoxWidthStyle? selectionWidthStyle,
      bool? enableInteractiveSelection,
      EdgeInsets? floatingCursorAddedMargin,
      TextRange? promptRectRange,
      Color? promptRectColor,
      Clip? clipBehavior,
      required TextSelectionDelegate textSelectionDelegate,
      RenderEditablePainter? painter,
      RenderEditablePainter? foregroundPainter,
      List? children,
    }) {
      void onCaretChangedProxy(Rect onCaretChanged_caretRect$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onCaretChanged!,
            [onCaretChanged_caretRect$],
            {},
          );
      return RenderEditable(
        backgroundCursorColor: backgroundCursorColor,
        children: children == null ? null : List.from(children),
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        cursorColor: cursorColor,
        cursorHeight: cursorHeight,
        cursorOffset: cursorOffset ?? Offset.zero,
        cursorRadius: cursorRadius,
        cursorWidth: cursorWidth ?? 1.0,
        devicePixelRatio: devicePixelRatio ?? 1.0,
        enableInteractiveSelection: enableInteractiveSelection,
        endHandleLayerLink: endHandleLayerLink,
        expands: expands ?? false,
        floatingCursorAddedMargin:
            floatingCursorAddedMargin ?? const EdgeInsets.fromLTRB(4, 4, 4, 5),
        forceLine: forceLine ?? true,
        foregroundPainter: foregroundPainter,
        hasFocus: hasFocus,
        ignorePointer: ignorePointer ?? false,
        locale: locale,
        maxLines: maxLines ?? 1,
        minLines: minLines,
        obscureText: obscureText ?? false,
        obscuringCharacter: obscuringCharacter ?? '•',
        offset: offset,
        onCaretChanged: onCaretChanged == null ? null : onCaretChangedProxy,
        paintCursorAboveText: paintCursorAboveText ?? false,
        painter: painter,
        promptRectColor: promptRectColor,
        promptRectRange: promptRectRange,
        readOnly: readOnly ?? false,
        selection: selection,
        selectionColor: selectionColor,
        selectionHeightStyle: selectionHeightStyle ?? BoxHeightStyle.tight,
        selectionWidthStyle: selectionWidthStyle ?? BoxWidthStyle.tight,
        showCursor: showCursor,
        startHandleLayerLink: startHandleLayerLink,
        strutStyle: strutStyle,
        text: text,
        textAlign: textAlign ?? TextAlign.start,
        textDirection: textDirection,
        textHeightBehavior: textHeightBehavior,
        textScaleFactor: textScaleFactor ?? 1.0,
        textSelectionDelegate: textSelectionDelegate,
        textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
      );
    };
Function _RenderEditable_setupParentData$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.setupParentData;
Function _RenderEditable_dispose$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.dispose;
Function _RenderEditable_debugAssertLayoutUpToDate$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.debugAssertLayoutUpToDate;
Function _RenderEditable_getLineAtOffset$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getLineAtOffset;
Function _RenderEditable_getWordBoundary$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getWordBoundary;
Function _RenderEditable_getTextPositionAbove$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getTextPositionAbove;
Function _RenderEditable_getTextPositionBelow$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getTextPositionBelow;
Function _RenderEditable_markNeedsPaint$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.markNeedsPaint;
Function _RenderEditable_markNeedsTextLayout$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.markNeedsTextLayout;
Function _RenderEditable_systemFontsDidChange$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.systemFontsDidChange;
Function _RenderEditable_setPromptRectRange$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.setPromptRectRange;
Function _RenderEditable_getBoxesForSelection$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getBoxesForSelection;
Function _RenderEditable_describeSemanticsConfiguration$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.describeSemanticsConfiguration;
Function _RenderEditable_assembleSemanticsNode$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.assembleSemanticsNode;
Function _RenderEditable_attach$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.attach;
Function _RenderEditable_detach$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.detach;
Function _RenderEditable_redepthChildren$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.redepthChildren;
Function _RenderEditable_visitChildren$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildren(visitorProxy);
    };
Function _RenderEditable_getEndpointsForSelection$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getEndpointsForSelection;
Function _RenderEditable_getRectForComposingRange$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getRectForComposingRange;
Function _RenderEditable_getPositionForPoint$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getPositionForPoint;
Function _RenderEditable_getLocalRectForCaret$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.getLocalRectForCaret;
Function _RenderEditable_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderEditable_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderEditable_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderEditable_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderEditable_computeDistanceToActualBaseline$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.computeDistanceToActualBaseline;
Function _RenderEditable_hitTestSelf$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.hitTestSelf;
Function _RenderEditable_hitTestChildren$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.hitTestChildren;
Function _RenderEditable_handleEvent$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.handleEvent;
Function _RenderEditable_handleSecondaryTapDown$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.handleSecondaryTapDown;
Function _RenderEditable_handleTapDown$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.handleTapDown;
Function _RenderEditable_handleTap$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.handleTap;
Function _RenderEditable_handleDoubleTap$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.handleDoubleTap;
Function _RenderEditable_handleLongPress$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.handleLongPress;
Function _RenderEditable_selectPosition$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.selectPosition;
Function _RenderEditable_selectPositionAt$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.selectPositionAt;
Function _RenderEditable_selectWord$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.selectWord;
Function _RenderEditable_selectWordsInRange$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.selectWordsInRange;
Function _RenderEditable_selectWordEdge$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.selectWordEdge;
Function _RenderEditable_computeDryLayout$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.computeDryLayout;
Function _RenderEditable_performLayout$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.performLayout;
Function _RenderEditable_calculateBoundedFloatingCursorOffset$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.calculateBoundedFloatingCursorOffset;
Function _RenderEditable_setFloatingCursor$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.setFloatingCursor;
Function _RenderEditable_startVerticalCaretMovement$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.startVerticalCaretMovement;
Function _RenderEditable_paint$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.paint;
Function _RenderEditable_describeApproximatePaintClip$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.describeApproximatePaintClip;
Function _RenderEditable_debugFillProperties$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.debugFillProperties;
Function _RenderEditable_debugDescribeChildren$(
  m.Scope scope$,
  RenderEditable target$,
) =>
    target$.debugDescribeChildren;
Function RenderEditablePainter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderEditablePainter;
Function RenderEditablePainter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderEditablePainter;
Function _RenderEditablePainter_shouldRepaint$(
  m.Scope scope$,
  RenderEditablePainter target$,
) =>
    target$.shouldRepaint;
Function _RenderEditablePainter_paint$(
  m.Scope scope$,
  RenderEditablePainter target$,
) =>
    target$.paint;
