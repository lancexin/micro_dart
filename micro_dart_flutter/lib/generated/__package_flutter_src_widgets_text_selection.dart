// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/text_selection.dart';
import 'dart:async';
import 'dart:math';
import 'package:characters/characters.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/constants.dart';
import 'package:flutter/src/widgets/container.dart';
import 'package:flutter/src/widgets/context_menu_controller.dart';
import 'package:flutter/src/widgets/debug.dart';
import 'package:flutter/src/widgets/editable_text.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/gesture_detector.dart';
import 'package:flutter/src/widgets/magnifier.dart';
import 'package:flutter/src/widgets/overlay.dart';
import 'package:flutter/src/widgets/scrollable.dart';
import 'package:flutter/src/widgets/tap_and_drag_gestures.dart';
import 'package:flutter/src/widgets/tap_region.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';
import 'package:flutter/src/widgets/transitions.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/text_selection.dart',
  {
    'emptyTextSelectionControls': _emptyTextSelectionControls$,
    'ToolbarItemsParentData.': _ToolbarItemsParentData__$,
    'TextSelectionControls.buildHandle': _TextSelectionControls_buildHandle$,
    'EmptyTextSelectionControls.': _EmptyTextSelectionControls__$,
    'EmptyTextSelectionControls.buildHandle':
        _EmptyTextSelectionControls_buildHandle$,
    'TextSelectionOverlay.fadeDuration': _TextSelectionOverlay_fadeDuration$,
    'TextSelectionOverlay.': _TextSelectionOverlay__$,
    'TextSelectionOverlay.showSpellCheckSuggestionsToolbar':
        _TextSelectionOverlay_showSpellCheckSuggestionsToolbar$,
    'SelectionOverlay.fadeDuration': _SelectionOverlay_fadeDuration$,
    'SelectionOverlay.': _SelectionOverlay__$,
    'SelectionOverlay.showToolbar': _SelectionOverlay_showToolbar$,
    'SelectionOverlay.showSpellCheckSuggestionsToolbar':
        _SelectionOverlay_showSpellCheckSuggestionsToolbar$,
    'TextSelectionGestureDetectorBuilder.':
        _TextSelectionGestureDetectorBuilder__$,
    'TextSelectionGestureDetector.': _TextSelectionGestureDetector__$,
    'ClipboardStatusNotifier.': _ClipboardStatusNotifier__$,
    'ClipboardStatusNotifier.addListener':
        _ClipboardStatusNotifier_addListener$,
    'ClipboardStatusNotifier.removeListener':
        _ClipboardStatusNotifier_removeListener$,
    'ClipboardStatus.pasteable': _ClipboardStatus_pasteable$,
    'ClipboardStatus.unknown': _ClipboardStatus_unknown$,
    'ClipboardStatus.notPasteable': _ClipboardStatus_notPasteable$,
    'ClipboardStatus.values': _ClipboardStatus_values$,
  },
  {},
  {
    'ToolbarItemsParentData': m.ClassMirror(
      'ToolbarItemsParentData',
      {
        '#as': ToolbarItemsParentData_as$,
        '#is': ToolbarItemsParentData_is$,
        'shouldPaint': _ToolbarItemsParentData_shouldPaint$,
        'toString': _ToolbarItemsParentData_toString$,
      },
      {'shouldPaint': _ToolbarItemsParentData_shouldPaint_set$},
    ),
    'TextSelectionControls': m.ClassMirror(
      'TextSelectionControls',
      {
        '#as': TextSelectionControls_as$,
        '#is': TextSelectionControls_is$,
        'getHandleAnchor': _TextSelectionControls_getHandleAnchor$,
        'getHandleSize': _TextSelectionControls_getHandleSize$,
      },
      {},
    ),
    'EmptyTextSelectionControls': m.ClassMirror(
      'EmptyTextSelectionControls',
      {
        '#as': EmptyTextSelectionControls_as$,
        '#is': EmptyTextSelectionControls_is$,
        'getHandleSize': _EmptyTextSelectionControls_getHandleSize$,
        'buildToolbar': _EmptyTextSelectionControls_buildToolbar$,
        'getHandleAnchor': _EmptyTextSelectionControls_getHandleAnchor$,
      },
      {},
    ),
    'TextSelectionOverlay': m.ClassMirror(
      'TextSelectionOverlay',
      {
        '#as': TextSelectionOverlay_as$,
        '#is': TextSelectionOverlay_is$,
        'context': _TextSelectionOverlay_context$,
        'renderObject': _TextSelectionOverlay_renderObject$,
        'selectionControls': _TextSelectionOverlay_selectionControls$,
        'selectionDelegate': _TextSelectionOverlay_selectionDelegate$,
        'contextMenuBuilder': _TextSelectionOverlay_contextMenuBuilder$,
        'value': _TextSelectionOverlay_value$,
        'handlesVisible': _TextSelectionOverlay_handlesVisible$,
        'handlesAreVisible': _TextSelectionOverlay_handlesAreVisible$,
        'toolbarIsVisible': _TextSelectionOverlay_toolbarIsVisible$,
        'magnifierIsVisible': _TextSelectionOverlay_magnifierIsVisible$,
        'spellCheckToolbarIsVisible':
            _TextSelectionOverlay_spellCheckToolbarIsVisible$,
        'showHandles': _TextSelectionOverlay_showHandles$,
        'hideHandles': _TextSelectionOverlay_hideHandles$,
        'showToolbar': _TextSelectionOverlay_showToolbar$,
        'showMagnifier': _TextSelectionOverlay_showMagnifier$,
        'updateMagnifier': _TextSelectionOverlay_updateMagnifier$,
        'hideMagnifier': _TextSelectionOverlay_hideMagnifier$,
        'update': _TextSelectionOverlay_update$,
        'updateForScroll': _TextSelectionOverlay_updateForScroll$,
        'hide': _TextSelectionOverlay_hide$,
        'hideToolbar': _TextSelectionOverlay_hideToolbar$,
        'dispose': _TextSelectionOverlay_dispose$,
      },
      {'handlesVisible': _TextSelectionOverlay_handlesVisible_set$},
    ),
    'SelectionOverlay': m.ClassMirror(
      'SelectionOverlay',
      {
        '#as': SelectionOverlay_as$,
        '#is': SelectionOverlay_is$,
        'context': _SelectionOverlay_context$,
        'magnifierConfiguration': _SelectionOverlay_magnifierConfiguration$,
        'startHandlesVisible': _SelectionOverlay_startHandlesVisible$,
        'onStartHandleDragStart': _SelectionOverlay_onStartHandleDragStart$,
        'onStartHandleDragUpdate': _SelectionOverlay_onStartHandleDragUpdate$,
        'onStartHandleDragEnd': _SelectionOverlay_onStartHandleDragEnd$,
        'endHandlesVisible': _SelectionOverlay_endHandlesVisible$,
        'onEndHandleDragStart': _SelectionOverlay_onEndHandleDragStart$,
        'onEndHandleDragUpdate': _SelectionOverlay_onEndHandleDragUpdate$,
        'onEndHandleDragEnd': _SelectionOverlay_onEndHandleDragEnd$,
        'toolbarVisible': _SelectionOverlay_toolbarVisible$,
        'debugRequiredFor': _SelectionOverlay_debugRequiredFor$,
        'toolbarLayerLink': _SelectionOverlay_toolbarLayerLink$,
        'startHandleLayerLink': _SelectionOverlay_startHandleLayerLink$,
        'endHandleLayerLink': _SelectionOverlay_endHandleLayerLink$,
        'selectionControls': _SelectionOverlay_selectionControls$,
        'selectionDelegate': _SelectionOverlay_selectionDelegate$,
        'dragStartBehavior': _SelectionOverlay_dragStartBehavior$,
        'onSelectionHandleTapped': _SelectionOverlay_onSelectionHandleTapped$,
        'clipboardStatus': _SelectionOverlay_clipboardStatus$,
        'startHandleType': _SelectionOverlay_startHandleType$,
        'lineHeightAtStart': _SelectionOverlay_lineHeightAtStart$,
        'endHandleType': _SelectionOverlay_endHandleType$,
        'lineHeightAtEnd': _SelectionOverlay_lineHeightAtEnd$,
        'selectionEndpoints': _SelectionOverlay_selectionEndpoints$,
        'showMagnifier': _SelectionOverlay_showMagnifier$,
        'hideMagnifier': _SelectionOverlay_hideMagnifier$,
        'showHandles': _SelectionOverlay_showHandles$,
        'hideHandles': _SelectionOverlay_hideHandles$,
        'markNeedsBuild': _SelectionOverlay_markNeedsBuild$,
        'hide': _SelectionOverlay_hide$,
        'hideToolbar': _SelectionOverlay_hideToolbar$,
        'dispose': _SelectionOverlay_dispose$,
        'updateMagnifier': _SelectionOverlay_updateMagnifier$,
      },
      {
        'startHandleType': _SelectionOverlay_startHandleType_set$,
        'lineHeightAtStart': _SelectionOverlay_lineHeightAtStart_set$,
        'endHandleType': _SelectionOverlay_endHandleType_set$,
        'lineHeightAtEnd': _SelectionOverlay_lineHeightAtEnd_set$,
        'selectionEndpoints': _SelectionOverlay_selectionEndpoints_set$,
        'toolbarLocation': _SelectionOverlay_toolbarLocation_set$,
      },
    ),
    'TextSelectionGestureDetectorBuilderDelegate': m.ClassMirror(
      'TextSelectionGestureDetectorBuilderDelegate',
      {
        '#as': TextSelectionGestureDetectorBuilderDelegate_as$,
        '#is': TextSelectionGestureDetectorBuilderDelegate_is$,
        'editableTextKey':
            _TextSelectionGestureDetectorBuilderDelegate_editableTextKey$,
        'forcePressEnabled':
            _TextSelectionGestureDetectorBuilderDelegate_forcePressEnabled$,
        'selectionEnabled':
            _TextSelectionGestureDetectorBuilderDelegate_selectionEnabled$,
      },
      {},
    ),
    'TextSelectionGestureDetectorBuilder': m.ClassMirror(
      'TextSelectionGestureDetectorBuilder',
      {
        '#as': TextSelectionGestureDetectorBuilder_as$,
        '#is': TextSelectionGestureDetectorBuilder_is$,
        'delegate': _TextSelectionGestureDetectorBuilder_delegate$,
        'shouldShowSelectionToolbar':
            _TextSelectionGestureDetectorBuilder_shouldShowSelectionToolbar$,
        'editableText': _TextSelectionGestureDetectorBuilder_editableText$,
        'renderEditable': _TextSelectionGestureDetectorBuilder_renderEditable$,
        'onTapDown': _TextSelectionGestureDetectorBuilder_onTapDown$,
        'onForcePressStart':
            _TextSelectionGestureDetectorBuilder_onForcePressStart$,
        'onForcePressEnd':
            _TextSelectionGestureDetectorBuilder_onForcePressEnd$,
        'onSingleTapUp': _TextSelectionGestureDetectorBuilder_onSingleTapUp$,
        'onSingleTapCancel':
            _TextSelectionGestureDetectorBuilder_onSingleTapCancel$,
        'onSingleLongTapStart':
            _TextSelectionGestureDetectorBuilder_onSingleLongTapStart$,
        'onSingleLongTapMoveUpdate':
            _TextSelectionGestureDetectorBuilder_onSingleLongTapMoveUpdate$,
        'onSingleLongTapEnd':
            _TextSelectionGestureDetectorBuilder_onSingleLongTapEnd$,
        'onSecondaryTap': _TextSelectionGestureDetectorBuilder_onSecondaryTap$,
        'onSecondaryTapDown':
            _TextSelectionGestureDetectorBuilder_onSecondaryTapDown$,
        'onDoubleTapDown':
            _TextSelectionGestureDetectorBuilder_onDoubleTapDown$,
        'onTripleTapDown':
            _TextSelectionGestureDetectorBuilder_onTripleTapDown$,
        'onDragSelectionStart':
            _TextSelectionGestureDetectorBuilder_onDragSelectionStart$,
        'onDragSelectionUpdate':
            _TextSelectionGestureDetectorBuilder_onDragSelectionUpdate$,
        'onDragSelectionEnd':
            _TextSelectionGestureDetectorBuilder_onDragSelectionEnd$,
        'buildGestureDetector':
            _TextSelectionGestureDetectorBuilder_buildGestureDetector$,
      },
      {},
    ),
    'TextSelectionGestureDetector': m.ClassMirror(
      'TextSelectionGestureDetector',
      {
        '#as': TextSelectionGestureDetector_as$,
        '#is': TextSelectionGestureDetector_is$,
        'onTapDown': _TextSelectionGestureDetector_onTapDown$,
        'onForcePressStart': _TextSelectionGestureDetector_onForcePressStart$,
        'onForcePressEnd': _TextSelectionGestureDetector_onForcePressEnd$,
        'onSecondaryTap': _TextSelectionGestureDetector_onSecondaryTap$,
        'onSecondaryTapDown': _TextSelectionGestureDetector_onSecondaryTapDown$,
        'onSingleTapUp': _TextSelectionGestureDetector_onSingleTapUp$,
        'onSingleTapCancel': _TextSelectionGestureDetector_onSingleTapCancel$,
        'onSingleLongTapStart':
            _TextSelectionGestureDetector_onSingleLongTapStart$,
        'onSingleLongTapMoveUpdate':
            _TextSelectionGestureDetector_onSingleLongTapMoveUpdate$,
        'onSingleLongTapEnd': _TextSelectionGestureDetector_onSingleLongTapEnd$,
        'onDoubleTapDown': _TextSelectionGestureDetector_onDoubleTapDown$,
        'onTripleTapDown': _TextSelectionGestureDetector_onTripleTapDown$,
        'onDragSelectionStart':
            _TextSelectionGestureDetector_onDragSelectionStart$,
        'onDragSelectionUpdate':
            _TextSelectionGestureDetector_onDragSelectionUpdate$,
        'onDragSelectionEnd': _TextSelectionGestureDetector_onDragSelectionEnd$,
        'behavior': _TextSelectionGestureDetector_behavior$,
        'child': _TextSelectionGestureDetector_child$,
        'createState': _TextSelectionGestureDetector_createState$,
      },
      {},
    ),
    'ClipboardStatusNotifier': m.ClassMirror(
      'ClipboardStatusNotifier',
      {
        '#as': ClipboardStatusNotifier_as$,
        '#is': ClipboardStatusNotifier_is$,
        'disposed': _ClipboardStatusNotifier_disposed$,
        'update': _ClipboardStatusNotifier_update$,
        'didChangeAppLifecycleState':
            _ClipboardStatusNotifier_didChangeAppLifecycleState$,
        'dispose': _ClipboardStatusNotifier_dispose$,
      },
      {},
    ),
    'ClipboardStatus': m.ClassMirror(
      'ClipboardStatus',
      {},
      {},
    ),
  },
);
TextSelectionControls _emptyTextSelectionControls$() {
  return emptyTextSelectionControls;
}

Function ToolbarItemsParentData_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ToolbarItemsParentData;
Function ToolbarItemsParentData_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ToolbarItemsParentData;
Function _ToolbarItemsParentData_shouldPaint$(
  m.Scope scope$,
  ToolbarItemsParentData target$,
) =>
    () {
      return target$.shouldPaint;
    };
void _ToolbarItemsParentData_shouldPaint_set$(
  m.Scope scope$,
  ToolbarItemsParentData target$,
) =>
    (dynamic other$) {
      target$.shouldPaint = other$;
    };
Function _ToolbarItemsParentData__$(m.Scope scope$) => () {
      return ToolbarItemsParentData();
    };
Function _ToolbarItemsParentData_toString$(
  m.Scope scope$,
  ToolbarItemsParentData target$,
) =>
    target$.toString;
Function TextSelectionControls_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSelectionControls;
Function TextSelectionControls_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSelectionControls;
Function _TextSelectionControls_buildHandle$(
  m.Scope scope$,
  TextSelectionControls target$,
) =>
    (
      BuildContext context,
      TextSelectionHandleType type,
      double textLineHeight, [
      m.FunctionPointer? onTap,
    ]) {
      if (onTap == null) {
        return target$.buildHandle(
          context,
          type,
          textLineHeight,
        );
      }
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      return target$.buildHandle(
        context,
        type,
        textLineHeight,
        onTap == null ? null : onTapProxy,
      );
    };
Function _TextSelectionControls_getHandleAnchor$(
  m.Scope scope$,
  TextSelectionControls target$,
) =>
    target$.getHandleAnchor;
Function _TextSelectionControls_getHandleSize$(
  m.Scope scope$,
  TextSelectionControls target$,
) =>
    target$.getHandleSize;
Function EmptyTextSelectionControls_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as EmptyTextSelectionControls;
Function EmptyTextSelectionControls_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is EmptyTextSelectionControls;
Function _EmptyTextSelectionControls__$(m.Scope scope$) => () {
      return EmptyTextSelectionControls();
    };
Function _EmptyTextSelectionControls_getHandleSize$(
  m.Scope scope$,
  EmptyTextSelectionControls target$,
) =>
    target$.getHandleSize;
Function _EmptyTextSelectionControls_buildToolbar$(
  m.Scope scope$,
  EmptyTextSelectionControls target$,
) =>
    target$.buildToolbar;
Function _EmptyTextSelectionControls_buildHandle$(
  m.Scope scope$,
  EmptyTextSelectionControls target$,
) =>
    (
      BuildContext context,
      TextSelectionHandleType type,
      double textLineHeight, [
      m.FunctionPointer? onTap,
    ]) {
      if (onTap == null) {
        return target$.buildHandle(
          context,
          type,
          textLineHeight,
        );
      }
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      return target$.buildHandle(
        context,
        type,
        textLineHeight,
        onTap == null ? null : onTapProxy,
      );
    };
Function _EmptyTextSelectionControls_getHandleAnchor$(
  m.Scope scope$,
  EmptyTextSelectionControls target$,
) =>
    target$.getHandleAnchor;
Function TextSelectionOverlay_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSelectionOverlay;
Function TextSelectionOverlay_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSelectionOverlay;
Function _TextSelectionOverlay_context$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.context;
    };
Duration _TextSelectionOverlay_fadeDuration$() {
  return TextSelectionOverlay.fadeDuration;
}

Function _TextSelectionOverlay_renderObject$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.renderObject;
    };
Function _TextSelectionOverlay_selectionControls$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.selectionControls;
    };
Function _TextSelectionOverlay_selectionDelegate$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.selectionDelegate;
    };
Function _TextSelectionOverlay_contextMenuBuilder$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.contextMenuBuilder;
    };
Function _TextSelectionOverlay_value$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.value;
    };
Function _TextSelectionOverlay_handlesVisible$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.handlesVisible;
    };
void _TextSelectionOverlay_handlesVisible_set$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.handlesVisible = other$;
    };
Function _TextSelectionOverlay_handlesAreVisible$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.handlesAreVisible;
    };
Function _TextSelectionOverlay_toolbarIsVisible$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.toolbarIsVisible;
    };
Function _TextSelectionOverlay_magnifierIsVisible$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.magnifierIsVisible;
    };
Function _TextSelectionOverlay_spellCheckToolbarIsVisible$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    () {
      return target$.spellCheckToolbarIsVisible;
    };
Function _TextSelectionOverlay__$(m.Scope scope$) => ({
      required TextEditingValue value,
      required BuildContext context,
      Widget? debugRequiredFor,
      required LayerLink toolbarLayerLink,
      required LayerLink startHandleLayerLink,
      required LayerLink endHandleLayerLink,
      required RenderEditable renderObject,
      TextSelectionControls? selectionControls,
      bool? handlesVisible,
      required TextSelectionDelegate selectionDelegate,
      DragStartBehavior? dragStartBehavior,
      m.FunctionPointer? onSelectionHandleTapped,
      ClipboardStatusNotifier? clipboardStatus,
      m.FunctionPointer? contextMenuBuilder,
      required TextMagnifierConfiguration magnifierConfiguration,
    }) {
      Widget contextMenuBuilderProxy(
              BuildContext contextMenuBuilder_context$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            contextMenuBuilder!,
            [contextMenuBuilder_context$],
            {},
          );
      void onSelectionHandleTappedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onSelectionHandleTapped!,
            [],
            {},
          );
      return TextSelectionOverlay(
        clipboardStatus: clipboardStatus,
        context: context,
        contextMenuBuilder:
            contextMenuBuilder == null ? null : contextMenuBuilderProxy,
        debugRequiredFor: debugRequiredFor,
        dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
        endHandleLayerLink: endHandleLayerLink,
        handlesVisible: handlesVisible ?? false,
        magnifierConfiguration: magnifierConfiguration,
        onSelectionHandleTapped: onSelectionHandleTapped == null
            ? null
            : onSelectionHandleTappedProxy,
        renderObject: renderObject,
        selectionControls: selectionControls,
        selectionDelegate: selectionDelegate,
        startHandleLayerLink: startHandleLayerLink,
        toolbarLayerLink: toolbarLayerLink,
        value: value,
      );
    };
Function _TextSelectionOverlay_showHandles$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.showHandles;
Function _TextSelectionOverlay_hideHandles$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.hideHandles;
Function _TextSelectionOverlay_showToolbar$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.showToolbar;
Function _TextSelectionOverlay_showSpellCheckSuggestionsToolbar$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    (m.FunctionPointer spellCheckSuggestionsToolbarBuilder) {
      Widget spellCheckSuggestionsToolbarBuilderProxy(
              BuildContext spellCheckSuggestionsToolbarBuilder_context$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            spellCheckSuggestionsToolbarBuilder,
            [spellCheckSuggestionsToolbarBuilder_context$],
            {},
          );
      target$.showSpellCheckSuggestionsToolbar(
          spellCheckSuggestionsToolbarBuilderProxy);
    };
Function _TextSelectionOverlay_showMagnifier$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.showMagnifier;
Function _TextSelectionOverlay_updateMagnifier$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.updateMagnifier;
Function _TextSelectionOverlay_hideMagnifier$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.hideMagnifier;
Function _TextSelectionOverlay_update$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.update;
Function _TextSelectionOverlay_updateForScroll$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.updateForScroll;
Function _TextSelectionOverlay_hide$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.hide;
Function _TextSelectionOverlay_hideToolbar$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.hideToolbar;
Function _TextSelectionOverlay_dispose$(
  m.Scope scope$,
  TextSelectionOverlay target$,
) =>
    target$.dispose;
Function SelectionOverlay_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SelectionOverlay;
Function SelectionOverlay_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SelectionOverlay;
Function _SelectionOverlay_context$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.context;
    };
Function _SelectionOverlay_magnifierConfiguration$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.magnifierConfiguration;
    };
Function _SelectionOverlay_startHandlesVisible$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.startHandlesVisible;
    };
Function _SelectionOverlay_onStartHandleDragStart$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onStartHandleDragStart;
    };
Function _SelectionOverlay_onStartHandleDragUpdate$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onStartHandleDragUpdate;
    };
Function _SelectionOverlay_onStartHandleDragEnd$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onStartHandleDragEnd;
    };
Function _SelectionOverlay_endHandlesVisible$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.endHandlesVisible;
    };
Function _SelectionOverlay_onEndHandleDragStart$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onEndHandleDragStart;
    };
Function _SelectionOverlay_onEndHandleDragUpdate$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onEndHandleDragUpdate;
    };
Function _SelectionOverlay_onEndHandleDragEnd$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onEndHandleDragEnd;
    };
Function _SelectionOverlay_toolbarVisible$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.toolbarVisible;
    };
Function _SelectionOverlay_debugRequiredFor$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.debugRequiredFor;
    };
Function _SelectionOverlay_toolbarLayerLink$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.toolbarLayerLink;
    };
Function _SelectionOverlay_startHandleLayerLink$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.startHandleLayerLink;
    };
Function _SelectionOverlay_endHandleLayerLink$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.endHandleLayerLink;
    };
Function _SelectionOverlay_selectionControls$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.selectionControls;
    };
Function _SelectionOverlay_selectionDelegate$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.selectionDelegate;
    };
Function _SelectionOverlay_dragStartBehavior$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.dragStartBehavior;
    };
Function _SelectionOverlay_onSelectionHandleTapped$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.onSelectionHandleTapped;
    };
Function _SelectionOverlay_clipboardStatus$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.clipboardStatus;
    };
Duration _SelectionOverlay_fadeDuration$() {
  return SelectionOverlay.fadeDuration;
}

Function _SelectionOverlay_startHandleType$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.startHandleType;
    };
void _SelectionOverlay_startHandleType_set$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.startHandleType = other$;
    };
Function _SelectionOverlay_lineHeightAtStart$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.lineHeightAtStart;
    };
void _SelectionOverlay_lineHeightAtStart_set$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.lineHeightAtStart = other$;
    };
Function _SelectionOverlay_endHandleType$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.endHandleType;
    };
void _SelectionOverlay_endHandleType_set$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.endHandleType = other$;
    };
Function _SelectionOverlay_lineHeightAtEnd$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.lineHeightAtEnd;
    };
void _SelectionOverlay_lineHeightAtEnd_set$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.lineHeightAtEnd = other$;
    };
Function _SelectionOverlay_selectionEndpoints$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    () {
      return target$.selectionEndpoints;
    };
void _SelectionOverlay_selectionEndpoints_set$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.selectionEndpoints = other$;
    };
void _SelectionOverlay_toolbarLocation_set$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    (dynamic other$) {
      target$.toolbarLocation = other$;
    };
Function _SelectionOverlay__$(m.Scope scope$) => ({
      required BuildContext context,
      Widget? debugRequiredFor,
      required TextSelectionHandleType startHandleType,
      required double lineHeightAtStart,
      ValueListenable<bool>? startHandlesVisible,
      m.FunctionPointer? onStartHandleDragStart,
      m.FunctionPointer? onStartHandleDragUpdate,
      m.FunctionPointer? onStartHandleDragEnd,
      required TextSelectionHandleType endHandleType,
      required double lineHeightAtEnd,
      ValueListenable<bool>? endHandlesVisible,
      m.FunctionPointer? onEndHandleDragStart,
      m.FunctionPointer? onEndHandleDragUpdate,
      m.FunctionPointer? onEndHandleDragEnd,
      ValueListenable<bool>? toolbarVisible,
      required List selectionEndpoints,
      required TextSelectionControls? selectionControls,
      required TextSelectionDelegate? selectionDelegate,
      required ClipboardStatusNotifier? clipboardStatus,
      required LayerLink startHandleLayerLink,
      required LayerLink endHandleLayerLink,
      required LayerLink toolbarLayerLink,
      DragStartBehavior? dragStartBehavior,
      m.FunctionPointer? onSelectionHandleTapped,
      Offset? toolbarLocation,
      TextMagnifierConfiguration? magnifierConfiguration,
    }) {
      void onEndHandleDragEndProxy(DragEndDetails onEndHandleDragEnd_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEndHandleDragEnd!,
            [onEndHandleDragEnd_value$],
            {},
          );
      void onEndHandleDragStartProxy(
              DragStartDetails onEndHandleDragStart_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEndHandleDragStart!,
            [onEndHandleDragStart_value$],
            {},
          );
      void onEndHandleDragUpdateProxy(
              DragUpdateDetails onEndHandleDragUpdate_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEndHandleDragUpdate!,
            [onEndHandleDragUpdate_value$],
            {},
          );
      void onSelectionHandleTappedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onSelectionHandleTapped!,
            [],
            {},
          );
      void onStartHandleDragEndProxy(
              DragEndDetails onStartHandleDragEnd_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onStartHandleDragEnd!,
            [onStartHandleDragEnd_value$],
            {},
          );
      void onStartHandleDragStartProxy(
              DragStartDetails onStartHandleDragStart_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onStartHandleDragStart!,
            [onStartHandleDragStart_value$],
            {},
          );
      void onStartHandleDragUpdateProxy(
              DragUpdateDetails onStartHandleDragUpdate_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onStartHandleDragUpdate!,
            [onStartHandleDragUpdate_value$],
            {},
          );
      return SelectionOverlay(
        clipboardStatus: clipboardStatus,
        context: context,
        debugRequiredFor: debugRequiredFor,
        dragStartBehavior: dragStartBehavior ?? DragStartBehavior.start,
        endHandleLayerLink: endHandleLayerLink,
        endHandleType: endHandleType,
        endHandlesVisible: endHandlesVisible,
        lineHeightAtEnd: lineHeightAtEnd,
        lineHeightAtStart: lineHeightAtStart,
        magnifierConfiguration:
            magnifierConfiguration ?? TextMagnifierConfiguration.disabled,
        onEndHandleDragEnd:
            onEndHandleDragEnd == null ? null : onEndHandleDragEndProxy,
        onEndHandleDragStart:
            onEndHandleDragStart == null ? null : onEndHandleDragStartProxy,
        onEndHandleDragUpdate:
            onEndHandleDragUpdate == null ? null : onEndHandleDragUpdateProxy,
        onSelectionHandleTapped: onSelectionHandleTapped == null
            ? null
            : onSelectionHandleTappedProxy,
        onStartHandleDragEnd:
            onStartHandleDragEnd == null ? null : onStartHandleDragEndProxy,
        onStartHandleDragStart:
            onStartHandleDragStart == null ? null : onStartHandleDragStartProxy,
        onStartHandleDragUpdate: onStartHandleDragUpdate == null
            ? null
            : onStartHandleDragUpdateProxy,
        selectionControls: selectionControls,
        selectionDelegate: selectionDelegate,
        selectionEndpoints: List.from(selectionEndpoints),
        startHandleLayerLink: startHandleLayerLink,
        startHandleType: startHandleType,
        startHandlesVisible: startHandlesVisible,
        toolbarLayerLink: toolbarLayerLink,
        toolbarLocation: toolbarLocation,
        toolbarVisible: toolbarVisible,
      );
    };
Function _SelectionOverlay_showMagnifier$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.showMagnifier;
Function _SelectionOverlay_hideMagnifier$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.hideMagnifier;
Function _SelectionOverlay_showHandles$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.showHandles;
Function _SelectionOverlay_hideHandles$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.hideHandles;
Function _SelectionOverlay_showToolbar$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    ({
      BuildContext? context,
      m.FunctionPointer? contextMenuBuilder,
    }) {
      Widget contextMenuBuilderProxy(
              BuildContext contextMenuBuilder_context$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            contextMenuBuilder!,
            [contextMenuBuilder_context$],
            {},
          );
      target$.showToolbar(
        context: context,
        contextMenuBuilder:
            contextMenuBuilder == null ? null : contextMenuBuilderProxy,
      );
    };
Function _SelectionOverlay_showSpellCheckSuggestionsToolbar$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    ({
      BuildContext? context,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(BuildContext builder_context$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [builder_context$],
            {},
          );
      target$.showSpellCheckSuggestionsToolbar(
        builder: builderProxy,
        context: context,
      );
    };
Function _SelectionOverlay_markNeedsBuild$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.markNeedsBuild;
Function _SelectionOverlay_hide$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.hide;
Function _SelectionOverlay_hideToolbar$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.hideToolbar;
Function _SelectionOverlay_dispose$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.dispose;
Function _SelectionOverlay_updateMagnifier$(
  m.Scope scope$,
  SelectionOverlay target$,
) =>
    target$.updateMagnifier;
Function TextSelectionGestureDetectorBuilderDelegate_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSelectionGestureDetectorBuilderDelegate;
Function TextSelectionGestureDetectorBuilderDelegate_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSelectionGestureDetectorBuilderDelegate;
Function _TextSelectionGestureDetectorBuilderDelegate_editableTextKey$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilderDelegate target$,
) =>
    () {
      return target$.editableTextKey;
    };
Function _TextSelectionGestureDetectorBuilderDelegate_forcePressEnabled$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilderDelegate target$,
) =>
    () {
      return target$.forcePressEnabled;
    };
Function _TextSelectionGestureDetectorBuilderDelegate_selectionEnabled$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilderDelegate target$,
) =>
    () {
      return target$.selectionEnabled;
    };
Function TextSelectionGestureDetectorBuilder_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSelectionGestureDetectorBuilder;
Function TextSelectionGestureDetectorBuilder_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSelectionGestureDetectorBuilder;
Function _TextSelectionGestureDetectorBuilder_delegate$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    () {
      return target$.delegate;
    };
Function _TextSelectionGestureDetectorBuilder_shouldShowSelectionToolbar$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    () {
      return target$.shouldShowSelectionToolbar;
    };
Function _TextSelectionGestureDetectorBuilder_editableText$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    () {
      return target$.editableText;
    };
Function _TextSelectionGestureDetectorBuilder_renderEditable$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    () {
      return target$.renderEditable;
    };
Function _TextSelectionGestureDetectorBuilder__$(m.Scope scope$) =>
    ({required TextSelectionGestureDetectorBuilderDelegate delegate}) {
      return TextSelectionGestureDetectorBuilder(delegate: delegate);
    };
Function _TextSelectionGestureDetectorBuilder_onTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onTapDown;
Function _TextSelectionGestureDetectorBuilder_onForcePressStart$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onForcePressStart;
Function _TextSelectionGestureDetectorBuilder_onForcePressEnd$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onForcePressEnd;
Function _TextSelectionGestureDetectorBuilder_onSingleTapUp$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSingleTapUp;
Function _TextSelectionGestureDetectorBuilder_onSingleTapCancel$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSingleTapCancel;
Function _TextSelectionGestureDetectorBuilder_onSingleLongTapStart$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSingleLongTapStart;
Function _TextSelectionGestureDetectorBuilder_onSingleLongTapMoveUpdate$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSingleLongTapMoveUpdate;
Function _TextSelectionGestureDetectorBuilder_onSingleLongTapEnd$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSingleLongTapEnd;
Function _TextSelectionGestureDetectorBuilder_onSecondaryTap$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSecondaryTap;
Function _TextSelectionGestureDetectorBuilder_onSecondaryTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onSecondaryTapDown;
Function _TextSelectionGestureDetectorBuilder_onDoubleTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onDoubleTapDown;
Function _TextSelectionGestureDetectorBuilder_onTripleTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onTripleTapDown;
Function _TextSelectionGestureDetectorBuilder_onDragSelectionStart$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onDragSelectionStart;
Function _TextSelectionGestureDetectorBuilder_onDragSelectionUpdate$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onDragSelectionUpdate;
Function _TextSelectionGestureDetectorBuilder_onDragSelectionEnd$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.onDragSelectionEnd;
Function _TextSelectionGestureDetectorBuilder_buildGestureDetector$(
  m.Scope scope$,
  TextSelectionGestureDetectorBuilder target$,
) =>
    target$.buildGestureDetector;
Function TextSelectionGestureDetector_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSelectionGestureDetector;
Function TextSelectionGestureDetector_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSelectionGestureDetector;
Function _TextSelectionGestureDetector_onTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onTapDown;
    };
Function _TextSelectionGestureDetector_onForcePressStart$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onForcePressStart;
    };
Function _TextSelectionGestureDetector_onForcePressEnd$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onForcePressEnd;
    };
Function _TextSelectionGestureDetector_onSecondaryTap$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSecondaryTap;
    };
Function _TextSelectionGestureDetector_onSecondaryTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSecondaryTapDown;
    };
Function _TextSelectionGestureDetector_onSingleTapUp$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSingleTapUp;
    };
Function _TextSelectionGestureDetector_onSingleTapCancel$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSingleTapCancel;
    };
Function _TextSelectionGestureDetector_onSingleLongTapStart$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSingleLongTapStart;
    };
Function _TextSelectionGestureDetector_onSingleLongTapMoveUpdate$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSingleLongTapMoveUpdate;
    };
Function _TextSelectionGestureDetector_onSingleLongTapEnd$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onSingleLongTapEnd;
    };
Function _TextSelectionGestureDetector_onDoubleTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onDoubleTapDown;
    };
Function _TextSelectionGestureDetector_onTripleTapDown$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onTripleTapDown;
    };
Function _TextSelectionGestureDetector_onDragSelectionStart$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onDragSelectionStart;
    };
Function _TextSelectionGestureDetector_onDragSelectionUpdate$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onDragSelectionUpdate;
    };
Function _TextSelectionGestureDetector_onDragSelectionEnd$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.onDragSelectionEnd;
    };
Function _TextSelectionGestureDetector_behavior$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.behavior;
    };
Function _TextSelectionGestureDetector_child$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    () {
      return target$.child;
    };
Function _TextSelectionGestureDetector__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onTapDown,
      m.FunctionPointer? onForcePressStart,
      m.FunctionPointer? onForcePressEnd,
      m.FunctionPointer? onSecondaryTap,
      m.FunctionPointer? onSecondaryTapDown,
      m.FunctionPointer? onSingleTapUp,
      m.FunctionPointer? onSingleTapCancel,
      m.FunctionPointer? onSingleLongTapStart,
      m.FunctionPointer? onSingleLongTapMoveUpdate,
      m.FunctionPointer? onSingleLongTapEnd,
      m.FunctionPointer? onDoubleTapDown,
      m.FunctionPointer? onTripleTapDown,
      m.FunctionPointer? onDragSelectionStart,
      m.FunctionPointer? onDragSelectionUpdate,
      m.FunctionPointer? onDragSelectionEnd,
      HitTestBehavior? behavior,
      required Widget child,
    }) {
      void onDoubleTapDownProxy(TapDragDownDetails onDoubleTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDoubleTapDown!,
            [onDoubleTapDown_details$],
            {},
          );
      void onDragSelectionEndProxy(
              TapDragEndDetails onDragSelectionEnd_endDetails$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDragSelectionEnd!,
            [onDragSelectionEnd_endDetails$],
            {},
          );
      void onDragSelectionStartProxy(
              TapDragStartDetails onDragSelectionStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDragSelectionStart!,
            [onDragSelectionStart_details$],
            {},
          );
      void onDragSelectionUpdateProxy(
              TapDragUpdateDetails onDragSelectionUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDragSelectionUpdate!,
            [onDragSelectionUpdate_details$],
            {},
          );
      void onForcePressEndProxy(ForcePressDetails onForcePressEnd_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onForcePressEnd!,
            [onForcePressEnd_details$],
            {},
          );
      void onForcePressStartProxy(
              ForcePressDetails onForcePressStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onForcePressStart!,
            [onForcePressStart_details$],
            {},
          );
      void onSecondaryTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onSecondaryTap!,
            [],
            {},
          );
      void onSecondaryTapDownProxy(
              TapDownDetails onSecondaryTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSecondaryTapDown!,
            [onSecondaryTapDown_details$],
            {},
          );
      void onSingleLongTapEndProxy(
              LongPressEndDetails onSingleLongTapEnd_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSingleLongTapEnd!,
            [onSingleLongTapEnd_details$],
            {},
          );
      void onSingleLongTapMoveUpdateProxy(
              LongPressMoveUpdateDetails onSingleLongTapMoveUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSingleLongTapMoveUpdate!,
            [onSingleLongTapMoveUpdate_details$],
            {},
          );
      void onSingleLongTapStartProxy(
              LongPressStartDetails onSingleLongTapStart_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSingleLongTapStart!,
            [onSingleLongTapStart_details$],
            {},
          );
      void onSingleTapCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onSingleTapCancel!,
            [],
            {},
          );
      void onSingleTapUpProxy(TapDragUpDetails onSingleTapUp_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSingleTapUp!,
            [onSingleTapUp_details$],
            {},
          );
      void onTapDownProxy(TapDragDownDetails onTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onTapDown!,
            [onTapDown_details$],
            {},
          );
      void onTripleTapDownProxy(TapDragDownDetails onTripleTapDown_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onTripleTapDown!,
            [onTripleTapDown_details$],
            {},
          );
      return TextSelectionGestureDetector(
        behavior: behavior,
        child: child,
        key: key,
        onDoubleTapDown: onDoubleTapDown == null ? null : onDoubleTapDownProxy,
        onDragSelectionEnd:
            onDragSelectionEnd == null ? null : onDragSelectionEndProxy,
        onDragSelectionStart:
            onDragSelectionStart == null ? null : onDragSelectionStartProxy,
        onDragSelectionUpdate:
            onDragSelectionUpdate == null ? null : onDragSelectionUpdateProxy,
        onForcePressEnd: onForcePressEnd == null ? null : onForcePressEndProxy,
        onForcePressStart:
            onForcePressStart == null ? null : onForcePressStartProxy,
        onSecondaryTap: onSecondaryTap == null ? null : onSecondaryTapProxy,
        onSecondaryTapDown:
            onSecondaryTapDown == null ? null : onSecondaryTapDownProxy,
        onSingleLongTapEnd:
            onSingleLongTapEnd == null ? null : onSingleLongTapEndProxy,
        onSingleLongTapMoveUpdate: onSingleLongTapMoveUpdate == null
            ? null
            : onSingleLongTapMoveUpdateProxy,
        onSingleLongTapStart:
            onSingleLongTapStart == null ? null : onSingleLongTapStartProxy,
        onSingleTapCancel:
            onSingleTapCancel == null ? null : onSingleTapCancelProxy,
        onSingleTapUp: onSingleTapUp == null ? null : onSingleTapUpProxy,
        onTapDown: onTapDown == null ? null : onTapDownProxy,
        onTripleTapDown: onTripleTapDown == null ? null : onTripleTapDownProxy,
      );
    };
Function _TextSelectionGestureDetector_createState$(
  m.Scope scope$,
  TextSelectionGestureDetector target$,
) =>
    target$.createState;
Function ClipboardStatusNotifier_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ClipboardStatusNotifier;
Function ClipboardStatusNotifier_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ClipboardStatusNotifier;
Function _ClipboardStatusNotifier_disposed$(
  m.Scope scope$,
  ClipboardStatusNotifier target$,
) =>
    () {
      return target$.disposed;
    };
Function _ClipboardStatusNotifier__$(m.Scope scope$) =>
    ({ClipboardStatus? value}) {
      return ClipboardStatusNotifier(value: value ?? ClipboardStatus.unknown);
    };
Function _ClipboardStatusNotifier_update$(
  m.Scope scope$,
  ClipboardStatusNotifier target$,
) =>
    target$.update;
Function _ClipboardStatusNotifier_addListener$(
  m.Scope scope$,
  ClipboardStatusNotifier target$,
) =>
    (m.FunctionPointer listener) {
      void listenerProxy() => scope$.engine.callFunctionPointer(
            scope$,
            listener,
            [],
            {},
          );
      target$.addListener(listenerProxy);
    };
Function _ClipboardStatusNotifier_removeListener$(
  m.Scope scope$,
  ClipboardStatusNotifier target$,
) =>
    (m.FunctionPointer listener) {
      void listenerProxy() => scope$.engine.callFunctionPointer(
            scope$,
            listener,
            [],
            {},
          );
      target$.removeListener(listenerProxy);
    };
Function _ClipboardStatusNotifier_didChangeAppLifecycleState$(
  m.Scope scope$,
  ClipboardStatusNotifier target$,
) =>
    target$.didChangeAppLifecycleState;
Function _ClipboardStatusNotifier_dispose$(
  m.Scope scope$,
  ClipboardStatusNotifier target$,
) =>
    target$.dispose;
ClipboardStatus _ClipboardStatus_pasteable$() {
  return ClipboardStatus.pasteable;
}

ClipboardStatus _ClipboardStatus_unknown$() {
  return ClipboardStatus.unknown;
}

ClipboardStatus _ClipboardStatus_notPasteable$() {
  return ClipboardStatus.notPasteable;
}

List<ClipboardStatus> _ClipboardStatus_values$() {
  return ClipboardStatus.values;
}
