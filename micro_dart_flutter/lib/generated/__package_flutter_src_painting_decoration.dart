// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/decoration.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/painting/image_provider.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/decoration.dart',
  {'Decoration.lerp': _Decoration_lerp$},
  {},
  {
    'Decoration': m.ClassMirror(
      'Decoration',
      {
        '#as': Decoration_as$,
        '#is': Decoration_is$,
        'padding': _Decoration_padding$,
        'isComplex': _Decoration_isComplex$,
        'toStringShort': _Decoration_toStringShort$,
        'debugAssertIsValid': _Decoration_debugAssertIsValid$,
        'lerpFrom': _Decoration_lerpFrom$,
        'lerpTo': _Decoration_lerpTo$,
        'hitTest': _Decoration_hitTest$,
        'createBoxPainter': _Decoration_createBoxPainter$,
        'getClipPath': _Decoration_getClipPath$,
      },
      {},
    ),
    'BoxPainter': m.ClassMirror(
      'BoxPainter',
      {
        '#as': BoxPainter_as$,
        '#is': BoxPainter_is$,
        'onChanged': _BoxPainter_onChanged$,
        'paint': _BoxPainter_paint$,
        'dispose': _BoxPainter_dispose$,
      },
      {},
    ),
  },
);
Function Decoration_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Decoration;
Function Decoration_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Decoration;
Function _Decoration_padding$(
  m.Scope scope$,
  Decoration target$,
) =>
    () {
      return target$.padding;
    };
Function _Decoration_isComplex$(
  m.Scope scope$,
  Decoration target$,
) =>
    () {
      return target$.isComplex;
    };
Function _Decoration_toStringShort$(
  m.Scope scope$,
  Decoration target$,
) =>
    target$.toStringShort;
Function _Decoration_debugAssertIsValid$(
  m.Scope scope$,
  Decoration target$,
) =>
    target$.debugAssertIsValid;
Function _Decoration_lerpFrom$(
  m.Scope scope$,
  Decoration target$,
) =>
    target$.lerpFrom;
Function _Decoration_lerpTo$(
  m.Scope scope$,
  Decoration target$,
) =>
    target$.lerpTo;
Function _Decoration_lerp$(m.Scope scope$) => Decoration.lerp;
Function _Decoration_hitTest$(
  m.Scope scope$,
  Decoration target$,
) =>
    target$.hitTest;
Function _Decoration_createBoxPainter$(
  m.Scope scope$,
  Decoration target$,
) =>
    ([m.FunctionPointer? onChanged]) {
      if (onChanged == null) {
        return target$.createBoxPainter();
      }
      void onChangedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onChanged,
            [],
            {},
          );
      return target$.createBoxPainter(onChangedProxy);
    };
Function _Decoration_getClipPath$(
  m.Scope scope$,
  Decoration target$,
) =>
    target$.getClipPath;
Function BoxPainter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BoxPainter;
Function BoxPainter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BoxPainter;
Function _BoxPainter_onChanged$(
  m.Scope scope$,
  BoxPainter target$,
) =>
    () {
      return target$.onChanged;
    };
Function _BoxPainter_paint$(
  m.Scope scope$,
  BoxPainter target$,
) =>
    target$.paint;
Function _BoxPainter_dispose$(
  m.Scope scope$,
  BoxPainter target$,
) =>
    target$.dispose;
