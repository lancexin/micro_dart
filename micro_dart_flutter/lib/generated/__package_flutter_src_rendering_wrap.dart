// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/rendering/wrap.dart';
import 'dart:math';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/rendering/layout_helper.dart';
import 'package:flutter/src/rendering/object.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/rendering/wrap.dart',
  {
    'WrapParentData.': _WrapParentData__$,
    'RenderWrap.': _RenderWrap__$,
    'WrapAlignment.start': _WrapAlignment_start$,
    'WrapAlignment.end': _WrapAlignment_end$,
    'WrapAlignment.center': _WrapAlignment_center$,
    'WrapAlignment.spaceBetween': _WrapAlignment_spaceBetween$,
    'WrapAlignment.spaceAround': _WrapAlignment_spaceAround$,
    'WrapAlignment.spaceEvenly': _WrapAlignment_spaceEvenly$,
    'WrapAlignment.values': _WrapAlignment_values$,
    'WrapCrossAlignment.start': _WrapCrossAlignment_start$,
    'WrapCrossAlignment.end': _WrapCrossAlignment_end$,
    'WrapCrossAlignment.center': _WrapCrossAlignment_center$,
    'WrapCrossAlignment.values': _WrapCrossAlignment_values$,
  },
  {},
  {
    'WrapParentData': m.ClassMirror(
      'WrapParentData',
      {
        '#as': WrapParentData_as$,
        '#is': WrapParentData_is$,
      },
      {},
    ),
    'RenderWrap': m.ClassMirror(
      'RenderWrap',
      {
        '#as': RenderWrap_as$,
        '#is': RenderWrap_is$,
        'direction': _RenderWrap_direction$,
        'alignment': _RenderWrap_alignment$,
        'spacing': _RenderWrap_spacing$,
        'runAlignment': _RenderWrap_runAlignment$,
        'runSpacing': _RenderWrap_runSpacing$,
        'crossAxisAlignment': _RenderWrap_crossAxisAlignment$,
        'textDirection': _RenderWrap_textDirection$,
        'verticalDirection': _RenderWrap_verticalDirection$,
        'clipBehavior': _RenderWrap_clipBehavior$,
        'setupParentData': _RenderWrap_setupParentData$,
        'computeMinIntrinsicWidth': _RenderWrap_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth': _RenderWrap_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight': _RenderWrap_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight': _RenderWrap_computeMaxIntrinsicHeight$,
        'computeDistanceToActualBaseline':
            _RenderWrap_computeDistanceToActualBaseline$,
        'computeDryLayout': _RenderWrap_computeDryLayout$,
        'performLayout': _RenderWrap_performLayout$,
        'hitTestChildren': _RenderWrap_hitTestChildren$,
        'paint': _RenderWrap_paint$,
        'dispose': _RenderWrap_dispose$,
        'debugFillProperties': _RenderWrap_debugFillProperties$,
      },
      {
        'direction': _RenderWrap_direction_set$,
        'alignment': _RenderWrap_alignment_set$,
        'spacing': _RenderWrap_spacing_set$,
        'runAlignment': _RenderWrap_runAlignment_set$,
        'runSpacing': _RenderWrap_runSpacing_set$,
        'crossAxisAlignment': _RenderWrap_crossAxisAlignment_set$,
        'textDirection': _RenderWrap_textDirection_set$,
        'verticalDirection': _RenderWrap_verticalDirection_set$,
        'clipBehavior': _RenderWrap_clipBehavior_set$,
      },
    ),
    'WrapAlignment': m.ClassMirror(
      'WrapAlignment',
      {},
      {},
    ),
    'WrapCrossAlignment': m.ClassMirror(
      'WrapCrossAlignment',
      {},
      {},
    ),
  },
);
Function WrapParentData_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as WrapParentData;
Function WrapParentData_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is WrapParentData;
Function _WrapParentData__$(m.Scope scope$) => () {
      return WrapParentData();
    };
Function RenderWrap_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderWrap;
Function RenderWrap_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderWrap;
Function _RenderWrap_direction$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.direction;
    };
void _RenderWrap_direction_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.direction = other$;
    };
Function _RenderWrap_alignment$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.alignment;
    };
void _RenderWrap_alignment_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.alignment = other$;
    };
Function _RenderWrap_spacing$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.spacing;
    };
void _RenderWrap_spacing_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.spacing = other$;
    };
Function _RenderWrap_runAlignment$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.runAlignment;
    };
void _RenderWrap_runAlignment_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.runAlignment = other$;
    };
Function _RenderWrap_runSpacing$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.runSpacing;
    };
void _RenderWrap_runSpacing_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.runSpacing = other$;
    };
Function _RenderWrap_crossAxisAlignment$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.crossAxisAlignment;
    };
void _RenderWrap_crossAxisAlignment_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.crossAxisAlignment = other$;
    };
Function _RenderWrap_textDirection$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.textDirection;
    };
void _RenderWrap_textDirection_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _RenderWrap_verticalDirection$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.verticalDirection;
    };
void _RenderWrap_verticalDirection_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.verticalDirection = other$;
    };
Function _RenderWrap_clipBehavior$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    () {
      return target$.clipBehavior;
    };
void _RenderWrap_clipBehavior_set$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    (dynamic other$) {
      target$.clipBehavior = other$;
    };
Function _RenderWrap__$(m.Scope scope$) => ({
      List? children,
      Axis? direction,
      WrapAlignment? alignment,
      double? spacing,
      WrapAlignment? runAlignment,
      double? runSpacing,
      WrapCrossAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      Clip? clipBehavior,
    }) {
      return RenderWrap(
        alignment: alignment ?? WrapAlignment.start,
        children: children == null ? null : List.from(children),
        clipBehavior: clipBehavior ?? Clip.none,
        crossAxisAlignment: crossAxisAlignment ?? WrapCrossAlignment.start,
        direction: direction ?? Axis.horizontal,
        runAlignment: runAlignment ?? WrapAlignment.start,
        runSpacing: runSpacing ?? 0.0,
        spacing: spacing ?? 0.0,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function _RenderWrap_setupParentData$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.setupParentData;
Function _RenderWrap_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderWrap_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderWrap_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderWrap_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderWrap_computeDistanceToActualBaseline$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.computeDistanceToActualBaseline;
Function _RenderWrap_computeDryLayout$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.computeDryLayout;
Function _RenderWrap_performLayout$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.performLayout;
Function _RenderWrap_hitTestChildren$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.hitTestChildren;
Function _RenderWrap_paint$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.paint;
Function _RenderWrap_dispose$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.dispose;
Function _RenderWrap_debugFillProperties$(
  m.Scope scope$,
  RenderWrap target$,
) =>
    target$.debugFillProperties;
WrapAlignment _WrapAlignment_start$() {
  return WrapAlignment.start;
}

WrapAlignment _WrapAlignment_end$() {
  return WrapAlignment.end;
}

WrapAlignment _WrapAlignment_center$() {
  return WrapAlignment.center;
}

WrapAlignment _WrapAlignment_spaceBetween$() {
  return WrapAlignment.spaceBetween;
}

WrapAlignment _WrapAlignment_spaceAround$() {
  return WrapAlignment.spaceAround;
}

WrapAlignment _WrapAlignment_spaceEvenly$() {
  return WrapAlignment.spaceEvenly;
}

List<WrapAlignment> _WrapAlignment_values$() {
  return WrapAlignment.values;
}

WrapCrossAlignment _WrapCrossAlignment_start$() {
  return WrapCrossAlignment.start;
}

WrapCrossAlignment _WrapCrossAlignment_end$() {
  return WrapCrossAlignment.end;
}

WrapCrossAlignment _WrapCrossAlignment_center$() {
  return WrapCrossAlignment.center;
}

List<WrapCrossAlignment> _WrapCrossAlignment_values$() {
  return WrapCrossAlignment.values;
}
