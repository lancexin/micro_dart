// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/gradient.dart';
import 'dart:collection';
import 'dart:math';
import 'dart:ui' show Gradient, lerpDouble;
import 'package:flutter/foundation.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/painting/basic_types.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/gradient.dart',
  {
    'Gradient.lerp': _Gradient_lerp$,
    'LinearGradient.lerp': _LinearGradient_lerp$,
    'RadialGradient.lerp': _RadialGradient_lerp$,
    'SweepGradient.lerp': _SweepGradient_lerp$,
  },
  {},
  {
    'GradientTransform': m.ClassMirror(
      'GradientTransform',
      {
        '#as': GradientTransform_as$,
        '#is': GradientTransform_is$,
        'transform': _GradientTransform_transform$,
      },
      {},
    ),
    'GradientRotation': m.ClassMirror(
      'GradientRotation',
      {
        '#as': GradientRotation_as$,
        '#is': GradientRotation_is$,
        'radians': _GradientRotation_radians$,
        'hashCode': _GradientRotation_hashCode$,
        'transform': _GradientRotation_transform$,
        '==': _GradientRotation_eq$$,
        'toString': _GradientRotation_toString$,
      },
      {},
    ),
    'Gradient': m.ClassMirror(
      'Gradient',
      {
        '#as': Gradient_as$,
        '#is': Gradient_is$,
        'colors': _Gradient_colors$,
        'stops': _Gradient_stops$,
        'transform': _Gradient_transform$,
        'createShader': _Gradient_createShader$,
        'scale': _Gradient_scale$,
        'lerpFrom': _Gradient_lerpFrom$,
        'lerpTo': _Gradient_lerpTo$,
      },
      {},
    ),
    'LinearGradient': m.ClassMirror(
      'LinearGradient',
      {
        '#as': LinearGradient_as$,
        '#is': LinearGradient_is$,
        'begin': _LinearGradient_begin$,
        'end': _LinearGradient_end$,
        'tileMode': _LinearGradient_tileMode$,
        'hashCode': _LinearGradient_hashCode$,
        'createShader': _LinearGradient_createShader$,
        'scale': _LinearGradient_scale$,
        'lerpFrom': _LinearGradient_lerpFrom$,
        'lerpTo': _LinearGradient_lerpTo$,
        '==': _LinearGradient_eq$$,
        'toString': _LinearGradient_toString$,
      },
      {},
    ),
    'RadialGradient': m.ClassMirror(
      'RadialGradient',
      {
        '#as': RadialGradient_as$,
        '#is': RadialGradient_is$,
        'center': _RadialGradient_center$,
        'radius': _RadialGradient_radius$,
        'tileMode': _RadialGradient_tileMode$,
        'focal': _RadialGradient_focal$,
        'focalRadius': _RadialGradient_focalRadius$,
        'hashCode': _RadialGradient_hashCode$,
        'createShader': _RadialGradient_createShader$,
        'scale': _RadialGradient_scale$,
        'lerpFrom': _RadialGradient_lerpFrom$,
        'lerpTo': _RadialGradient_lerpTo$,
        '==': _RadialGradient_eq$$,
        'toString': _RadialGradient_toString$,
      },
      {},
    ),
    'SweepGradient': m.ClassMirror(
      'SweepGradient',
      {
        '#as': SweepGradient_as$,
        '#is': SweepGradient_is$,
        'center': _SweepGradient_center$,
        'startAngle': _SweepGradient_startAngle$,
        'endAngle': _SweepGradient_endAngle$,
        'tileMode': _SweepGradient_tileMode$,
        'hashCode': _SweepGradient_hashCode$,
        'createShader': _SweepGradient_createShader$,
        'scale': _SweepGradient_scale$,
        'lerpFrom': _SweepGradient_lerpFrom$,
        'lerpTo': _SweepGradient_lerpTo$,
        '==': _SweepGradient_eq$$,
        'toString': _SweepGradient_toString$,
      },
      {},
    ),
  },
);
Function GradientTransform_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as GradientTransform;
Function GradientTransform_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is GradientTransform;
Function _GradientTransform_transform$(
  m.Scope scope,
  GradientTransform target,
) =>
    target.transform;
Function GradientRotation_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as GradientRotation;
Function GradientRotation_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is GradientRotation;
double _GradientRotation_radians$(GradientRotation target) {
  return target.radians;
}

int _GradientRotation_hashCode$(GradientRotation target) {
  return target.hashCode;
}

Function _GradientRotation_transform$(
  m.Scope scope,
  GradientRotation target,
) =>
    target.transform;
Function _GradientRotation_eq$$(
  m.Scope scope,
  GradientRotation target,
) =>
    (Object other) => target == other;
Function _GradientRotation_toString$(
  m.Scope scope,
  GradientRotation target,
) =>
    target.toString;
Function Gradient_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as Gradient;
Function Gradient_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is Gradient;
List<Color> _Gradient_colors$(Gradient target) {
  return target.colors;
}

List<double>? _Gradient_stops$(Gradient target) {
  return target.stops;
}

GradientTransform? _Gradient_transform$(Gradient target) {
  return target.transform;
}

Function _Gradient_createShader$(
  m.Scope scope,
  Gradient target,
) =>
    target.createShader;
Function _Gradient_scale$(
  m.Scope scope,
  Gradient target,
) =>
    target.scale;
Function _Gradient_lerpFrom$(
  m.Scope scope,
  Gradient target,
) =>
    target.lerpFrom;
Function _Gradient_lerpTo$(
  m.Scope scope,
  Gradient target,
) =>
    target.lerpTo;
Function _Gradient_lerp$(m.Scope scope) => Gradient.lerp;
Function LinearGradient_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as LinearGradient;
Function LinearGradient_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is LinearGradient;
AlignmentGeometry _LinearGradient_begin$(LinearGradient target) {
  return target.begin;
}

AlignmentGeometry _LinearGradient_end$(LinearGradient target) {
  return target.end;
}

TileMode _LinearGradient_tileMode$(LinearGradient target) {
  return target.tileMode;
}

int _LinearGradient_hashCode$(LinearGradient target) {
  return target.hashCode;
}

Function _LinearGradient_createShader$(
  m.Scope scope,
  LinearGradient target,
) =>
    target.createShader;
Function _LinearGradient_scale$(
  m.Scope scope,
  LinearGradient target,
) =>
    target.scale;
Function _LinearGradient_lerpFrom$(
  m.Scope scope,
  LinearGradient target,
) =>
    target.lerpFrom;
Function _LinearGradient_lerpTo$(
  m.Scope scope,
  LinearGradient target,
) =>
    target.lerpTo;
Function _LinearGradient_lerp$(m.Scope scope) => LinearGradient.lerp;
Function _LinearGradient_eq$$(
  m.Scope scope,
  LinearGradient target,
) =>
    (Object other) => target == other;
Function _LinearGradient_toString$(
  m.Scope scope,
  LinearGradient target,
) =>
    target.toString;
Function RadialGradient_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as RadialGradient;
Function RadialGradient_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is RadialGradient;
AlignmentGeometry _RadialGradient_center$(RadialGradient target) {
  return target.center;
}

double _RadialGradient_radius$(RadialGradient target) {
  return target.radius;
}

TileMode _RadialGradient_tileMode$(RadialGradient target) {
  return target.tileMode;
}

AlignmentGeometry? _RadialGradient_focal$(RadialGradient target) {
  return target.focal;
}

double _RadialGradient_focalRadius$(RadialGradient target) {
  return target.focalRadius;
}

int _RadialGradient_hashCode$(RadialGradient target) {
  return target.hashCode;
}

Function _RadialGradient_createShader$(
  m.Scope scope,
  RadialGradient target,
) =>
    target.createShader;
Function _RadialGradient_scale$(
  m.Scope scope,
  RadialGradient target,
) =>
    target.scale;
Function _RadialGradient_lerpFrom$(
  m.Scope scope,
  RadialGradient target,
) =>
    target.lerpFrom;
Function _RadialGradient_lerpTo$(
  m.Scope scope,
  RadialGradient target,
) =>
    target.lerpTo;
Function _RadialGradient_lerp$(m.Scope scope) => RadialGradient.lerp;
Function _RadialGradient_eq$$(
  m.Scope scope,
  RadialGradient target,
) =>
    (Object other) => target == other;
Function _RadialGradient_toString$(
  m.Scope scope,
  RadialGradient target,
) =>
    target.toString;
Function SweepGradient_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as SweepGradient;
Function SweepGradient_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is SweepGradient;
AlignmentGeometry _SweepGradient_center$(SweepGradient target) {
  return target.center;
}

double _SweepGradient_startAngle$(SweepGradient target) {
  return target.startAngle;
}

double _SweepGradient_endAngle$(SweepGradient target) {
  return target.endAngle;
}

TileMode _SweepGradient_tileMode$(SweepGradient target) {
  return target.tileMode;
}

int _SweepGradient_hashCode$(SweepGradient target) {
  return target.hashCode;
}

Function _SweepGradient_createShader$(
  m.Scope scope,
  SweepGradient target,
) =>
    target.createShader;
Function _SweepGradient_scale$(
  m.Scope scope,
  SweepGradient target,
) =>
    target.scale;
Function _SweepGradient_lerpFrom$(
  m.Scope scope,
  SweepGradient target,
) =>
    target.lerpFrom;
Function _SweepGradient_lerpTo$(
  m.Scope scope,
  SweepGradient target,
) =>
    target.lerpTo;
Function _SweepGradient_lerp$(m.Scope scope) => SweepGradient.lerp;
Function _SweepGradient_eq$$(
  m.Scope scope,
  SweepGradient target,
) =>
    (Object other) => target == other;
Function _SweepGradient_toString$(
  m.Scope scope,
  SweepGradient target,
) =>
    target.toString;
