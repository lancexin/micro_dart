// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/alignment.dart';
import 'dart:ui' show lerpDouble;
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/basic_types.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/alignment.dart',
  {
    'AlignmentGeometry.lerp': _AlignmentGeometry_lerp$,
    'Alignment.topLeft': _Alignment_topLeft$,
    'Alignment.topCenter': _Alignment_topCenter$,
    'Alignment.topRight': _Alignment_topRight$,
    'Alignment.centerLeft': _Alignment_centerLeft$,
    'Alignment.center': _Alignment_center$,
    'Alignment.centerRight': _Alignment_centerRight$,
    'Alignment.bottomLeft': _Alignment_bottomLeft$,
    'Alignment.bottomCenter': _Alignment_bottomCenter$,
    'Alignment.bottomRight': _Alignment_bottomRight$,
    'Alignment.': _Alignment__$,
    'Alignment.lerp': _Alignment_lerp$,
    'AlignmentDirectional.topStart': _AlignmentDirectional_topStart$,
    'AlignmentDirectional.topCenter': _AlignmentDirectional_topCenter$,
    'AlignmentDirectional.topEnd': _AlignmentDirectional_topEnd$,
    'AlignmentDirectional.centerStart': _AlignmentDirectional_centerStart$,
    'AlignmentDirectional.center': _AlignmentDirectional_center$,
    'AlignmentDirectional.centerEnd': _AlignmentDirectional_centerEnd$,
    'AlignmentDirectional.bottomStart': _AlignmentDirectional_bottomStart$,
    'AlignmentDirectional.bottomCenter': _AlignmentDirectional_bottomCenter$,
    'AlignmentDirectional.bottomEnd': _AlignmentDirectional_bottomEnd$,
    'AlignmentDirectional.': _AlignmentDirectional__$,
    'AlignmentDirectional.lerp': _AlignmentDirectional_lerp$,
    'TextAlignVertical.top': _TextAlignVertical_top$,
    'TextAlignVertical.center': _TextAlignVertical_center$,
    'TextAlignVertical.bottom': _TextAlignVertical_bottom$,
    'TextAlignVertical.': _TextAlignVertical__$,
  },
  {},
  {
    'AlignmentGeometry': m.ClassMirror(
      'AlignmentGeometry',
      {
        '#as': AlignmentGeometry_as$,
        '#is': AlignmentGeometry_is$,
        'hashCode': _AlignmentGeometry_hashCode$,
        'add': _AlignmentGeometry_add$,
        'unary-': _AlignmentGeometry_unary_minus$$,
        '*': _AlignmentGeometry_times$$,
        '/': _AlignmentGeometry_over$$,
        '~/': _AlignmentGeometry_division$$,
        '%': _AlignmentGeometry_surplus$$,
        'resolve': _AlignmentGeometry_resolve$,
        'toString': _AlignmentGeometry_toString$,
        '==': _AlignmentGeometry_eq$$,
      },
      {},
    ),
    'Alignment': m.ClassMirror(
      'Alignment',
      {
        '#as': Alignment_as$,
        '#is': Alignment_is$,
        'x': _Alignment_x$,
        'y': _Alignment_y$,
        'add': _Alignment_add$,
        '-': _Alignment_minus$$,
        '+': _Alignment_plus$$,
        'unary-': _Alignment_unary_minus$$,
        '*': _Alignment_times$$,
        '/': _Alignment_over$$,
        '~/': _Alignment_division$$,
        '%': _Alignment_surplus$$,
        'alongOffset': _Alignment_alongOffset$,
        'alongSize': _Alignment_alongSize$,
        'withinRect': _Alignment_withinRect$,
        'inscribe': _Alignment_inscribe$,
        'resolve': _Alignment_resolve$,
        'toString': _Alignment_toString$,
      },
      {},
    ),
    'AlignmentDirectional': m.ClassMirror(
      'AlignmentDirectional',
      {
        '#as': AlignmentDirectional_as$,
        '#is': AlignmentDirectional_is$,
        'start': _AlignmentDirectional_start$,
        'y': _AlignmentDirectional_y$,
        'add': _AlignmentDirectional_add$,
        '-': _AlignmentDirectional_minus$$,
        '+': _AlignmentDirectional_plus$$,
        'unary-': _AlignmentDirectional_unary_minus$$,
        '*': _AlignmentDirectional_times$$,
        '/': _AlignmentDirectional_over$$,
        '~/': _AlignmentDirectional_division$$,
        '%': _AlignmentDirectional_surplus$$,
        'resolve': _AlignmentDirectional_resolve$,
        'toString': _AlignmentDirectional_toString$,
      },
      {},
    ),
    'TextAlignVertical': m.ClassMirror(
      'TextAlignVertical',
      {
        '#as': TextAlignVertical_as$,
        '#is': TextAlignVertical_is$,
        'y': _TextAlignVertical_y$,
        'toString': _TextAlignVertical_toString$,
      },
      {},
    ),
  },
);
Function AlignmentGeometry_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AlignmentGeometry;
Function AlignmentGeometry_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AlignmentGeometry;
Function _AlignmentGeometry_hashCode$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    () {
      return target$.hashCode;
    };
Function _AlignmentGeometry_add$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    target$.add;
Function _AlignmentGeometry_unary_minus$$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    () => -target$;
Function _AlignmentGeometry_times$$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    (double other$) => target$ * other$;
Function _AlignmentGeometry_over$$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    (double other$) => target$ / other$;
Function _AlignmentGeometry_division$$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    (double other$) => target$ ~/ other$;
Function _AlignmentGeometry_surplus$$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    (double other$) => target$ % other$;
Function _AlignmentGeometry_lerp$(m.Scope scope$) => AlignmentGeometry.lerp;
Function _AlignmentGeometry_resolve$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    target$.resolve;
Function _AlignmentGeometry_toString$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    target$.toString;
Function _AlignmentGeometry_eq$$(
  m.Scope scope$,
  AlignmentGeometry target$,
) =>
    (Object other$) => target$ == other$;
Function Alignment_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Alignment;
Function Alignment_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Alignment;
Function _Alignment_x$(
  m.Scope scope$,
  Alignment target$,
) =>
    () {
      return target$.x;
    };
Function _Alignment_y$(
  m.Scope scope$,
  Alignment target$,
) =>
    () {
      return target$.y;
    };
Function _Alignment_topLeft$(m.Scope scope$) => () => Alignment.topLeft;
Function _Alignment_topCenter$(m.Scope scope$) => () => Alignment.topCenter;
Function _Alignment_topRight$(m.Scope scope$) => () => Alignment.topRight;
Function _Alignment_centerLeft$(m.Scope scope$) => () => Alignment.centerLeft;
Function _Alignment_center$(m.Scope scope$) => () => Alignment.center;
Function _Alignment_centerRight$(m.Scope scope$) => () => Alignment.centerRight;
Function _Alignment_bottomLeft$(m.Scope scope$) => () => Alignment.bottomLeft;
Function _Alignment_bottomCenter$(m.Scope scope$) =>
    () => Alignment.bottomCenter;
Function _Alignment_bottomRight$(m.Scope scope$) => () => Alignment.bottomRight;
Function _Alignment__$(m.Scope scope$) => (
      double x,
      double y,
    ) {
      return Alignment(
        x,
        y,
      );
    };
Function _Alignment_add$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.add;
Function _Alignment_minus$$(
  m.Scope scope$,
  Alignment target$,
) =>
    (Alignment other$) => target$ - other$;
Function _Alignment_plus$$(
  m.Scope scope$,
  Alignment target$,
) =>
    (Alignment other$) => target$ + other$;
Function _Alignment_unary_minus$$(
  m.Scope scope$,
  Alignment target$,
) =>
    () => -target$;
Function _Alignment_times$$(
  m.Scope scope$,
  Alignment target$,
) =>
    (double other$) => target$ * other$;
Function _Alignment_over$$(
  m.Scope scope$,
  Alignment target$,
) =>
    (double other$) => target$ / other$;
Function _Alignment_division$$(
  m.Scope scope$,
  Alignment target$,
) =>
    (double other$) => target$ ~/ other$;
Function _Alignment_surplus$$(
  m.Scope scope$,
  Alignment target$,
) =>
    (double other$) => target$ % other$;
Function _Alignment_alongOffset$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.alongOffset;
Function _Alignment_alongSize$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.alongSize;
Function _Alignment_withinRect$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.withinRect;
Function _Alignment_inscribe$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.inscribe;
Function _Alignment_lerp$(m.Scope scope$) => Alignment.lerp;
Function _Alignment_resolve$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.resolve;
Function _Alignment_toString$(
  m.Scope scope$,
  Alignment target$,
) =>
    target$.toString;
Function AlignmentDirectional_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AlignmentDirectional;
Function AlignmentDirectional_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AlignmentDirectional;
Function _AlignmentDirectional_start$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    () {
      return target$.start;
    };
Function _AlignmentDirectional_y$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    () {
      return target$.y;
    };
Function _AlignmentDirectional_topStart$(m.Scope scope$) =>
    () => AlignmentDirectional.topStart;
Function _AlignmentDirectional_topCenter$(m.Scope scope$) =>
    () => AlignmentDirectional.topCenter;
Function _AlignmentDirectional_topEnd$(m.Scope scope$) =>
    () => AlignmentDirectional.topEnd;
Function _AlignmentDirectional_centerStart$(m.Scope scope$) =>
    () => AlignmentDirectional.centerStart;
Function _AlignmentDirectional_center$(m.Scope scope$) =>
    () => AlignmentDirectional.center;
Function _AlignmentDirectional_centerEnd$(m.Scope scope$) =>
    () => AlignmentDirectional.centerEnd;
Function _AlignmentDirectional_bottomStart$(m.Scope scope$) =>
    () => AlignmentDirectional.bottomStart;
Function _AlignmentDirectional_bottomCenter$(m.Scope scope$) =>
    () => AlignmentDirectional.bottomCenter;
Function _AlignmentDirectional_bottomEnd$(m.Scope scope$) =>
    () => AlignmentDirectional.bottomEnd;
Function _AlignmentDirectional__$(m.Scope scope$) => (
      double start,
      double y,
    ) {
      return AlignmentDirectional(
        start,
        y,
      );
    };
Function _AlignmentDirectional_add$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    target$.add;
Function _AlignmentDirectional_minus$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    (AlignmentDirectional other$) => target$ - other$;
Function _AlignmentDirectional_plus$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    (AlignmentDirectional other$) => target$ + other$;
Function _AlignmentDirectional_unary_minus$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    () => -target$;
Function _AlignmentDirectional_times$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    (double other$) => target$ * other$;
Function _AlignmentDirectional_over$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    (double other$) => target$ / other$;
Function _AlignmentDirectional_division$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    (double other$) => target$ ~/ other$;
Function _AlignmentDirectional_surplus$$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    (double other$) => target$ % other$;
Function _AlignmentDirectional_lerp$(m.Scope scope$) =>
    AlignmentDirectional.lerp;
Function _AlignmentDirectional_resolve$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    target$.resolve;
Function _AlignmentDirectional_toString$(
  m.Scope scope$,
  AlignmentDirectional target$,
) =>
    target$.toString;
Function TextAlignVertical_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextAlignVertical;
Function TextAlignVertical_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextAlignVertical;
Function _TextAlignVertical_y$(
  m.Scope scope$,
  TextAlignVertical target$,
) =>
    () {
      return target$.y;
    };
Function _TextAlignVertical_top$(m.Scope scope$) => () => TextAlignVertical.top;
Function _TextAlignVertical_center$(m.Scope scope$) =>
    () => TextAlignVertical.center;
Function _TextAlignVertical_bottom$(m.Scope scope$) =>
    () => TextAlignVertical.bottom;
Function _TextAlignVertical__$(m.Scope scope$) => ({required double y}) {
      return TextAlignVertical(y: y);
    };
Function _TextAlignVertical_toString$(
  m.Scope scope$,
  TextAlignVertical target$,
) =>
    target$.toString;
