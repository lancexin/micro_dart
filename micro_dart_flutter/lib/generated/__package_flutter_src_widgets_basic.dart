// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/basic.dart';
import 'dart:math';
import 'dart:ui' show Image, ImageFilter, TextHeightBehavior;
import 'package:flutter/animation.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/debug.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/localizations.dart';
import 'package:flutter/src/widgets/visibility.dart';
import 'package:flutter/src/widgets/widget_span.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/basic.dart',
  {
    'Directionality.': _Directionality__$,
    'Directionality.of': _Directionality_of$,
    'Directionality.maybeOf': _Directionality_maybeOf$,
    'Opacity.': _Opacity__$,
    'ShaderMask.': _ShaderMask__$,
    'BackdropFilter.': _BackdropFilter__$,
    'CustomPaint.': _CustomPaint__$,
    'ClipRect.': _ClipRect__$,
    'ClipRRect.': _ClipRRect__$,
    'ClipOval.': _ClipOval__$,
    'ClipPath.': _ClipPath__$,
    'ClipPath.shape': _ClipPath_shape$,
    'PhysicalModel.': _PhysicalModel__$,
    'PhysicalShape.': _PhysicalShape__$,
    'Transform.': _Transform__$,
    'Transform.rotate': _Transform_rotate_$,
    'Transform.translate': _Transform_translate_$,
    'Transform.scale': _Transform_scale_$,
    'Transform.flip': _Transform_flip_$,
    'CompositedTransformTarget.': _CompositedTransformTarget__$,
    'CompositedTransformFollower.': _CompositedTransformFollower__$,
    'FittedBox.': _FittedBox__$,
    'FractionalTranslation.': _FractionalTranslation__$,
    'RotatedBox.': _RotatedBox__$,
    'Padding.': _Padding__$,
    'Align.': _Align__$,
    'Center.': _Center__$,
    'CustomSingleChildLayout.': _CustomSingleChildLayout__$,
    'LayoutId.': _LayoutId__$,
    'CustomMultiChildLayout.': _CustomMultiChildLayout__$,
    'SizedBox.': _SizedBox__$,
    'SizedBox.expand': _SizedBox_expand_$,
    'SizedBox.shrink': _SizedBox_shrink_$,
    'SizedBox.fromSize': _SizedBox_fromSize_$,
    'SizedBox.square': _SizedBox_square_$,
    'ConstrainedBox.': _ConstrainedBox__$,
    'ConstraintsTransformBox.': _ConstraintsTransformBox__$,
    'ConstraintsTransformBox.unmodified': _ConstraintsTransformBox_unmodified$,
    'ConstraintsTransformBox.unconstrained':
        _ConstraintsTransformBox_unconstrained$,
    'ConstraintsTransformBox.widthUnconstrained':
        _ConstraintsTransformBox_widthUnconstrained$,
    'ConstraintsTransformBox.heightUnconstrained':
        _ConstraintsTransformBox_heightUnconstrained$,
    'ConstraintsTransformBox.maxHeightUnconstrained':
        _ConstraintsTransformBox_maxHeightUnconstrained$,
    'ConstraintsTransformBox.maxWidthUnconstrained':
        _ConstraintsTransformBox_maxWidthUnconstrained$,
    'ConstraintsTransformBox.maxUnconstrained':
        _ConstraintsTransformBox_maxUnconstrained$,
    'UnconstrainedBox.': _UnconstrainedBox__$,
    'FractionallySizedBox.': _FractionallySizedBox__$,
    'LimitedBox.': _LimitedBox__$,
    'OverflowBox.': _OverflowBox__$,
    'SizedOverflowBox.': _SizedOverflowBox__$,
    'Offstage.': _Offstage__$,
    'AspectRatio.': _AspectRatio__$,
    'IntrinsicWidth.': _IntrinsicWidth__$,
    'IntrinsicHeight.': _IntrinsicHeight__$,
    'Baseline.': _Baseline__$,
    'SliverToBoxAdapter.': _SliverToBoxAdapter__$,
    'SliverPadding.': _SliverPadding__$,
    'ListBody.': _ListBody__$,
    'Stack.': _Stack__$,
    'IndexedStack.': _IndexedStack__$,
    'Positioned.': _Positioned__$,
    'Positioned.fromRect': _Positioned_fromRect_$,
    'Positioned.fromRelativeRect': _Positioned_fromRelativeRect_$,
    'Positioned.fill': _Positioned_fill_$,
    'Positioned.directional': _Positioned_directional_$,
    'PositionedDirectional.': _PositionedDirectional__$,
    'Flex.': _Flex__$,
    'Row.': _Row__$,
    'Column.': _Column__$,
    'Flexible.': _Flexible__$,
    'Expanded.': _Expanded__$,
    'Wrap.': _Wrap__$,
    'Flow.': _Flow__$,
    'Flow.unwrapped': _Flow_unwrapped_$,
    'RichText.': _RichText__$,
    'RawImage.': _RawImage__$,
    'DefaultAssetBundle.': _DefaultAssetBundle__$,
    'DefaultAssetBundle.of': _DefaultAssetBundle_of$,
    'WidgetToRenderBoxAdapter.': _WidgetToRenderBoxAdapter__$,
    'Listener.': _Listener__$,
    'MouseRegion.': _MouseRegion__$,
    'RepaintBoundary.': _RepaintBoundary__$,
    'RepaintBoundary.wrap': _RepaintBoundary_wrap_$,
    'RepaintBoundary.wrapAll': _RepaintBoundary_wrapAll$,
    'IgnorePointer.': _IgnorePointer__$,
    'AbsorbPointer.': _AbsorbPointer__$,
    'MetaData.': _MetaData__$,
    'Semantics.': _Semantics__$,
    'Semantics.fromProperties': _Semantics_fromProperties_$,
    'MergeSemantics.': _MergeSemantics__$,
    'BlockSemantics.': _BlockSemantics__$,
    'ExcludeSemantics.': _ExcludeSemantics__$,
    'IndexedSemantics.': _IndexedSemantics__$,
    'KeyedSubtree.': _KeyedSubtree__$,
    'KeyedSubtree.wrap': _KeyedSubtree_wrap_$,
    'KeyedSubtree.ensureUniqueKeysForList':
        _KeyedSubtree_ensureUniqueKeysForList$,
    'Builder.': _Builder__$,
    'StatefulBuilder.': _StatefulBuilder__$,
    'ColoredBox.': _ColoredBox__$,
    'getAxisDirectionFromAxisReverseAndDirectionality':
        _getAxisDirectionFromAxisReverseAndDirectionality$,
  },
  {},
  {
    'Directionality': m.ClassMirror(
      'Directionality',
      {
        '#as': Directionality_as$,
        '#is': Directionality_is$,
        'textDirection': _Directionality_textDirection$,
        'updateShouldNotify': _Directionality_updateShouldNotify$,
        'debugFillProperties': _Directionality_debugFillProperties$,
      },
      {},
    ),
    'Opacity': m.ClassMirror(
      'Opacity',
      {
        '#as': Opacity_as$,
        '#is': Opacity_is$,
        'opacity': _Opacity_opacity$,
        'alwaysIncludeSemantics': _Opacity_alwaysIncludeSemantics$,
        'createRenderObject': _Opacity_createRenderObject$,
        'updateRenderObject': _Opacity_updateRenderObject$,
        'debugFillProperties': _Opacity_debugFillProperties$,
      },
      {},
    ),
    'ShaderMask': m.ClassMirror(
      'ShaderMask',
      {
        '#as': ShaderMask_as$,
        '#is': ShaderMask_is$,
        'shaderCallback': _ShaderMask_shaderCallback$,
        'blendMode': _ShaderMask_blendMode$,
        'createRenderObject': _ShaderMask_createRenderObject$,
        'updateRenderObject': _ShaderMask_updateRenderObject$,
      },
      {},
    ),
    'BackdropFilter': m.ClassMirror(
      'BackdropFilter',
      {
        '#as': BackdropFilter_as$,
        '#is': BackdropFilter_is$,
        'filter': _BackdropFilter_filter$,
        'blendMode': _BackdropFilter_blendMode$,
        'createRenderObject': _BackdropFilter_createRenderObject$,
        'updateRenderObject': _BackdropFilter_updateRenderObject$,
      },
      {},
    ),
    'CustomPaint': m.ClassMirror(
      'CustomPaint',
      {
        '#as': CustomPaint_as$,
        '#is': CustomPaint_is$,
        'painter': _CustomPaint_painter$,
        'foregroundPainter': _CustomPaint_foregroundPainter$,
        'size': _CustomPaint_size$,
        'isComplex': _CustomPaint_isComplex$,
        'willChange': _CustomPaint_willChange$,
        'createRenderObject': _CustomPaint_createRenderObject$,
        'updateRenderObject': _CustomPaint_updateRenderObject$,
        'didUnmountRenderObject': _CustomPaint_didUnmountRenderObject$,
      },
      {},
    ),
    'ClipRect': m.ClassMirror(
      'ClipRect',
      {
        '#as': ClipRect_as$,
        '#is': ClipRect_is$,
        'clipper': _ClipRect_clipper$,
        'clipBehavior': _ClipRect_clipBehavior$,
        'createRenderObject': _ClipRect_createRenderObject$,
        'updateRenderObject': _ClipRect_updateRenderObject$,
        'didUnmountRenderObject': _ClipRect_didUnmountRenderObject$,
        'debugFillProperties': _ClipRect_debugFillProperties$,
      },
      {},
    ),
    'ClipRRect': m.ClassMirror(
      'ClipRRect',
      {
        '#as': ClipRRect_as$,
        '#is': ClipRRect_is$,
        'borderRadius': _ClipRRect_borderRadius$,
        'clipper': _ClipRRect_clipper$,
        'clipBehavior': _ClipRRect_clipBehavior$,
        'createRenderObject': _ClipRRect_createRenderObject$,
        'updateRenderObject': _ClipRRect_updateRenderObject$,
        'debugFillProperties': _ClipRRect_debugFillProperties$,
      },
      {},
    ),
    'ClipOval': m.ClassMirror(
      'ClipOval',
      {
        '#as': ClipOval_as$,
        '#is': ClipOval_is$,
        'clipper': _ClipOval_clipper$,
        'clipBehavior': _ClipOval_clipBehavior$,
        'createRenderObject': _ClipOval_createRenderObject$,
        'updateRenderObject': _ClipOval_updateRenderObject$,
        'didUnmountRenderObject': _ClipOval_didUnmountRenderObject$,
        'debugFillProperties': _ClipOval_debugFillProperties$,
      },
      {},
    ),
    'ClipPath': m.ClassMirror(
      'ClipPath',
      {
        '#as': ClipPath_as$,
        '#is': ClipPath_is$,
        'clipper': _ClipPath_clipper$,
        'clipBehavior': _ClipPath_clipBehavior$,
        'createRenderObject': _ClipPath_createRenderObject$,
        'updateRenderObject': _ClipPath_updateRenderObject$,
        'didUnmountRenderObject': _ClipPath_didUnmountRenderObject$,
        'debugFillProperties': _ClipPath_debugFillProperties$,
      },
      {},
    ),
    'PhysicalModel': m.ClassMirror(
      'PhysicalModel',
      {
        '#as': PhysicalModel_as$,
        '#is': PhysicalModel_is$,
        'shape': _PhysicalModel_shape$,
        'clipBehavior': _PhysicalModel_clipBehavior$,
        'borderRadius': _PhysicalModel_borderRadius$,
        'elevation': _PhysicalModel_elevation$,
        'color': _PhysicalModel_color$,
        'shadowColor': _PhysicalModel_shadowColor$,
        'createRenderObject': _PhysicalModel_createRenderObject$,
        'updateRenderObject': _PhysicalModel_updateRenderObject$,
        'debugFillProperties': _PhysicalModel_debugFillProperties$,
      },
      {},
    ),
    'PhysicalShape': m.ClassMirror(
      'PhysicalShape',
      {
        '#as': PhysicalShape_as$,
        '#is': PhysicalShape_is$,
        'clipper': _PhysicalShape_clipper$,
        'clipBehavior': _PhysicalShape_clipBehavior$,
        'elevation': _PhysicalShape_elevation$,
        'color': _PhysicalShape_color$,
        'shadowColor': _PhysicalShape_shadowColor$,
        'createRenderObject': _PhysicalShape_createRenderObject$,
        'updateRenderObject': _PhysicalShape_updateRenderObject$,
        'debugFillProperties': _PhysicalShape_debugFillProperties$,
      },
      {},
    ),
    'Transform': m.ClassMirror(
      'Transform',
      {
        '#as': Transform_as$,
        '#is': Transform_is$,
        'transform': _Transform_transform$,
        'origin': _Transform_origin$,
        'alignment': _Transform_alignment$,
        'transformHitTests': _Transform_transformHitTests$,
        'filterQuality': _Transform_filterQuality$,
        'createRenderObject': _Transform_createRenderObject$,
        'updateRenderObject': _Transform_updateRenderObject$,
      },
      {},
    ),
    'CompositedTransformTarget': m.ClassMirror(
      'CompositedTransformTarget',
      {
        '#as': CompositedTransformTarget_as$,
        '#is': CompositedTransformTarget_is$,
        'link': _CompositedTransformTarget_link$,
        'createRenderObject': _CompositedTransformTarget_createRenderObject$,
        'updateRenderObject': _CompositedTransformTarget_updateRenderObject$,
      },
      {},
    ),
    'CompositedTransformFollower': m.ClassMirror(
      'CompositedTransformFollower',
      {
        '#as': CompositedTransformFollower_as$,
        '#is': CompositedTransformFollower_is$,
        'link': _CompositedTransformFollower_link$,
        'showWhenUnlinked': _CompositedTransformFollower_showWhenUnlinked$,
        'targetAnchor': _CompositedTransformFollower_targetAnchor$,
        'followerAnchor': _CompositedTransformFollower_followerAnchor$,
        'offset': _CompositedTransformFollower_offset$,
        'createRenderObject': _CompositedTransformFollower_createRenderObject$,
        'updateRenderObject': _CompositedTransformFollower_updateRenderObject$,
      },
      {},
    ),
    'FittedBox': m.ClassMirror(
      'FittedBox',
      {
        '#as': FittedBox_as$,
        '#is': FittedBox_is$,
        'fit': _FittedBox_fit$,
        'alignment': _FittedBox_alignment$,
        'clipBehavior': _FittedBox_clipBehavior$,
        'createRenderObject': _FittedBox_createRenderObject$,
        'updateRenderObject': _FittedBox_updateRenderObject$,
        'debugFillProperties': _FittedBox_debugFillProperties$,
      },
      {},
    ),
    'FractionalTranslation': m.ClassMirror(
      'FractionalTranslation',
      {
        '#as': FractionalTranslation_as$,
        '#is': FractionalTranslation_is$,
        'translation': _FractionalTranslation_translation$,
        'transformHitTests': _FractionalTranslation_transformHitTests$,
        'createRenderObject': _FractionalTranslation_createRenderObject$,
        'updateRenderObject': _FractionalTranslation_updateRenderObject$,
      },
      {},
    ),
    'RotatedBox': m.ClassMirror(
      'RotatedBox',
      {
        '#as': RotatedBox_as$,
        '#is': RotatedBox_is$,
        'quarterTurns': _RotatedBox_quarterTurns$,
        'createRenderObject': _RotatedBox_createRenderObject$,
        'updateRenderObject': _RotatedBox_updateRenderObject$,
      },
      {},
    ),
    'Padding': m.ClassMirror(
      'Padding',
      {
        '#as': Padding_as$,
        '#is': Padding_is$,
        'padding': _Padding_padding$,
        'createRenderObject': _Padding_createRenderObject$,
        'updateRenderObject': _Padding_updateRenderObject$,
        'debugFillProperties': _Padding_debugFillProperties$,
      },
      {},
    ),
    'Align': m.ClassMirror(
      'Align',
      {
        '#as': Align_as$,
        '#is': Align_is$,
        'alignment': _Align_alignment$,
        'widthFactor': _Align_widthFactor$,
        'heightFactor': _Align_heightFactor$,
        'createRenderObject': _Align_createRenderObject$,
        'updateRenderObject': _Align_updateRenderObject$,
        'debugFillProperties': _Align_debugFillProperties$,
      },
      {},
    ),
    'Center': m.ClassMirror(
      'Center',
      {
        '#as': Center_as$,
        '#is': Center_is$,
      },
      {},
    ),
    'CustomSingleChildLayout': m.ClassMirror(
      'CustomSingleChildLayout',
      {
        '#as': CustomSingleChildLayout_as$,
        '#is': CustomSingleChildLayout_is$,
        'delegate': _CustomSingleChildLayout_delegate$,
        'createRenderObject': _CustomSingleChildLayout_createRenderObject$,
        'updateRenderObject': _CustomSingleChildLayout_updateRenderObject$,
      },
      {},
    ),
    'LayoutId': m.ClassMirror(
      'LayoutId',
      {
        '#as': LayoutId_as$,
        '#is': LayoutId_is$,
        'id': _LayoutId_id$,
        'debugTypicalAncestorWidgetClass':
            _LayoutId_debugTypicalAncestorWidgetClass$,
        'applyParentData': _LayoutId_applyParentData$,
        'debugFillProperties': _LayoutId_debugFillProperties$,
      },
      {},
    ),
    'CustomMultiChildLayout': m.ClassMirror(
      'CustomMultiChildLayout',
      {
        '#as': CustomMultiChildLayout_as$,
        '#is': CustomMultiChildLayout_is$,
        'delegate': _CustomMultiChildLayout_delegate$,
        'createRenderObject': _CustomMultiChildLayout_createRenderObject$,
        'updateRenderObject': _CustomMultiChildLayout_updateRenderObject$,
      },
      {},
    ),
    'SizedBox': m.ClassMirror(
      'SizedBox',
      {
        '#as': SizedBox_as$,
        '#is': SizedBox_is$,
        'width': _SizedBox_width$,
        'height': _SizedBox_height$,
        'createRenderObject': _SizedBox_createRenderObject$,
        'updateRenderObject': _SizedBox_updateRenderObject$,
        'toStringShort': _SizedBox_toStringShort$,
        'debugFillProperties': _SizedBox_debugFillProperties$,
      },
      {},
    ),
    'ConstrainedBox': m.ClassMirror(
      'ConstrainedBox',
      {
        '#as': ConstrainedBox_as$,
        '#is': ConstrainedBox_is$,
        'constraints': _ConstrainedBox_constraints$,
        'createRenderObject': _ConstrainedBox_createRenderObject$,
        'updateRenderObject': _ConstrainedBox_updateRenderObject$,
        'debugFillProperties': _ConstrainedBox_debugFillProperties$,
      },
      {},
    ),
    'ConstraintsTransformBox': m.ClassMirror(
      'ConstraintsTransformBox',
      {
        '#as': ConstraintsTransformBox_as$,
        '#is': ConstraintsTransformBox_is$,
        'textDirection': _ConstraintsTransformBox_textDirection$,
        'alignment': _ConstraintsTransformBox_alignment$,
        'constraintsTransform': _ConstraintsTransformBox_constraintsTransform$,
        'clipBehavior': _ConstraintsTransformBox_clipBehavior$,
        'createRenderObject': _ConstraintsTransformBox_createRenderObject$,
        'updateRenderObject': _ConstraintsTransformBox_updateRenderObject$,
        'debugFillProperties': _ConstraintsTransformBox_debugFillProperties$,
      },
      {},
    ),
    'UnconstrainedBox': m.ClassMirror(
      'UnconstrainedBox',
      {
        '#as': UnconstrainedBox_as$,
        '#is': UnconstrainedBox_is$,
        'textDirection': _UnconstrainedBox_textDirection$,
        'alignment': _UnconstrainedBox_alignment$,
        'constrainedAxis': _UnconstrainedBox_constrainedAxis$,
        'clipBehavior': _UnconstrainedBox_clipBehavior$,
        'child': _UnconstrainedBox_child$,
        'build': _UnconstrainedBox_build$,
        'debugFillProperties': _UnconstrainedBox_debugFillProperties$,
      },
      {},
    ),
    'FractionallySizedBox': m.ClassMirror(
      'FractionallySizedBox',
      {
        '#as': FractionallySizedBox_as$,
        '#is': FractionallySizedBox_is$,
        'widthFactor': _FractionallySizedBox_widthFactor$,
        'heightFactor': _FractionallySizedBox_heightFactor$,
        'alignment': _FractionallySizedBox_alignment$,
        'createRenderObject': _FractionallySizedBox_createRenderObject$,
        'updateRenderObject': _FractionallySizedBox_updateRenderObject$,
        'debugFillProperties': _FractionallySizedBox_debugFillProperties$,
      },
      {},
    ),
    'LimitedBox': m.ClassMirror(
      'LimitedBox',
      {
        '#as': LimitedBox_as$,
        '#is': LimitedBox_is$,
        'maxWidth': _LimitedBox_maxWidth$,
        'maxHeight': _LimitedBox_maxHeight$,
        'createRenderObject': _LimitedBox_createRenderObject$,
        'updateRenderObject': _LimitedBox_updateRenderObject$,
        'debugFillProperties': _LimitedBox_debugFillProperties$,
      },
      {},
    ),
    'OverflowBox': m.ClassMirror(
      'OverflowBox',
      {
        '#as': OverflowBox_as$,
        '#is': OverflowBox_is$,
        'alignment': _OverflowBox_alignment$,
        'minWidth': _OverflowBox_minWidth$,
        'maxWidth': _OverflowBox_maxWidth$,
        'minHeight': _OverflowBox_minHeight$,
        'maxHeight': _OverflowBox_maxHeight$,
        'createRenderObject': _OverflowBox_createRenderObject$,
        'updateRenderObject': _OverflowBox_updateRenderObject$,
        'debugFillProperties': _OverflowBox_debugFillProperties$,
      },
      {},
    ),
    'SizedOverflowBox': m.ClassMirror(
      'SizedOverflowBox',
      {
        '#as': SizedOverflowBox_as$,
        '#is': SizedOverflowBox_is$,
        'alignment': _SizedOverflowBox_alignment$,
        'size': _SizedOverflowBox_size$,
        'createRenderObject': _SizedOverflowBox_createRenderObject$,
        'updateRenderObject': _SizedOverflowBox_updateRenderObject$,
        'debugFillProperties': _SizedOverflowBox_debugFillProperties$,
      },
      {},
    ),
    'Offstage': m.ClassMirror(
      'Offstage',
      {
        '#as': Offstage_as$,
        '#is': Offstage_is$,
        'offstage': _Offstage_offstage$,
        'createRenderObject': _Offstage_createRenderObject$,
        'updateRenderObject': _Offstage_updateRenderObject$,
        'debugFillProperties': _Offstage_debugFillProperties$,
        'createElement': _Offstage_createElement$,
      },
      {},
    ),
    'AspectRatio': m.ClassMirror(
      'AspectRatio',
      {
        '#as': AspectRatio_as$,
        '#is': AspectRatio_is$,
        'aspectRatio': _AspectRatio_aspectRatio$,
        'createRenderObject': _AspectRatio_createRenderObject$,
        'updateRenderObject': _AspectRatio_updateRenderObject$,
        'debugFillProperties': _AspectRatio_debugFillProperties$,
      },
      {},
    ),
    'IntrinsicWidth': m.ClassMirror(
      'IntrinsicWidth',
      {
        '#as': IntrinsicWidth_as$,
        '#is': IntrinsicWidth_is$,
        'stepWidth': _IntrinsicWidth_stepWidth$,
        'stepHeight': _IntrinsicWidth_stepHeight$,
        'createRenderObject': _IntrinsicWidth_createRenderObject$,
        'updateRenderObject': _IntrinsicWidth_updateRenderObject$,
      },
      {},
    ),
    'IntrinsicHeight': m.ClassMirror(
      'IntrinsicHeight',
      {
        '#as': IntrinsicHeight_as$,
        '#is': IntrinsicHeight_is$,
        'createRenderObject': _IntrinsicHeight_createRenderObject$,
      },
      {},
    ),
    'Baseline': m.ClassMirror(
      'Baseline',
      {
        '#as': Baseline_as$,
        '#is': Baseline_is$,
        'baseline': _Baseline_baseline$,
        'baselineType': _Baseline_baselineType$,
        'createRenderObject': _Baseline_createRenderObject$,
        'updateRenderObject': _Baseline_updateRenderObject$,
      },
      {},
    ),
    'SliverToBoxAdapter': m.ClassMirror(
      'SliverToBoxAdapter',
      {
        '#as': SliverToBoxAdapter_as$,
        '#is': SliverToBoxAdapter_is$,
        'createRenderObject': _SliverToBoxAdapter_createRenderObject$,
      },
      {},
    ),
    'SliverPadding': m.ClassMirror(
      'SliverPadding',
      {
        '#as': SliverPadding_as$,
        '#is': SliverPadding_is$,
        'padding': _SliverPadding_padding$,
        'createRenderObject': _SliverPadding_createRenderObject$,
        'updateRenderObject': _SliverPadding_updateRenderObject$,
        'debugFillProperties': _SliverPadding_debugFillProperties$,
      },
      {},
    ),
    'ListBody': m.ClassMirror(
      'ListBody',
      {
        '#as': ListBody_as$,
        '#is': ListBody_is$,
        'mainAxis': _ListBody_mainAxis$,
        'reverse': _ListBody_reverse$,
        'createRenderObject': _ListBody_createRenderObject$,
        'updateRenderObject': _ListBody_updateRenderObject$,
      },
      {},
    ),
    'Stack': m.ClassMirror(
      'Stack',
      {
        '#as': Stack_as$,
        '#is': Stack_is$,
        'alignment': _Stack_alignment$,
        'textDirection': _Stack_textDirection$,
        'fit': _Stack_fit$,
        'clipBehavior': _Stack_clipBehavior$,
        'createRenderObject': _Stack_createRenderObject$,
        'updateRenderObject': _Stack_updateRenderObject$,
        'debugFillProperties': _Stack_debugFillProperties$,
      },
      {},
    ),
    'IndexedStack': m.ClassMirror(
      'IndexedStack',
      {
        '#as': IndexedStack_as$,
        '#is': IndexedStack_is$,
        'alignment': _IndexedStack_alignment$,
        'textDirection': _IndexedStack_textDirection$,
        'clipBehavior': _IndexedStack_clipBehavior$,
        'sizing': _IndexedStack_sizing$,
        'index': _IndexedStack_index$,
        'children': _IndexedStack_children$,
        'build': _IndexedStack_build$,
      },
      {},
    ),
    'Positioned': m.ClassMirror(
      'Positioned',
      {
        '#as': Positioned_as$,
        '#is': Positioned_is$,
        'left': _Positioned_left$,
        'top': _Positioned_top$,
        'right': _Positioned_right$,
        'bottom': _Positioned_bottom$,
        'width': _Positioned_width$,
        'height': _Positioned_height$,
        'debugTypicalAncestorWidgetClass':
            _Positioned_debugTypicalAncestorWidgetClass$,
        'applyParentData': _Positioned_applyParentData$,
        'debugFillProperties': _Positioned_debugFillProperties$,
      },
      {},
    ),
    'PositionedDirectional': m.ClassMirror(
      'PositionedDirectional',
      {
        '#as': PositionedDirectional_as$,
        '#is': PositionedDirectional_is$,
        'start': _PositionedDirectional_start$,
        'top': _PositionedDirectional_top$,
        'end': _PositionedDirectional_end$,
        'bottom': _PositionedDirectional_bottom$,
        'width': _PositionedDirectional_width$,
        'height': _PositionedDirectional_height$,
        'child': _PositionedDirectional_child$,
        'build': _PositionedDirectional_build$,
      },
      {},
    ),
    'Flex': m.ClassMirror(
      'Flex',
      {
        '#as': Flex_as$,
        '#is': Flex_is$,
        'direction': _Flex_direction$,
        'mainAxisAlignment': _Flex_mainAxisAlignment$,
        'mainAxisSize': _Flex_mainAxisSize$,
        'crossAxisAlignment': _Flex_crossAxisAlignment$,
        'textDirection': _Flex_textDirection$,
        'verticalDirection': _Flex_verticalDirection$,
        'textBaseline': _Flex_textBaseline$,
        'clipBehavior': _Flex_clipBehavior$,
        'getEffectiveTextDirection': _Flex_getEffectiveTextDirection$,
        'createRenderObject': _Flex_createRenderObject$,
        'updateRenderObject': _Flex_updateRenderObject$,
        'debugFillProperties': _Flex_debugFillProperties$,
      },
      {},
    ),
    'Row': m.ClassMirror(
      'Row',
      {
        '#as': Row_as$,
        '#is': Row_is$,
      },
      {},
    ),
    'Column': m.ClassMirror(
      'Column',
      {
        '#as': Column_as$,
        '#is': Column_is$,
      },
      {},
    ),
    'Flexible': m.ClassMirror(
      'Flexible',
      {
        '#as': Flexible_as$,
        '#is': Flexible_is$,
        'flex': _Flexible_flex$,
        'fit': _Flexible_fit$,
        'debugTypicalAncestorWidgetClass':
            _Flexible_debugTypicalAncestorWidgetClass$,
        'applyParentData': _Flexible_applyParentData$,
        'debugFillProperties': _Flexible_debugFillProperties$,
      },
      {},
    ),
    'Expanded': m.ClassMirror(
      'Expanded',
      {
        '#as': Expanded_as$,
        '#is': Expanded_is$,
      },
      {},
    ),
    'Wrap': m.ClassMirror(
      'Wrap',
      {
        '#as': Wrap_as$,
        '#is': Wrap_is$,
        'direction': _Wrap_direction$,
        'alignment': _Wrap_alignment$,
        'spacing': _Wrap_spacing$,
        'runAlignment': _Wrap_runAlignment$,
        'runSpacing': _Wrap_runSpacing$,
        'crossAxisAlignment': _Wrap_crossAxisAlignment$,
        'textDirection': _Wrap_textDirection$,
        'verticalDirection': _Wrap_verticalDirection$,
        'clipBehavior': _Wrap_clipBehavior$,
        'createRenderObject': _Wrap_createRenderObject$,
        'updateRenderObject': _Wrap_updateRenderObject$,
        'debugFillProperties': _Wrap_debugFillProperties$,
      },
      {},
    ),
    'Flow': m.ClassMirror(
      'Flow',
      {
        '#as': Flow_as$,
        '#is': Flow_is$,
        'delegate': _Flow_delegate$,
        'clipBehavior': _Flow_clipBehavior$,
        'createRenderObject': _Flow_createRenderObject$,
        'updateRenderObject': _Flow_updateRenderObject$,
      },
      {},
    ),
    'RichText': m.ClassMirror(
      'RichText',
      {
        '#as': RichText_as$,
        '#is': RichText_is$,
        'text': _RichText_text$,
        'textAlign': _RichText_textAlign$,
        'textDirection': _RichText_textDirection$,
        'softWrap': _RichText_softWrap$,
        'overflow': _RichText_overflow$,
        'textScaleFactor': _RichText_textScaleFactor$,
        'maxLines': _RichText_maxLines$,
        'locale': _RichText_locale$,
        'strutStyle': _RichText_strutStyle$,
        'textWidthBasis': _RichText_textWidthBasis$,
        'textHeightBehavior': _RichText_textHeightBehavior$,
        'selectionRegistrar': _RichText_selectionRegistrar$,
        'selectionColor': _RichText_selectionColor$,
        'createRenderObject': _RichText_createRenderObject$,
        'updateRenderObject': _RichText_updateRenderObject$,
        'debugFillProperties': _RichText_debugFillProperties$,
      },
      {},
    ),
    'RawImage': m.ClassMirror(
      'RawImage',
      {
        '#as': RawImage_as$,
        '#is': RawImage_is$,
        'image': _RawImage_image$,
        'debugImageLabel': _RawImage_debugImageLabel$,
        'width': _RawImage_width$,
        'height': _RawImage_height$,
        'scale': _RawImage_scale$,
        'color': _RawImage_color$,
        'opacity': _RawImage_opacity$,
        'filterQuality': _RawImage_filterQuality$,
        'colorBlendMode': _RawImage_colorBlendMode$,
        'fit': _RawImage_fit$,
        'alignment': _RawImage_alignment$,
        'repeat': _RawImage_repeat$,
        'centerSlice': _RawImage_centerSlice$,
        'matchTextDirection': _RawImage_matchTextDirection$,
        'invertColors': _RawImage_invertColors$,
        'isAntiAlias': _RawImage_isAntiAlias$,
        'createRenderObject': _RawImage_createRenderObject$,
        'updateRenderObject': _RawImage_updateRenderObject$,
        'didUnmountRenderObject': _RawImage_didUnmountRenderObject$,
        'debugFillProperties': _RawImage_debugFillProperties$,
      },
      {},
    ),
    'DefaultAssetBundle': m.ClassMirror(
      'DefaultAssetBundle',
      {
        '#as': DefaultAssetBundle_as$,
        '#is': DefaultAssetBundle_is$,
        'bundle': _DefaultAssetBundle_bundle$,
        'updateShouldNotify': _DefaultAssetBundle_updateShouldNotify$,
      },
      {},
    ),
    'WidgetToRenderBoxAdapter': m.ClassMirror(
      'WidgetToRenderBoxAdapter',
      {
        '#as': WidgetToRenderBoxAdapter_as$,
        '#is': WidgetToRenderBoxAdapter_is$,
        'renderBox': _WidgetToRenderBoxAdapter_renderBox$,
        'onBuild': _WidgetToRenderBoxAdapter_onBuild$,
        'onUnmount': _WidgetToRenderBoxAdapter_onUnmount$,
        'createRenderObject': _WidgetToRenderBoxAdapter_createRenderObject$,
        'updateRenderObject': _WidgetToRenderBoxAdapter_updateRenderObject$,
        'didUnmountRenderObject':
            _WidgetToRenderBoxAdapter_didUnmountRenderObject$,
      },
      {},
    ),
    'Listener': m.ClassMirror(
      'Listener',
      {
        '#as': Listener_as$,
        '#is': Listener_is$,
        'onPointerDown': _Listener_onPointerDown$,
        'onPointerMove': _Listener_onPointerMove$,
        'onPointerUp': _Listener_onPointerUp$,
        'onPointerHover': _Listener_onPointerHover$,
        'onPointerCancel': _Listener_onPointerCancel$,
        'onPointerPanZoomStart': _Listener_onPointerPanZoomStart$,
        'onPointerPanZoomUpdate': _Listener_onPointerPanZoomUpdate$,
        'onPointerPanZoomEnd': _Listener_onPointerPanZoomEnd$,
        'onPointerSignal': _Listener_onPointerSignal$,
        'behavior': _Listener_behavior$,
        'createRenderObject': _Listener_createRenderObject$,
        'updateRenderObject': _Listener_updateRenderObject$,
        'debugFillProperties': _Listener_debugFillProperties$,
      },
      {},
    ),
    'MouseRegion': m.ClassMirror(
      'MouseRegion',
      {
        '#as': MouseRegion_as$,
        '#is': MouseRegion_is$,
        'onEnter': _MouseRegion_onEnter$,
        'onHover': _MouseRegion_onHover$,
        'onExit': _MouseRegion_onExit$,
        'cursor': _MouseRegion_cursor$,
        'opaque': _MouseRegion_opaque$,
        'hitTestBehavior': _MouseRegion_hitTestBehavior$,
        'createRenderObject': _MouseRegion_createRenderObject$,
        'updateRenderObject': _MouseRegion_updateRenderObject$,
        'debugFillProperties': _MouseRegion_debugFillProperties$,
      },
      {},
    ),
    'RepaintBoundary': m.ClassMirror(
      'RepaintBoundary',
      {
        '#as': RepaintBoundary_as$,
        '#is': RepaintBoundary_is$,
        'createRenderObject': _RepaintBoundary_createRenderObject$,
      },
      {},
    ),
    'IgnorePointer': m.ClassMirror(
      'IgnorePointer',
      {
        '#as': IgnorePointer_as$,
        '#is': IgnorePointer_is$,
        'ignoring': _IgnorePointer_ignoring$,
        'ignoringSemantics': _IgnorePointer_ignoringSemantics$,
        'createRenderObject': _IgnorePointer_createRenderObject$,
        'updateRenderObject': _IgnorePointer_updateRenderObject$,
        'debugFillProperties': _IgnorePointer_debugFillProperties$,
      },
      {},
    ),
    'AbsorbPointer': m.ClassMirror(
      'AbsorbPointer',
      {
        '#as': AbsorbPointer_as$,
        '#is': AbsorbPointer_is$,
        'absorbing': _AbsorbPointer_absorbing$,
        'ignoringSemantics': _AbsorbPointer_ignoringSemantics$,
        'createRenderObject': _AbsorbPointer_createRenderObject$,
        'updateRenderObject': _AbsorbPointer_updateRenderObject$,
        'debugFillProperties': _AbsorbPointer_debugFillProperties$,
      },
      {},
    ),
    'MetaData': m.ClassMirror(
      'MetaData',
      {
        '#as': MetaData_as$,
        '#is': MetaData_is$,
        'metaData': _MetaData_metaData$,
        'behavior': _MetaData_behavior$,
        'createRenderObject': _MetaData_createRenderObject$,
        'updateRenderObject': _MetaData_updateRenderObject$,
        'debugFillProperties': _MetaData_debugFillProperties$,
      },
      {},
    ),
    'Semantics': m.ClassMirror(
      'Semantics',
      {
        '#as': Semantics_as$,
        '#is': Semantics_is$,
        'properties': _Semantics_properties$,
        'container': _Semantics_container$,
        'explicitChildNodes': _Semantics_explicitChildNodes$,
        'excludeSemantics': _Semantics_excludeSemantics$,
        'createRenderObject': _Semantics_createRenderObject$,
        'updateRenderObject': _Semantics_updateRenderObject$,
        'debugFillProperties': _Semantics_debugFillProperties$,
      },
      {},
    ),
    'MergeSemantics': m.ClassMirror(
      'MergeSemantics',
      {
        '#as': MergeSemantics_as$,
        '#is': MergeSemantics_is$,
        'createRenderObject': _MergeSemantics_createRenderObject$,
      },
      {},
    ),
    'BlockSemantics': m.ClassMirror(
      'BlockSemantics',
      {
        '#as': BlockSemantics_as$,
        '#is': BlockSemantics_is$,
        'blocking': _BlockSemantics_blocking$,
        'createRenderObject': _BlockSemantics_createRenderObject$,
        'updateRenderObject': _BlockSemantics_updateRenderObject$,
        'debugFillProperties': _BlockSemantics_debugFillProperties$,
      },
      {},
    ),
    'ExcludeSemantics': m.ClassMirror(
      'ExcludeSemantics',
      {
        '#as': ExcludeSemantics_as$,
        '#is': ExcludeSemantics_is$,
        'excluding': _ExcludeSemantics_excluding$,
        'createRenderObject': _ExcludeSemantics_createRenderObject$,
        'updateRenderObject': _ExcludeSemantics_updateRenderObject$,
        'debugFillProperties': _ExcludeSemantics_debugFillProperties$,
      },
      {},
    ),
    'IndexedSemantics': m.ClassMirror(
      'IndexedSemantics',
      {
        '#as': IndexedSemantics_as$,
        '#is': IndexedSemantics_is$,
        'index': _IndexedSemantics_index$,
        'createRenderObject': _IndexedSemantics_createRenderObject$,
        'updateRenderObject': _IndexedSemantics_updateRenderObject$,
        'debugFillProperties': _IndexedSemantics_debugFillProperties$,
      },
      {},
    ),
    'KeyedSubtree': m.ClassMirror(
      'KeyedSubtree',
      {
        '#as': KeyedSubtree_as$,
        '#is': KeyedSubtree_is$,
        'child': _KeyedSubtree_child$,
        'build': _KeyedSubtree_build$,
      },
      {},
    ),
    'Builder': m.ClassMirror(
      'Builder',
      {
        '#as': Builder_as$,
        '#is': Builder_is$,
        'builder': _Builder_builder$,
        'build': _Builder_build$,
      },
      {},
    ),
    'StatefulBuilder': m.ClassMirror(
      'StatefulBuilder',
      {
        '#as': StatefulBuilder_as$,
        '#is': StatefulBuilder_is$,
        'builder': _StatefulBuilder_builder$,
        'createState': _StatefulBuilder_createState$,
      },
      {},
    ),
    'ColoredBox': m.ClassMirror(
      'ColoredBox',
      {
        '#as': ColoredBox_as$,
        '#is': ColoredBox_is$,
        'color': _ColoredBox_color$,
        'createRenderObject': _ColoredBox_createRenderObject$,
        'updateRenderObject': _ColoredBox_updateRenderObject$,
        'debugFillProperties': _ColoredBox_debugFillProperties$,
      },
      {},
    ),
  },
);
Function Directionality_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Directionality;
Function Directionality_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Directionality;
Function _Directionality_textDirection$(
  m.Scope scope$,
  Directionality target$,
) =>
    () {
      return target$.textDirection;
    };
Function _Directionality__$(m.Scope scope$) => ({
      Key? key,
      required TextDirection textDirection,
      required Widget child,
    }) {
      return Directionality(
        child: child,
        key: key,
        textDirection: textDirection,
      );
    };
Function _Directionality_of$(m.Scope scope$) => Directionality.of;
Function _Directionality_maybeOf$(m.Scope scope$) => Directionality.maybeOf;
Function _Directionality_updateShouldNotify$(
  m.Scope scope$,
  Directionality target$,
) =>
    target$.updateShouldNotify;
Function _Directionality_debugFillProperties$(
  m.Scope scope$,
  Directionality target$,
) =>
    target$.debugFillProperties;
Function Opacity_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Opacity;
Function Opacity_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Opacity;
Function _Opacity_opacity$(
  m.Scope scope$,
  Opacity target$,
) =>
    () {
      return target$.opacity;
    };
Function _Opacity_alwaysIncludeSemantics$(
  m.Scope scope$,
  Opacity target$,
) =>
    () {
      return target$.alwaysIncludeSemantics;
    };
Function _Opacity__$(m.Scope scope$) => ({
      Key? key,
      required double opacity,
      bool? alwaysIncludeSemantics,
      Widget? child,
    }) {
      return Opacity(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        child: child,
        key: key,
        opacity: opacity,
      );
    };
Function _Opacity_createRenderObject$(
  m.Scope scope$,
  Opacity target$,
) =>
    target$.createRenderObject;
Function _Opacity_updateRenderObject$(
  m.Scope scope$,
  Opacity target$,
) =>
    target$.updateRenderObject;
Function _Opacity_debugFillProperties$(
  m.Scope scope$,
  Opacity target$,
) =>
    target$.debugFillProperties;
Function ShaderMask_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ShaderMask;
Function ShaderMask_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ShaderMask;
Function _ShaderMask_shaderCallback$(
  m.Scope scope$,
  ShaderMask target$,
) =>
    () {
      return target$.shaderCallback;
    };
Function _ShaderMask_blendMode$(
  m.Scope scope$,
  ShaderMask target$,
) =>
    () {
      return target$.blendMode;
    };
Function _ShaderMask__$(m.Scope scope$) => ({
      Key? key,
      required m.FunctionPointer shaderCallback,
      BlendMode? blendMode,
      Widget? child,
    }) {
      Shader shaderCallbackProxy(Rect shaderCallback_bounds$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            shaderCallback,
            [shaderCallback_bounds$],
            {},
          );
      return ShaderMask(
        blendMode: blendMode ?? BlendMode.modulate,
        child: child,
        key: key,
        shaderCallback: shaderCallbackProxy,
      );
    };
Function _ShaderMask_createRenderObject$(
  m.Scope scope$,
  ShaderMask target$,
) =>
    target$.createRenderObject;
Function _ShaderMask_updateRenderObject$(
  m.Scope scope$,
  ShaderMask target$,
) =>
    target$.updateRenderObject;
Function BackdropFilter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BackdropFilter;
Function BackdropFilter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BackdropFilter;
Function _BackdropFilter_filter$(
  m.Scope scope$,
  BackdropFilter target$,
) =>
    () {
      return target$.filter;
    };
Function _BackdropFilter_blendMode$(
  m.Scope scope$,
  BackdropFilter target$,
) =>
    () {
      return target$.blendMode;
    };
Function _BackdropFilter__$(m.Scope scope$) => ({
      Key? key,
      required ImageFilter filter,
      Widget? child,
      BlendMode? blendMode,
    }) {
      return BackdropFilter(
        blendMode: blendMode ?? BlendMode.srcOver,
        child: child,
        filter: filter,
        key: key,
      );
    };
Function _BackdropFilter_createRenderObject$(
  m.Scope scope$,
  BackdropFilter target$,
) =>
    target$.createRenderObject;
Function _BackdropFilter_updateRenderObject$(
  m.Scope scope$,
  BackdropFilter target$,
) =>
    target$.updateRenderObject;
Function CustomPaint_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CustomPaint;
Function CustomPaint_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CustomPaint;
Function _CustomPaint_painter$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    () {
      return target$.painter;
    };
Function _CustomPaint_foregroundPainter$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    () {
      return target$.foregroundPainter;
    };
Function _CustomPaint_size$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    () {
      return target$.size;
    };
Function _CustomPaint_isComplex$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    () {
      return target$.isComplex;
    };
Function _CustomPaint_willChange$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    () {
      return target$.willChange;
    };
Function _CustomPaint__$(m.Scope scope$) => ({
      Key? key,
      CustomPainter? painter,
      CustomPainter? foregroundPainter,
      Size? size,
      bool? isComplex,
      bool? willChange,
      Widget? child,
    }) {
      return CustomPaint(
        child: child,
        foregroundPainter: foregroundPainter,
        isComplex: isComplex ?? false,
        key: key,
        painter: painter,
        size: size ?? Size.zero,
        willChange: willChange ?? false,
      );
    };
Function _CustomPaint_createRenderObject$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    target$.createRenderObject;
Function _CustomPaint_updateRenderObject$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    target$.updateRenderObject;
Function _CustomPaint_didUnmountRenderObject$(
  m.Scope scope$,
  CustomPaint target$,
) =>
    target$.didUnmountRenderObject;
Function ClipRect_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ClipRect;
Function ClipRect_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ClipRect;
Function _ClipRect_clipper$(
  m.Scope scope$,
  ClipRect target$,
) =>
    () {
      return target$.clipper;
    };
Function _ClipRect_clipBehavior$(
  m.Scope scope$,
  ClipRect target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _ClipRect__$(m.Scope scope$) => ({
      Key? key,
      CustomClipper<Rect>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipRect(
        child: child,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        clipper: clipper,
        key: key,
      );
    };
Function _ClipRect_createRenderObject$(
  m.Scope scope$,
  ClipRect target$,
) =>
    target$.createRenderObject;
Function _ClipRect_updateRenderObject$(
  m.Scope scope$,
  ClipRect target$,
) =>
    target$.updateRenderObject;
Function _ClipRect_didUnmountRenderObject$(
  m.Scope scope$,
  ClipRect target$,
) =>
    target$.didUnmountRenderObject;
Function _ClipRect_debugFillProperties$(
  m.Scope scope$,
  ClipRect target$,
) =>
    target$.debugFillProperties;
Function ClipRRect_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ClipRRect;
Function ClipRRect_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ClipRRect;
Function _ClipRRect_borderRadius$(
  m.Scope scope$,
  ClipRRect target$,
) =>
    () {
      return target$.borderRadius;
    };
Function _ClipRRect_clipper$(
  m.Scope scope$,
  ClipRRect target$,
) =>
    () {
      return target$.clipper;
    };
Function _ClipRRect_clipBehavior$(
  m.Scope scope$,
  ClipRRect target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _ClipRRect__$(m.Scope scope$) => ({
      Key? key,
      BorderRadiusGeometry? borderRadius,
      CustomClipper<RRect>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipRRect(
        borderRadius: borderRadius ?? BorderRadius.zero,
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
        key: key,
      );
    };
Function _ClipRRect_createRenderObject$(
  m.Scope scope$,
  ClipRRect target$,
) =>
    target$.createRenderObject;
Function _ClipRRect_updateRenderObject$(
  m.Scope scope$,
  ClipRRect target$,
) =>
    target$.updateRenderObject;
Function _ClipRRect_debugFillProperties$(
  m.Scope scope$,
  ClipRRect target$,
) =>
    target$.debugFillProperties;
Function ClipOval_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ClipOval;
Function ClipOval_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ClipOval;
Function _ClipOval_clipper$(
  m.Scope scope$,
  ClipOval target$,
) =>
    () {
      return target$.clipper;
    };
Function _ClipOval_clipBehavior$(
  m.Scope scope$,
  ClipOval target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _ClipOval__$(m.Scope scope$) => ({
      Key? key,
      CustomClipper<Rect>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipOval(
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
        key: key,
      );
    };
Function _ClipOval_createRenderObject$(
  m.Scope scope$,
  ClipOval target$,
) =>
    target$.createRenderObject;
Function _ClipOval_updateRenderObject$(
  m.Scope scope$,
  ClipOval target$,
) =>
    target$.updateRenderObject;
Function _ClipOval_didUnmountRenderObject$(
  m.Scope scope$,
  ClipOval target$,
) =>
    target$.didUnmountRenderObject;
Function _ClipOval_debugFillProperties$(
  m.Scope scope$,
  ClipOval target$,
) =>
    target$.debugFillProperties;
Function ClipPath_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ClipPath;
Function ClipPath_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ClipPath;
Function _ClipPath_clipper$(
  m.Scope scope$,
  ClipPath target$,
) =>
    () {
      return target$.clipper;
    };
Function _ClipPath_clipBehavior$(
  m.Scope scope$,
  ClipPath target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _ClipPath__$(m.Scope scope$) => ({
      Key? key,
      CustomClipper<Path>? clipper,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return ClipPath(
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
        key: key,
      );
    };
Function _ClipPath_shape$(m.Scope scope$) => ClipPath.shape;
Function _ClipPath_createRenderObject$(
  m.Scope scope$,
  ClipPath target$,
) =>
    target$.createRenderObject;
Function _ClipPath_updateRenderObject$(
  m.Scope scope$,
  ClipPath target$,
) =>
    target$.updateRenderObject;
Function _ClipPath_didUnmountRenderObject$(
  m.Scope scope$,
  ClipPath target$,
) =>
    target$.didUnmountRenderObject;
Function _ClipPath_debugFillProperties$(
  m.Scope scope$,
  ClipPath target$,
) =>
    target$.debugFillProperties;
Function PhysicalModel_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PhysicalModel;
Function PhysicalModel_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PhysicalModel;
Function _PhysicalModel_shape$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    () {
      return target$.shape;
    };
Function _PhysicalModel_clipBehavior$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _PhysicalModel_borderRadius$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    () {
      return target$.borderRadius;
    };
Function _PhysicalModel_elevation$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    () {
      return target$.elevation;
    };
Function _PhysicalModel_color$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    () {
      return target$.color;
    };
Function _PhysicalModel_shadowColor$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    () {
      return target$.shadowColor;
    };
Function _PhysicalModel__$(m.Scope scope$) => ({
      Key? key,
      BoxShape? shape,
      Clip? clipBehavior,
      BorderRadius? borderRadius,
      double? elevation,
      required Color color,
      Color? shadowColor,
      Widget? child,
    }) {
      return PhysicalModel(
        borderRadius: borderRadius,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        color: color,
        elevation: elevation ?? 0.0,
        key: key,
        shadowColor: shadowColor ?? const Color(0xFF000000),
        shape: shape ?? BoxShape.rectangle,
      );
    };
Function _PhysicalModel_createRenderObject$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    target$.createRenderObject;
Function _PhysicalModel_updateRenderObject$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    target$.updateRenderObject;
Function _PhysicalModel_debugFillProperties$(
  m.Scope scope$,
  PhysicalModel target$,
) =>
    target$.debugFillProperties;
Function PhysicalShape_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PhysicalShape;
Function PhysicalShape_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PhysicalShape;
Function _PhysicalShape_clipper$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    () {
      return target$.clipper;
    };
Function _PhysicalShape_clipBehavior$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _PhysicalShape_elevation$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    () {
      return target$.elevation;
    };
Function _PhysicalShape_color$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    () {
      return target$.color;
    };
Function _PhysicalShape_shadowColor$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    () {
      return target$.shadowColor;
    };
Function _PhysicalShape__$(m.Scope scope$) => ({
      Key? key,
      required CustomClipper<Path> clipper,
      Clip? clipBehavior,
      double? elevation,
      required Color color,
      Color? shadowColor,
      Widget? child,
    }) {
      return PhysicalShape(
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        clipper: clipper,
        color: color,
        elevation: elevation ?? 0.0,
        key: key,
        shadowColor: shadowColor ?? const Color(0xFF000000),
      );
    };
Function _PhysicalShape_createRenderObject$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    target$.createRenderObject;
Function _PhysicalShape_updateRenderObject$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    target$.updateRenderObject;
Function _PhysicalShape_debugFillProperties$(
  m.Scope scope$,
  PhysicalShape target$,
) =>
    target$.debugFillProperties;
Function Transform_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Transform;
Function Transform_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Transform;
Function _Transform_transform$(
  m.Scope scope$,
  Transform target$,
) =>
    () {
      return target$.transform;
    };
Function _Transform_origin$(
  m.Scope scope$,
  Transform target$,
) =>
    () {
      return target$.origin;
    };
Function _Transform_alignment$(
  m.Scope scope$,
  Transform target$,
) =>
    () {
      return target$.alignment;
    };
Function _Transform_transformHitTests$(
  m.Scope scope$,
  Transform target$,
) =>
    () {
      return target$.transformHitTests;
    };
Function _Transform_filterQuality$(
  m.Scope scope$,
  Transform target$,
) =>
    () {
      return target$.filterQuality;
    };
Function _Transform__$(m.Scope scope$) => ({
      Key? key,
      required Matrix4 transform,
      Offset? origin,
      AlignmentGeometry? alignment,
      bool? transformHitTests,
      FilterQuality? filterQuality,
      Widget? child,
    }) {
      return Transform(
        alignment: alignment,
        child: child,
        filterQuality: filterQuality,
        key: key,
        origin: origin,
        transform: transform,
        transformHitTests: transformHitTests ?? true,
      );
    };
Function _Transform_rotate_$(m.Scope scope$) => Transform.rotate;
Function _Transform_translate_$(m.Scope scope$) => Transform.translate;
Function _Transform_scale_$(m.Scope scope$) => Transform.scale;
Function _Transform_flip_$(m.Scope scope$) => Transform.flip;
Function _Transform_createRenderObject$(
  m.Scope scope$,
  Transform target$,
) =>
    target$.createRenderObject;
Function _Transform_updateRenderObject$(
  m.Scope scope$,
  Transform target$,
) =>
    target$.updateRenderObject;
Function CompositedTransformTarget_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CompositedTransformTarget;
Function CompositedTransformTarget_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CompositedTransformTarget;
Function _CompositedTransformTarget_link$(
  m.Scope scope$,
  CompositedTransformTarget target$,
) =>
    () {
      return target$.link;
    };
Function _CompositedTransformTarget__$(m.Scope scope$) => ({
      Key? key,
      required LayerLink link,
      Widget? child,
    }) {
      return CompositedTransformTarget(
        child: child,
        key: key,
        link: link,
      );
    };
Function _CompositedTransformTarget_createRenderObject$(
  m.Scope scope$,
  CompositedTransformTarget target$,
) =>
    target$.createRenderObject;
Function _CompositedTransformTarget_updateRenderObject$(
  m.Scope scope$,
  CompositedTransformTarget target$,
) =>
    target$.updateRenderObject;
Function CompositedTransformFollower_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CompositedTransformFollower;
Function CompositedTransformFollower_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CompositedTransformFollower;
Function _CompositedTransformFollower_link$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    () {
      return target$.link;
    };
Function _CompositedTransformFollower_showWhenUnlinked$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    () {
      return target$.showWhenUnlinked;
    };
Function _CompositedTransformFollower_targetAnchor$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    () {
      return target$.targetAnchor;
    };
Function _CompositedTransformFollower_followerAnchor$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    () {
      return target$.followerAnchor;
    };
Function _CompositedTransformFollower_offset$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    () {
      return target$.offset;
    };
Function _CompositedTransformFollower__$(m.Scope scope$) => ({
      Key? key,
      required LayerLink link,
      bool? showWhenUnlinked,
      Offset? offset,
      Alignment? targetAnchor,
      Alignment? followerAnchor,
      Widget? child,
    }) {
      return CompositedTransformFollower(
        child: child,
        followerAnchor: followerAnchor ?? Alignment.topLeft,
        key: key,
        link: link,
        offset: offset ?? Offset.zero,
        showWhenUnlinked: showWhenUnlinked ?? true,
        targetAnchor: targetAnchor ?? Alignment.topLeft,
      );
    };
Function _CompositedTransformFollower_createRenderObject$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    target$.createRenderObject;
Function _CompositedTransformFollower_updateRenderObject$(
  m.Scope scope$,
  CompositedTransformFollower target$,
) =>
    target$.updateRenderObject;
Function FittedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FittedBox;
Function FittedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FittedBox;
Function _FittedBox_fit$(
  m.Scope scope$,
  FittedBox target$,
) =>
    () {
      return target$.fit;
    };
Function _FittedBox_alignment$(
  m.Scope scope$,
  FittedBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _FittedBox_clipBehavior$(
  m.Scope scope$,
  FittedBox target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _FittedBox__$(m.Scope scope$) => ({
      Key? key,
      BoxFit? fit,
      AlignmentGeometry? alignment,
      Clip? clipBehavior,
      Widget? child,
    }) {
      return FittedBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        fit: fit ?? BoxFit.contain,
        key: key,
      );
    };
Function _FittedBox_createRenderObject$(
  m.Scope scope$,
  FittedBox target$,
) =>
    target$.createRenderObject;
Function _FittedBox_updateRenderObject$(
  m.Scope scope$,
  FittedBox target$,
) =>
    target$.updateRenderObject;
Function _FittedBox_debugFillProperties$(
  m.Scope scope$,
  FittedBox target$,
) =>
    target$.debugFillProperties;
Function FractionalTranslation_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FractionalTranslation;
Function FractionalTranslation_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FractionalTranslation;
Function _FractionalTranslation_translation$(
  m.Scope scope$,
  FractionalTranslation target$,
) =>
    () {
      return target$.translation;
    };
Function _FractionalTranslation_transformHitTests$(
  m.Scope scope$,
  FractionalTranslation target$,
) =>
    () {
      return target$.transformHitTests;
    };
Function _FractionalTranslation__$(m.Scope scope$) => ({
      Key? key,
      required Offset translation,
      bool? transformHitTests,
      Widget? child,
    }) {
      return FractionalTranslation(
        child: child,
        key: key,
        transformHitTests: transformHitTests ?? true,
        translation: translation,
      );
    };
Function _FractionalTranslation_createRenderObject$(
  m.Scope scope$,
  FractionalTranslation target$,
) =>
    target$.createRenderObject;
Function _FractionalTranslation_updateRenderObject$(
  m.Scope scope$,
  FractionalTranslation target$,
) =>
    target$.updateRenderObject;
Function RotatedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RotatedBox;
Function RotatedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RotatedBox;
Function _RotatedBox_quarterTurns$(
  m.Scope scope$,
  RotatedBox target$,
) =>
    () {
      return target$.quarterTurns;
    };
Function _RotatedBox__$(m.Scope scope$) => ({
      Key? key,
      required int quarterTurns,
      Widget? child,
    }) {
      return RotatedBox(
        child: child,
        key: key,
        quarterTurns: quarterTurns,
      );
    };
Function _RotatedBox_createRenderObject$(
  m.Scope scope$,
  RotatedBox target$,
) =>
    target$.createRenderObject;
Function _RotatedBox_updateRenderObject$(
  m.Scope scope$,
  RotatedBox target$,
) =>
    target$.updateRenderObject;
Function Padding_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Padding;
Function Padding_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Padding;
Function _Padding_padding$(
  m.Scope scope$,
  Padding target$,
) =>
    () {
      return target$.padding;
    };
Function _Padding__$(m.Scope scope$) => ({
      Key? key,
      required EdgeInsetsGeometry padding,
      Widget? child,
    }) {
      return Padding(
        child: child,
        key: key,
        padding: padding,
      );
    };
Function _Padding_createRenderObject$(
  m.Scope scope$,
  Padding target$,
) =>
    target$.createRenderObject;
Function _Padding_updateRenderObject$(
  m.Scope scope$,
  Padding target$,
) =>
    target$.updateRenderObject;
Function _Padding_debugFillProperties$(
  m.Scope scope$,
  Padding target$,
) =>
    target$.debugFillProperties;
Function Align_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Align;
Function Align_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Align;
Function _Align_alignment$(
  m.Scope scope$,
  Align target$,
) =>
    () {
      return target$.alignment;
    };
Function _Align_widthFactor$(
  m.Scope scope$,
  Align target$,
) =>
    () {
      return target$.widthFactor;
    };
Function _Align_heightFactor$(
  m.Scope scope$,
  Align target$,
) =>
    () {
      return target$.heightFactor;
    };
Function _Align__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      double? widthFactor,
      double? heightFactor,
      Widget? child,
    }) {
      return Align(
        alignment: alignment ?? Alignment.center,
        child: child,
        heightFactor: heightFactor,
        key: key,
        widthFactor: widthFactor,
      );
    };
Function _Align_createRenderObject$(
  m.Scope scope$,
  Align target$,
) =>
    target$.createRenderObject;
Function _Align_updateRenderObject$(
  m.Scope scope$,
  Align target$,
) =>
    target$.updateRenderObject;
Function _Align_debugFillProperties$(
  m.Scope scope$,
  Align target$,
) =>
    target$.debugFillProperties;
Function Center_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Center;
Function Center_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Center;
Function _Center__$(m.Scope scope$) => ({
      Key? key,
      double? widthFactor,
      double? heightFactor,
      Widget? child,
    }) {
      return Center(
        child: child,
        heightFactor: heightFactor,
        key: key,
        widthFactor: widthFactor,
      );
    };
Function CustomSingleChildLayout_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CustomSingleChildLayout;
Function CustomSingleChildLayout_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CustomSingleChildLayout;
Function _CustomSingleChildLayout_delegate$(
  m.Scope scope$,
  CustomSingleChildLayout target$,
) =>
    () {
      return target$.delegate;
    };
Function _CustomSingleChildLayout__$(m.Scope scope$) => ({
      Key? key,
      required SingleChildLayoutDelegate delegate,
      Widget? child,
    }) {
      return CustomSingleChildLayout(
        child: child,
        delegate: delegate,
        key: key,
      );
    };
Function _CustomSingleChildLayout_createRenderObject$(
  m.Scope scope$,
  CustomSingleChildLayout target$,
) =>
    target$.createRenderObject;
Function _CustomSingleChildLayout_updateRenderObject$(
  m.Scope scope$,
  CustomSingleChildLayout target$,
) =>
    target$.updateRenderObject;
Function LayoutId_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LayoutId;
Function LayoutId_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LayoutId;
Function _LayoutId_id$(
  m.Scope scope$,
  LayoutId target$,
) =>
    () {
      return target$.id;
    };
Function _LayoutId_debugTypicalAncestorWidgetClass$(
  m.Scope scope$,
  LayoutId target$,
) =>
    () {
      return target$.debugTypicalAncestorWidgetClass;
    };
Function _LayoutId__$(m.Scope scope$) => ({
      Key? key,
      required Object id,
      required Widget child,
    }) {
      return LayoutId(
        child: child,
        id: id,
        key: key,
      );
    };
Function _LayoutId_applyParentData$(
  m.Scope scope$,
  LayoutId target$,
) =>
    target$.applyParentData;
Function _LayoutId_debugFillProperties$(
  m.Scope scope$,
  LayoutId target$,
) =>
    target$.debugFillProperties;
Function CustomMultiChildLayout_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CustomMultiChildLayout;
Function CustomMultiChildLayout_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CustomMultiChildLayout;
Function _CustomMultiChildLayout_delegate$(
  m.Scope scope$,
  CustomMultiChildLayout target$,
) =>
    () {
      return target$.delegate;
    };
Function _CustomMultiChildLayout__$(m.Scope scope$) => ({
      Key? key,
      required MultiChildLayoutDelegate delegate,
      List? children,
    }) {
      return CustomMultiChildLayout(
        children: children == null ? const <Widget>[] : List.from(children),
        delegate: delegate,
        key: key,
      );
    };
Function _CustomMultiChildLayout_createRenderObject$(
  m.Scope scope$,
  CustomMultiChildLayout target$,
) =>
    target$.createRenderObject;
Function _CustomMultiChildLayout_updateRenderObject$(
  m.Scope scope$,
  CustomMultiChildLayout target$,
) =>
    target$.updateRenderObject;
Function SizedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SizedBox;
Function SizedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SizedBox;
Function _SizedBox_width$(
  m.Scope scope$,
  SizedBox target$,
) =>
    () {
      return target$.width;
    };
Function _SizedBox_height$(
  m.Scope scope$,
  SizedBox target$,
) =>
    () {
      return target$.height;
    };
Function _SizedBox__$(m.Scope scope$) => ({
      Key? key,
      double? width,
      double? height,
      Widget? child,
    }) {
      return SizedBox(
        child: child,
        height: height,
        key: key,
        width: width,
      );
    };
Function _SizedBox_expand_$(m.Scope scope$) => SizedBox.expand;
Function _SizedBox_shrink_$(m.Scope scope$) => SizedBox.shrink;
Function _SizedBox_fromSize_$(m.Scope scope$) => SizedBox.fromSize;
Function _SizedBox_square_$(m.Scope scope$) => SizedBox.square;
Function _SizedBox_createRenderObject$(
  m.Scope scope$,
  SizedBox target$,
) =>
    target$.createRenderObject;
Function _SizedBox_updateRenderObject$(
  m.Scope scope$,
  SizedBox target$,
) =>
    target$.updateRenderObject;
Function _SizedBox_toStringShort$(
  m.Scope scope$,
  SizedBox target$,
) =>
    target$.toStringShort;
Function _SizedBox_debugFillProperties$(
  m.Scope scope$,
  SizedBox target$,
) =>
    target$.debugFillProperties;
Function ConstrainedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ConstrainedBox;
Function ConstrainedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ConstrainedBox;
Function _ConstrainedBox_constraints$(
  m.Scope scope$,
  ConstrainedBox target$,
) =>
    () {
      return target$.constraints;
    };
Function _ConstrainedBox__$(m.Scope scope$) => ({
      Key? key,
      required BoxConstraints constraints,
      Widget? child,
    }) {
      return ConstrainedBox(
        child: child,
        constraints: constraints,
        key: key,
      );
    };
Function _ConstrainedBox_createRenderObject$(
  m.Scope scope$,
  ConstrainedBox target$,
) =>
    target$.createRenderObject;
Function _ConstrainedBox_updateRenderObject$(
  m.Scope scope$,
  ConstrainedBox target$,
) =>
    target$.updateRenderObject;
Function _ConstrainedBox_debugFillProperties$(
  m.Scope scope$,
  ConstrainedBox target$,
) =>
    target$.debugFillProperties;
Function ConstraintsTransformBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ConstraintsTransformBox;
Function ConstraintsTransformBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ConstraintsTransformBox;
Function _ConstraintsTransformBox_textDirection$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    () {
      return target$.textDirection;
    };
Function _ConstraintsTransformBox_alignment$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _ConstraintsTransformBox_constraintsTransform$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    () {
      return target$.constraintsTransform;
    };
Function _ConstraintsTransformBox_clipBehavior$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _ConstraintsTransformBox__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      TextDirection? textDirection,
      AlignmentGeometry? alignment,
      required m.FunctionPointer constraintsTransform,
      Clip? clipBehavior,
      String? debugTransformType,
    }) {
      BoxConstraints constraintsTransformProxy(
              BoxConstraints constraintsTransform_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            constraintsTransform,
            [constraintsTransform_$p0$],
            {},
          );
      return ConstraintsTransformBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        constraintsTransform: constraintsTransformProxy,
        debugTransformType: debugTransformType ?? '',
        key: key,
        textDirection: textDirection,
      );
    };
Function _ConstraintsTransformBox_unmodified$(m.Scope scope$) =>
    ConstraintsTransformBox.unmodified;
Function _ConstraintsTransformBox_unconstrained$(m.Scope scope$) =>
    ConstraintsTransformBox.unconstrained;
Function _ConstraintsTransformBox_widthUnconstrained$(m.Scope scope$) =>
    ConstraintsTransformBox.widthUnconstrained;
Function _ConstraintsTransformBox_heightUnconstrained$(m.Scope scope$) =>
    ConstraintsTransformBox.heightUnconstrained;
Function _ConstraintsTransformBox_maxHeightUnconstrained$(m.Scope scope$) =>
    ConstraintsTransformBox.maxHeightUnconstrained;
Function _ConstraintsTransformBox_maxWidthUnconstrained$(m.Scope scope$) =>
    ConstraintsTransformBox.maxWidthUnconstrained;
Function _ConstraintsTransformBox_maxUnconstrained$(m.Scope scope$) =>
    ConstraintsTransformBox.maxUnconstrained;
Function _ConstraintsTransformBox_createRenderObject$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    target$.createRenderObject;
Function _ConstraintsTransformBox_updateRenderObject$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    target$.updateRenderObject;
Function _ConstraintsTransformBox_debugFillProperties$(
  m.Scope scope$,
  ConstraintsTransformBox target$,
) =>
    target$.debugFillProperties;
Function UnconstrainedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as UnconstrainedBox;
Function UnconstrainedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is UnconstrainedBox;
Function _UnconstrainedBox_textDirection$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    () {
      return target$.textDirection;
    };
Function _UnconstrainedBox_alignment$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _UnconstrainedBox_constrainedAxis$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    () {
      return target$.constrainedAxis;
    };
Function _UnconstrainedBox_clipBehavior$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _UnconstrainedBox_child$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    () {
      return target$.child;
    };
Function _UnconstrainedBox__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      TextDirection? textDirection,
      AlignmentGeometry? alignment,
      Axis? constrainedAxis,
      Clip? clipBehavior,
    }) {
      return UnconstrainedBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        constrainedAxis: constrainedAxis,
        key: key,
        textDirection: textDirection,
      );
    };
Function _UnconstrainedBox_build$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    target$.build;
Function _UnconstrainedBox_debugFillProperties$(
  m.Scope scope$,
  UnconstrainedBox target$,
) =>
    target$.debugFillProperties;
Function FractionallySizedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FractionallySizedBox;
Function FractionallySizedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FractionallySizedBox;
Function _FractionallySizedBox_widthFactor$(
  m.Scope scope$,
  FractionallySizedBox target$,
) =>
    () {
      return target$.widthFactor;
    };
Function _FractionallySizedBox_heightFactor$(
  m.Scope scope$,
  FractionallySizedBox target$,
) =>
    () {
      return target$.heightFactor;
    };
Function _FractionallySizedBox_alignment$(
  m.Scope scope$,
  FractionallySizedBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _FractionallySizedBox__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      double? widthFactor,
      double? heightFactor,
      Widget? child,
    }) {
      return FractionallySizedBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        heightFactor: heightFactor,
        key: key,
        widthFactor: widthFactor,
      );
    };
Function _FractionallySizedBox_createRenderObject$(
  m.Scope scope$,
  FractionallySizedBox target$,
) =>
    target$.createRenderObject;
Function _FractionallySizedBox_updateRenderObject$(
  m.Scope scope$,
  FractionallySizedBox target$,
) =>
    target$.updateRenderObject;
Function _FractionallySizedBox_debugFillProperties$(
  m.Scope scope$,
  FractionallySizedBox target$,
) =>
    target$.debugFillProperties;
Function LimitedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LimitedBox;
Function LimitedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LimitedBox;
Function _LimitedBox_maxWidth$(
  m.Scope scope$,
  LimitedBox target$,
) =>
    () {
      return target$.maxWidth;
    };
Function _LimitedBox_maxHeight$(
  m.Scope scope$,
  LimitedBox target$,
) =>
    () {
      return target$.maxHeight;
    };
Function _LimitedBox__$(m.Scope scope$) => ({
      Key? key,
      double? maxWidth,
      double? maxHeight,
      Widget? child,
    }) {
      return LimitedBox(
        child: child,
        key: key,
        maxHeight: maxHeight ?? double.infinity,
        maxWidth: maxWidth ?? double.infinity,
      );
    };
Function _LimitedBox_createRenderObject$(
  m.Scope scope$,
  LimitedBox target$,
) =>
    target$.createRenderObject;
Function _LimitedBox_updateRenderObject$(
  m.Scope scope$,
  LimitedBox target$,
) =>
    target$.updateRenderObject;
Function _LimitedBox_debugFillProperties$(
  m.Scope scope$,
  LimitedBox target$,
) =>
    target$.debugFillProperties;
Function OverflowBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as OverflowBox;
Function OverflowBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is OverflowBox;
Function _OverflowBox_alignment$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _OverflowBox_minWidth$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    () {
      return target$.minWidth;
    };
Function _OverflowBox_maxWidth$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    () {
      return target$.maxWidth;
    };
Function _OverflowBox_minHeight$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    () {
      return target$.minHeight;
    };
Function _OverflowBox_maxHeight$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    () {
      return target$.maxHeight;
    };
Function _OverflowBox__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      double? minWidth,
      double? maxWidth,
      double? minHeight,
      double? maxHeight,
      Widget? child,
    }) {
      return OverflowBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        key: key,
        maxHeight: maxHeight,
        maxWidth: maxWidth,
        minHeight: minHeight,
        minWidth: minWidth,
      );
    };
Function _OverflowBox_createRenderObject$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    target$.createRenderObject;
Function _OverflowBox_updateRenderObject$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    target$.updateRenderObject;
Function _OverflowBox_debugFillProperties$(
  m.Scope scope$,
  OverflowBox target$,
) =>
    target$.debugFillProperties;
Function SizedOverflowBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SizedOverflowBox;
Function SizedOverflowBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SizedOverflowBox;
Function _SizedOverflowBox_alignment$(
  m.Scope scope$,
  SizedOverflowBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _SizedOverflowBox_size$(
  m.Scope scope$,
  SizedOverflowBox target$,
) =>
    () {
      return target$.size;
    };
Function _SizedOverflowBox__$(m.Scope scope$) => ({
      Key? key,
      required Size size,
      AlignmentGeometry? alignment,
      Widget? child,
    }) {
      return SizedOverflowBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        key: key,
        size: size,
      );
    };
Function _SizedOverflowBox_createRenderObject$(
  m.Scope scope$,
  SizedOverflowBox target$,
) =>
    target$.createRenderObject;
Function _SizedOverflowBox_updateRenderObject$(
  m.Scope scope$,
  SizedOverflowBox target$,
) =>
    target$.updateRenderObject;
Function _SizedOverflowBox_debugFillProperties$(
  m.Scope scope$,
  SizedOverflowBox target$,
) =>
    target$.debugFillProperties;
Function Offstage_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Offstage;
Function Offstage_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Offstage;
Function _Offstage_offstage$(
  m.Scope scope$,
  Offstage target$,
) =>
    () {
      return target$.offstage;
    };
Function _Offstage__$(m.Scope scope$) => ({
      Key? key,
      bool? offstage,
      Widget? child,
    }) {
      return Offstage(
        child: child,
        key: key,
        offstage: offstage ?? true,
      );
    };
Function _Offstage_createRenderObject$(
  m.Scope scope$,
  Offstage target$,
) =>
    target$.createRenderObject;
Function _Offstage_updateRenderObject$(
  m.Scope scope$,
  Offstage target$,
) =>
    target$.updateRenderObject;
Function _Offstage_debugFillProperties$(
  m.Scope scope$,
  Offstage target$,
) =>
    target$.debugFillProperties;
Function _Offstage_createElement$(
  m.Scope scope$,
  Offstage target$,
) =>
    target$.createElement;
Function AspectRatio_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AspectRatio;
Function AspectRatio_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AspectRatio;
Function _AspectRatio_aspectRatio$(
  m.Scope scope$,
  AspectRatio target$,
) =>
    () {
      return target$.aspectRatio;
    };
Function _AspectRatio__$(m.Scope scope$) => ({
      Key? key,
      required double aspectRatio,
      Widget? child,
    }) {
      return AspectRatio(
        aspectRatio: aspectRatio,
        child: child,
        key: key,
      );
    };
Function _AspectRatio_createRenderObject$(
  m.Scope scope$,
  AspectRatio target$,
) =>
    target$.createRenderObject;
Function _AspectRatio_updateRenderObject$(
  m.Scope scope$,
  AspectRatio target$,
) =>
    target$.updateRenderObject;
Function _AspectRatio_debugFillProperties$(
  m.Scope scope$,
  AspectRatio target$,
) =>
    target$.debugFillProperties;
Function IntrinsicWidth_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as IntrinsicWidth;
Function IntrinsicWidth_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is IntrinsicWidth;
Function _IntrinsicWidth_stepWidth$(
  m.Scope scope$,
  IntrinsicWidth target$,
) =>
    () {
      return target$.stepWidth;
    };
Function _IntrinsicWidth_stepHeight$(
  m.Scope scope$,
  IntrinsicWidth target$,
) =>
    () {
      return target$.stepHeight;
    };
Function _IntrinsicWidth__$(m.Scope scope$) => ({
      Key? key,
      double? stepWidth,
      double? stepHeight,
      Widget? child,
    }) {
      return IntrinsicWidth(
        child: child,
        key: key,
        stepHeight: stepHeight,
        stepWidth: stepWidth,
      );
    };
Function _IntrinsicWidth_createRenderObject$(
  m.Scope scope$,
  IntrinsicWidth target$,
) =>
    target$.createRenderObject;
Function _IntrinsicWidth_updateRenderObject$(
  m.Scope scope$,
  IntrinsicWidth target$,
) =>
    target$.updateRenderObject;
Function IntrinsicHeight_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as IntrinsicHeight;
Function IntrinsicHeight_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is IntrinsicHeight;
Function _IntrinsicHeight__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return IntrinsicHeight(
        child: child,
        key: key,
      );
    };
Function _IntrinsicHeight_createRenderObject$(
  m.Scope scope$,
  IntrinsicHeight target$,
) =>
    target$.createRenderObject;
Function Baseline_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Baseline;
Function Baseline_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Baseline;
Function _Baseline_baseline$(
  m.Scope scope$,
  Baseline target$,
) =>
    () {
      return target$.baseline;
    };
Function _Baseline_baselineType$(
  m.Scope scope$,
  Baseline target$,
) =>
    () {
      return target$.baselineType;
    };
Function _Baseline__$(m.Scope scope$) => ({
      Key? key,
      required double baseline,
      required TextBaseline baselineType,
      Widget? child,
    }) {
      return Baseline(
        baseline: baseline,
        baselineType: baselineType,
        child: child,
        key: key,
      );
    };
Function _Baseline_createRenderObject$(
  m.Scope scope$,
  Baseline target$,
) =>
    target$.createRenderObject;
Function _Baseline_updateRenderObject$(
  m.Scope scope$,
  Baseline target$,
) =>
    target$.updateRenderObject;
Function SliverToBoxAdapter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SliverToBoxAdapter;
Function SliverToBoxAdapter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SliverToBoxAdapter;
Function _SliverToBoxAdapter__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return SliverToBoxAdapter(
        child: child,
        key: key,
      );
    };
Function _SliverToBoxAdapter_createRenderObject$(
  m.Scope scope$,
  SliverToBoxAdapter target$,
) =>
    target$.createRenderObject;
Function SliverPadding_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SliverPadding;
Function SliverPadding_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SliverPadding;
Function _SliverPadding_padding$(
  m.Scope scope$,
  SliverPadding target$,
) =>
    () {
      return target$.padding;
    };
Function _SliverPadding__$(m.Scope scope$) => ({
      Key? key,
      required EdgeInsetsGeometry padding,
      Widget? sliver,
    }) {
      return SliverPadding(
        key: key,
        padding: padding,
        sliver: sliver,
      );
    };
Function _SliverPadding_createRenderObject$(
  m.Scope scope$,
  SliverPadding target$,
) =>
    target$.createRenderObject;
Function _SliverPadding_updateRenderObject$(
  m.Scope scope$,
  SliverPadding target$,
) =>
    target$.updateRenderObject;
Function _SliverPadding_debugFillProperties$(
  m.Scope scope$,
  SliverPadding target$,
) =>
    target$.debugFillProperties;
Function ListBody_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ListBody;
Function ListBody_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ListBody;
Function _ListBody_mainAxis$(
  m.Scope scope$,
  ListBody target$,
) =>
    () {
      return target$.mainAxis;
    };
Function _ListBody_reverse$(
  m.Scope scope$,
  ListBody target$,
) =>
    () {
      return target$.reverse;
    };
Function _ListBody__$(m.Scope scope$) => ({
      Key? key,
      Axis? mainAxis,
      bool? reverse,
      List? children,
    }) {
      return ListBody(
        children: children == null ? const <Widget>[] : List.from(children),
        key: key,
        mainAxis: mainAxis ?? Axis.vertical,
        reverse: reverse ?? false,
      );
    };
Function _ListBody_createRenderObject$(
  m.Scope scope$,
  ListBody target$,
) =>
    target$.createRenderObject;
Function _ListBody_updateRenderObject$(
  m.Scope scope$,
  ListBody target$,
) =>
    target$.updateRenderObject;
Function Stack_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Stack;
Function Stack_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Stack;
Function _Stack_alignment$(
  m.Scope scope$,
  Stack target$,
) =>
    () {
      return target$.alignment;
    };
Function _Stack_textDirection$(
  m.Scope scope$,
  Stack target$,
) =>
    () {
      return target$.textDirection;
    };
Function _Stack_fit$(
  m.Scope scope$,
  Stack target$,
) =>
    () {
      return target$.fit;
    };
Function _Stack_clipBehavior$(
  m.Scope scope$,
  Stack target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _Stack__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      TextDirection? textDirection,
      StackFit? fit,
      Clip? clipBehavior,
      List? children,
    }) {
      return Stack(
        alignment: alignment ?? AlignmentDirectional.topStart,
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        fit: fit ?? StackFit.loose,
        key: key,
        textDirection: textDirection,
      );
    };
Function _Stack_createRenderObject$(
  m.Scope scope$,
  Stack target$,
) =>
    target$.createRenderObject;
Function _Stack_updateRenderObject$(
  m.Scope scope$,
  Stack target$,
) =>
    target$.updateRenderObject;
Function _Stack_debugFillProperties$(
  m.Scope scope$,
  Stack target$,
) =>
    target$.debugFillProperties;
Function IndexedStack_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as IndexedStack;
Function IndexedStack_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is IndexedStack;
Function _IndexedStack_alignment$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    () {
      return target$.alignment;
    };
Function _IndexedStack_textDirection$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    () {
      return target$.textDirection;
    };
Function _IndexedStack_clipBehavior$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _IndexedStack_sizing$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    () {
      return target$.sizing;
    };
Function _IndexedStack_index$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    () {
      return target$.index;
    };
Function _IndexedStack_children$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    () {
      return target$.children;
    };
Function _IndexedStack__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      TextDirection? textDirection,
      Clip? clipBehavior,
      StackFit? sizing,
      int? index,
      List? children,
    }) {
      return IndexedStack(
        alignment: alignment ?? AlignmentDirectional.topStart,
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        index: index ?? 0,
        key: key,
        sizing: sizing ?? StackFit.loose,
        textDirection: textDirection,
      );
    };
Function _IndexedStack_build$(
  m.Scope scope$,
  IndexedStack target$,
) =>
    target$.build;
Function Positioned_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Positioned;
Function Positioned_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Positioned;
Function _Positioned_left$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.left;
    };
Function _Positioned_top$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.top;
    };
Function _Positioned_right$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.right;
    };
Function _Positioned_bottom$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.bottom;
    };
Function _Positioned_width$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.width;
    };
Function _Positioned_height$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.height;
    };
Function _Positioned_debugTypicalAncestorWidgetClass$(
  m.Scope scope$,
  Positioned target$,
) =>
    () {
      return target$.debugTypicalAncestorWidgetClass;
    };
Function _Positioned__$(m.Scope scope$) => ({
      Key? key,
      double? left,
      double? top,
      double? right,
      double? bottom,
      double? width,
      double? height,
      required Widget child,
    }) {
      return Positioned(
        bottom: bottom,
        child: child,
        height: height,
        key: key,
        left: left,
        right: right,
        top: top,
        width: width,
      );
    };
Function _Positioned_fromRect_$(m.Scope scope$) => Positioned.fromRect;
Function _Positioned_fromRelativeRect_$(m.Scope scope$) =>
    Positioned.fromRelativeRect;
Function _Positioned_fill_$(m.Scope scope$) => Positioned.fill;
Function _Positioned_directional_$(m.Scope scope$) => Positioned.directional;
Function _Positioned_applyParentData$(
  m.Scope scope$,
  Positioned target$,
) =>
    target$.applyParentData;
Function _Positioned_debugFillProperties$(
  m.Scope scope$,
  Positioned target$,
) =>
    target$.debugFillProperties;
Function PositionedDirectional_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PositionedDirectional;
Function PositionedDirectional_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PositionedDirectional;
Function _PositionedDirectional_start$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.start;
    };
Function _PositionedDirectional_top$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.top;
    };
Function _PositionedDirectional_end$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.end;
    };
Function _PositionedDirectional_bottom$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.bottom;
    };
Function _PositionedDirectional_width$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.width;
    };
Function _PositionedDirectional_height$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.height;
    };
Function _PositionedDirectional_child$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    () {
      return target$.child;
    };
Function _PositionedDirectional__$(m.Scope scope$) => ({
      Key? key,
      double? start,
      double? top,
      double? end,
      double? bottom,
      double? width,
      double? height,
      required Widget child,
    }) {
      return PositionedDirectional(
        bottom: bottom,
        child: child,
        end: end,
        height: height,
        key: key,
        start: start,
        top: top,
        width: width,
      );
    };
Function _PositionedDirectional_build$(
  m.Scope scope$,
  PositionedDirectional target$,
) =>
    target$.build;
Function Flex_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Flex;
Function Flex_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Flex;
Function _Flex_direction$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.direction;
    };
Function _Flex_mainAxisAlignment$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.mainAxisAlignment;
    };
Function _Flex_mainAxisSize$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.mainAxisSize;
    };
Function _Flex_crossAxisAlignment$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.crossAxisAlignment;
    };
Function _Flex_textDirection$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.textDirection;
    };
Function _Flex_verticalDirection$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.verticalDirection;
    };
Function _Flex_textBaseline$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.textBaseline;
    };
Function _Flex_clipBehavior$(
  m.Scope scope$,
  Flex target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _Flex__$(m.Scope scope$) => ({
      Key? key,
      required Axis direction,
      MainAxisAlignment? mainAxisAlignment,
      MainAxisSize? mainAxisSize,
      CrossAxisAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      TextBaseline? textBaseline,
      Clip? clipBehavior,
      List? children,
    }) {
      return Flex(
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.none,
        crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
        direction: direction,
        key: key,
        mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
        mainAxisSize: mainAxisSize ?? MainAxisSize.max,
        textBaseline: textBaseline,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function _Flex_getEffectiveTextDirection$(
  m.Scope scope$,
  Flex target$,
) =>
    target$.getEffectiveTextDirection;
Function _Flex_createRenderObject$(
  m.Scope scope$,
  Flex target$,
) =>
    target$.createRenderObject;
Function _Flex_updateRenderObject$(
  m.Scope scope$,
  Flex target$,
) =>
    target$.updateRenderObject;
Function _Flex_debugFillProperties$(
  m.Scope scope$,
  Flex target$,
) =>
    target$.debugFillProperties;
Function Row_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Row;
Function Row_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Row;
Function _Row__$(m.Scope scope$) => ({
      Key? key,
      MainAxisAlignment? mainAxisAlignment,
      MainAxisSize? mainAxisSize,
      CrossAxisAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      TextBaseline? textBaseline,
      List? children,
    }) {
      return Row(
        children: children == null ? const <Widget>[] : List.from(children),
        crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
        key: key,
        mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
        mainAxisSize: mainAxisSize ?? MainAxisSize.max,
        textBaseline: textBaseline,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function Column_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Column;
Function Column_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Column;
Function _Column__$(m.Scope scope$) => ({
      Key? key,
      MainAxisAlignment? mainAxisAlignment,
      MainAxisSize? mainAxisSize,
      CrossAxisAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      TextBaseline? textBaseline,
      List? children,
    }) {
      return Column(
        children: children == null ? const <Widget>[] : List.from(children),
        crossAxisAlignment: crossAxisAlignment ?? CrossAxisAlignment.center,
        key: key,
        mainAxisAlignment: mainAxisAlignment ?? MainAxisAlignment.start,
        mainAxisSize: mainAxisSize ?? MainAxisSize.max,
        textBaseline: textBaseline,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function Flexible_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Flexible;
Function Flexible_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Flexible;
Function _Flexible_flex$(
  m.Scope scope$,
  Flexible target$,
) =>
    () {
      return target$.flex;
    };
Function _Flexible_fit$(
  m.Scope scope$,
  Flexible target$,
) =>
    () {
      return target$.fit;
    };
Function _Flexible_debugTypicalAncestorWidgetClass$(
  m.Scope scope$,
  Flexible target$,
) =>
    () {
      return target$.debugTypicalAncestorWidgetClass;
    };
Function _Flexible__$(m.Scope scope$) => ({
      Key? key,
      int? flex,
      FlexFit? fit,
      required Widget child,
    }) {
      return Flexible(
        child: child,
        fit: fit ?? FlexFit.loose,
        flex: flex ?? 1,
        key: key,
      );
    };
Function _Flexible_applyParentData$(
  m.Scope scope$,
  Flexible target$,
) =>
    target$.applyParentData;
Function _Flexible_debugFillProperties$(
  m.Scope scope$,
  Flexible target$,
) =>
    target$.debugFillProperties;
Function Expanded_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Expanded;
Function Expanded_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Expanded;
Function _Expanded__$(m.Scope scope$) => ({
      Key? key,
      int? flex,
      required Widget child,
    }) {
      return Expanded(
        child: child,
        flex: flex ?? 1,
        key: key,
      );
    };
Function Wrap_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Wrap;
Function Wrap_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Wrap;
Function _Wrap_direction$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.direction;
    };
Function _Wrap_alignment$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.alignment;
    };
Function _Wrap_spacing$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.spacing;
    };
Function _Wrap_runAlignment$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.runAlignment;
    };
Function _Wrap_runSpacing$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.runSpacing;
    };
Function _Wrap_crossAxisAlignment$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.crossAxisAlignment;
    };
Function _Wrap_textDirection$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.textDirection;
    };
Function _Wrap_verticalDirection$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.verticalDirection;
    };
Function _Wrap_clipBehavior$(
  m.Scope scope$,
  Wrap target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _Wrap__$(m.Scope scope$) => ({
      Key? key,
      Axis? direction,
      WrapAlignment? alignment,
      double? spacing,
      WrapAlignment? runAlignment,
      double? runSpacing,
      WrapCrossAlignment? crossAxisAlignment,
      TextDirection? textDirection,
      VerticalDirection? verticalDirection,
      Clip? clipBehavior,
      List? children,
    }) {
      return Wrap(
        alignment: alignment ?? WrapAlignment.start,
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.none,
        crossAxisAlignment: crossAxisAlignment ?? WrapCrossAlignment.start,
        direction: direction ?? Axis.horizontal,
        key: key,
        runAlignment: runAlignment ?? WrapAlignment.start,
        runSpacing: runSpacing ?? 0.0,
        spacing: spacing ?? 0.0,
        textDirection: textDirection,
        verticalDirection: verticalDirection ?? VerticalDirection.down,
      );
    };
Function _Wrap_createRenderObject$(
  m.Scope scope$,
  Wrap target$,
) =>
    target$.createRenderObject;
Function _Wrap_updateRenderObject$(
  m.Scope scope$,
  Wrap target$,
) =>
    target$.updateRenderObject;
Function _Wrap_debugFillProperties$(
  m.Scope scope$,
  Wrap target$,
) =>
    target$.debugFillProperties;
Function Flow_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Flow;
Function Flow_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Flow;
Function _Flow_delegate$(
  m.Scope scope$,
  Flow target$,
) =>
    () {
      return target$.delegate;
    };
Function _Flow_clipBehavior$(
  m.Scope scope$,
  Flow target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _Flow__$(m.Scope scope$) => ({
      Key? key,
      required FlowDelegate delegate,
      List? children,
      Clip? clipBehavior,
    }) {
      return Flow(
        children: children == null ? const <Widget>[] : List.from(children),
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        delegate: delegate,
        key: key,
      );
    };
Function _Flow_unwrapped_$(m.Scope scope$) => Flow.unwrapped;
Function _Flow_createRenderObject$(
  m.Scope scope$,
  Flow target$,
) =>
    target$.createRenderObject;
Function _Flow_updateRenderObject$(
  m.Scope scope$,
  Flow target$,
) =>
    target$.updateRenderObject;
Function RichText_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RichText;
Function RichText_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RichText;
Function _RichText_text$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.text;
    };
Function _RichText_textAlign$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.textAlign;
    };
Function _RichText_textDirection$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.textDirection;
    };
Function _RichText_softWrap$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.softWrap;
    };
Function _RichText_overflow$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.overflow;
    };
Function _RichText_textScaleFactor$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.textScaleFactor;
    };
Function _RichText_maxLines$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.maxLines;
    };
Function _RichText_locale$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.locale;
    };
Function _RichText_strutStyle$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.strutStyle;
    };
Function _RichText_textWidthBasis$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.textWidthBasis;
    };
Function _RichText_textHeightBehavior$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.textHeightBehavior;
    };
Function _RichText_selectionRegistrar$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.selectionRegistrar;
    };
Function _RichText_selectionColor$(
  m.Scope scope$,
  RichText target$,
) =>
    () {
      return target$.selectionColor;
    };
Function _RichText__$(m.Scope scope$) => ({
      Key? key,
      required InlineSpan text,
      TextAlign? textAlign,
      TextDirection? textDirection,
      bool? softWrap,
      TextOverflow? overflow,
      double? textScaleFactor,
      int? maxLines,
      Locale? locale,
      StrutStyle? strutStyle,
      TextWidthBasis? textWidthBasis,
      TextHeightBehavior? textHeightBehavior,
      SelectionRegistrar? selectionRegistrar,
      Color? selectionColor,
    }) {
      return RichText(
        key: key,
        locale: locale,
        maxLines: maxLines,
        overflow: overflow ?? TextOverflow.clip,
        selectionColor: selectionColor,
        selectionRegistrar: selectionRegistrar,
        softWrap: softWrap ?? true,
        strutStyle: strutStyle,
        text: text,
        textAlign: textAlign ?? TextAlign.start,
        textDirection: textDirection,
        textHeightBehavior: textHeightBehavior,
        textScaleFactor: textScaleFactor ?? 1.0,
        textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
      );
    };
Function _RichText_createRenderObject$(
  m.Scope scope$,
  RichText target$,
) =>
    target$.createRenderObject;
Function _RichText_updateRenderObject$(
  m.Scope scope$,
  RichText target$,
) =>
    target$.updateRenderObject;
Function _RichText_debugFillProperties$(
  m.Scope scope$,
  RichText target$,
) =>
    target$.debugFillProperties;
Function RawImage_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RawImage;
Function RawImage_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RawImage;
Function _RawImage_image$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.image;
    };
Function _RawImage_debugImageLabel$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.debugImageLabel;
    };
Function _RawImage_width$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.width;
    };
Function _RawImage_height$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.height;
    };
Function _RawImage_scale$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.scale;
    };
Function _RawImage_color$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.color;
    };
Function _RawImage_opacity$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.opacity;
    };
Function _RawImage_filterQuality$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.filterQuality;
    };
Function _RawImage_colorBlendMode$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.colorBlendMode;
    };
Function _RawImage_fit$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.fit;
    };
Function _RawImage_alignment$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.alignment;
    };
Function _RawImage_repeat$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.repeat;
    };
Function _RawImage_centerSlice$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.centerSlice;
    };
Function _RawImage_matchTextDirection$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.matchTextDirection;
    };
Function _RawImage_invertColors$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.invertColors;
    };
Function _RawImage_isAntiAlias$(
  m.Scope scope$,
  RawImage target$,
) =>
    () {
      return target$.isAntiAlias;
    };
Function _RawImage__$(m.Scope scope$) => ({
      Key? key,
      Image? image,
      String? debugImageLabel,
      double? width,
      double? height,
      double? scale,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry? alignment,
      ImageRepeat? repeat,
      Rect? centerSlice,
      bool? matchTextDirection,
      bool? invertColors,
      FilterQuality? filterQuality,
      bool? isAntiAlias,
    }) {
      return RawImage(
        alignment: alignment ?? Alignment.center,
        centerSlice: centerSlice,
        color: color,
        colorBlendMode: colorBlendMode,
        debugImageLabel: debugImageLabel,
        filterQuality: filterQuality ?? FilterQuality.low,
        fit: fit,
        height: height,
        image: image,
        invertColors: invertColors ?? false,
        isAntiAlias: isAntiAlias ?? false,
        key: key,
        matchTextDirection: matchTextDirection ?? false,
        opacity: opacity,
        repeat: repeat ?? ImageRepeat.noRepeat,
        scale: scale ?? 1.0,
        width: width,
      );
    };
Function _RawImage_createRenderObject$(
  m.Scope scope$,
  RawImage target$,
) =>
    target$.createRenderObject;
Function _RawImage_updateRenderObject$(
  m.Scope scope$,
  RawImage target$,
) =>
    target$.updateRenderObject;
Function _RawImage_didUnmountRenderObject$(
  m.Scope scope$,
  RawImage target$,
) =>
    target$.didUnmountRenderObject;
Function _RawImage_debugFillProperties$(
  m.Scope scope$,
  RawImage target$,
) =>
    target$.debugFillProperties;
Function DefaultAssetBundle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DefaultAssetBundle;
Function DefaultAssetBundle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DefaultAssetBundle;
Function _DefaultAssetBundle_bundle$(
  m.Scope scope$,
  DefaultAssetBundle target$,
) =>
    () {
      return target$.bundle;
    };
Function _DefaultAssetBundle__$(m.Scope scope$) => ({
      Key? key,
      required AssetBundle bundle,
      required Widget child,
    }) {
      return DefaultAssetBundle(
        bundle: bundle,
        child: child,
        key: key,
      );
    };
Function _DefaultAssetBundle_of$(m.Scope scope$) => DefaultAssetBundle.of;
Function _DefaultAssetBundle_updateShouldNotify$(
  m.Scope scope$,
  DefaultAssetBundle target$,
) =>
    target$.updateShouldNotify;
Function WidgetToRenderBoxAdapter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as WidgetToRenderBoxAdapter;
Function WidgetToRenderBoxAdapter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is WidgetToRenderBoxAdapter;
Function _WidgetToRenderBoxAdapter_renderBox$(
  m.Scope scope$,
  WidgetToRenderBoxAdapter target$,
) =>
    () {
      return target$.renderBox;
    };
Function _WidgetToRenderBoxAdapter_onBuild$(
  m.Scope scope$,
  WidgetToRenderBoxAdapter target$,
) =>
    () {
      return target$.onBuild;
    };
Function _WidgetToRenderBoxAdapter_onUnmount$(
  m.Scope scope$,
  WidgetToRenderBoxAdapter target$,
) =>
    () {
      return target$.onUnmount;
    };
Function _WidgetToRenderBoxAdapter__$(m.Scope scope$) => ({
      required RenderBox renderBox,
      m.FunctionPointer? onBuild,
      m.FunctionPointer? onUnmount,
    }) {
      void onBuildProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onBuild!,
            [],
            {},
          );
      void onUnmountProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onUnmount!,
            [],
            {},
          );
      return WidgetToRenderBoxAdapter(
        onBuild: onBuild == null ? null : onBuildProxy,
        onUnmount: onUnmount == null ? null : onUnmountProxy,
        renderBox: renderBox,
      );
    };
Function _WidgetToRenderBoxAdapter_createRenderObject$(
  m.Scope scope$,
  WidgetToRenderBoxAdapter target$,
) =>
    target$.createRenderObject;
Function _WidgetToRenderBoxAdapter_updateRenderObject$(
  m.Scope scope$,
  WidgetToRenderBoxAdapter target$,
) =>
    target$.updateRenderObject;
Function _WidgetToRenderBoxAdapter_didUnmountRenderObject$(
  m.Scope scope$,
  WidgetToRenderBoxAdapter target$,
) =>
    target$.didUnmountRenderObject;
Function Listener_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Listener;
Function Listener_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Listener;
Function _Listener_onPointerDown$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerDown;
    };
Function _Listener_onPointerMove$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerMove;
    };
Function _Listener_onPointerUp$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerUp;
    };
Function _Listener_onPointerHover$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerHover;
    };
Function _Listener_onPointerCancel$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerCancel;
    };
Function _Listener_onPointerPanZoomStart$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerPanZoomStart;
    };
Function _Listener_onPointerPanZoomUpdate$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerPanZoomUpdate;
    };
Function _Listener_onPointerPanZoomEnd$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerPanZoomEnd;
    };
Function _Listener_onPointerSignal$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.onPointerSignal;
    };
Function _Listener_behavior$(
  m.Scope scope$,
  Listener target$,
) =>
    () {
      return target$.behavior;
    };
Function _Listener__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onPointerDown,
      m.FunctionPointer? onPointerMove,
      m.FunctionPointer? onPointerUp,
      m.FunctionPointer? onPointerHover,
      m.FunctionPointer? onPointerCancel,
      m.FunctionPointer? onPointerPanZoomStart,
      m.FunctionPointer? onPointerPanZoomUpdate,
      m.FunctionPointer? onPointerPanZoomEnd,
      m.FunctionPointer? onPointerSignal,
      HitTestBehavior? behavior,
      Widget? child,
    }) {
      void onPointerCancelProxy(PointerCancelEvent onPointerCancel_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerCancel!,
            [onPointerCancel_event$],
            {},
          );
      void onPointerDownProxy(PointerDownEvent onPointerDown_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerDown!,
            [onPointerDown_event$],
            {},
          );
      void onPointerHoverProxy(PointerHoverEvent onPointerHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerHover!,
            [onPointerHover_event$],
            {},
          );
      void onPointerMoveProxy(PointerMoveEvent onPointerMove_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerMove!,
            [onPointerMove_event$],
            {},
          );
      void onPointerPanZoomEndProxy(
              PointerPanZoomEndEvent onPointerPanZoomEnd_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomEnd!,
            [onPointerPanZoomEnd_event$],
            {},
          );
      void onPointerPanZoomStartProxy(
              PointerPanZoomStartEvent onPointerPanZoomStart_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomStart!,
            [onPointerPanZoomStart_event$],
            {},
          );
      void onPointerPanZoomUpdateProxy(
              PointerPanZoomUpdateEvent onPointerPanZoomUpdate_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomUpdate!,
            [onPointerPanZoomUpdate_event$],
            {},
          );
      void onPointerSignalProxy(PointerSignalEvent onPointerSignal_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerSignal!,
            [onPointerSignal_event$],
            {},
          );
      void onPointerUpProxy(PointerUpEvent onPointerUp_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerUp!,
            [onPointerUp_event$],
            {},
          );
      return Listener(
        behavior: behavior ?? HitTestBehavior.deferToChild,
        child: child,
        key: key,
        onPointerCancel: onPointerCancel == null ? null : onPointerCancelProxy,
        onPointerDown: onPointerDown == null ? null : onPointerDownProxy,
        onPointerHover: onPointerHover == null ? null : onPointerHoverProxy,
        onPointerMove: onPointerMove == null ? null : onPointerMoveProxy,
        onPointerPanZoomEnd:
            onPointerPanZoomEnd == null ? null : onPointerPanZoomEndProxy,
        onPointerPanZoomStart:
            onPointerPanZoomStart == null ? null : onPointerPanZoomStartProxy,
        onPointerPanZoomUpdate:
            onPointerPanZoomUpdate == null ? null : onPointerPanZoomUpdateProxy,
        onPointerSignal: onPointerSignal == null ? null : onPointerSignalProxy,
        onPointerUp: onPointerUp == null ? null : onPointerUpProxy,
      );
    };
Function _Listener_createRenderObject$(
  m.Scope scope$,
  Listener target$,
) =>
    target$.createRenderObject;
Function _Listener_updateRenderObject$(
  m.Scope scope$,
  Listener target$,
) =>
    target$.updateRenderObject;
Function _Listener_debugFillProperties$(
  m.Scope scope$,
  Listener target$,
) =>
    target$.debugFillProperties;
Function MouseRegion_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MouseRegion;
Function MouseRegion_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MouseRegion;
Function _MouseRegion_onEnter$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    () {
      return target$.onEnter;
    };
Function _MouseRegion_onHover$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    () {
      return target$.onHover;
    };
Function _MouseRegion_onExit$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    () {
      return target$.onExit;
    };
Function _MouseRegion_cursor$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    () {
      return target$.cursor;
    };
Function _MouseRegion_opaque$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    () {
      return target$.opaque;
    };
Function _MouseRegion_hitTestBehavior$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    () {
      return target$.hitTestBehavior;
    };
Function _MouseRegion__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onEnter,
      m.FunctionPointer? onExit,
      m.FunctionPointer? onHover,
      MouseCursor? cursor,
      bool? opaque,
      HitTestBehavior? hitTestBehavior,
      Widget? child,
    }) {
      void onEnterProxy(PointerEnterEvent onEnter_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEnter!,
            [onEnter_event$],
            {},
          );
      void onExitProxy(PointerExitEvent onExit_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onExit!,
            [onExit_event$],
            {},
          );
      void onHoverProxy(PointerHoverEvent onHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_event$],
            {},
          );
      return MouseRegion(
        child: child,
        cursor: cursor ?? MouseCursor.defer,
        hitTestBehavior: hitTestBehavior,
        key: key,
        onEnter: onEnter == null ? null : onEnterProxy,
        onExit: onExit == null ? null : onExitProxy,
        onHover: onHover == null ? null : onHoverProxy,
        opaque: opaque ?? true,
      );
    };
Function _MouseRegion_createRenderObject$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    target$.createRenderObject;
Function _MouseRegion_updateRenderObject$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    target$.updateRenderObject;
Function _MouseRegion_debugFillProperties$(
  m.Scope scope$,
  MouseRegion target$,
) =>
    target$.debugFillProperties;
Function RepaintBoundary_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RepaintBoundary;
Function RepaintBoundary_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RepaintBoundary;
Function _RepaintBoundary__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return RepaintBoundary(
        child: child,
        key: key,
      );
    };
Function _RepaintBoundary_wrap_$(m.Scope scope$) => RepaintBoundary.wrap;
Function _RepaintBoundary_wrapAll$(m.Scope scope$) => RepaintBoundary.wrapAll;
Function _RepaintBoundary_createRenderObject$(
  m.Scope scope$,
  RepaintBoundary target$,
) =>
    target$.createRenderObject;
Function IgnorePointer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as IgnorePointer;
Function IgnorePointer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is IgnorePointer;
Function _IgnorePointer_ignoring$(
  m.Scope scope$,
  IgnorePointer target$,
) =>
    () {
      return target$.ignoring;
    };
Function _IgnorePointer_ignoringSemantics$(
  m.Scope scope$,
  IgnorePointer target$,
) =>
    () {
      return target$.ignoringSemantics;
    };
Function _IgnorePointer__$(m.Scope scope$) => ({
      Key? key,
      bool? ignoring,
      bool? ignoringSemantics,
      Widget? child,
    }) {
      return IgnorePointer(
        child: child,
        ignoring: ignoring ?? true,
        ignoringSemantics: ignoringSemantics,
        key: key,
      );
    };
Function _IgnorePointer_createRenderObject$(
  m.Scope scope$,
  IgnorePointer target$,
) =>
    target$.createRenderObject;
Function _IgnorePointer_updateRenderObject$(
  m.Scope scope$,
  IgnorePointer target$,
) =>
    target$.updateRenderObject;
Function _IgnorePointer_debugFillProperties$(
  m.Scope scope$,
  IgnorePointer target$,
) =>
    target$.debugFillProperties;
Function AbsorbPointer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AbsorbPointer;
Function AbsorbPointer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AbsorbPointer;
Function _AbsorbPointer_absorbing$(
  m.Scope scope$,
  AbsorbPointer target$,
) =>
    () {
      return target$.absorbing;
    };
Function _AbsorbPointer_ignoringSemantics$(
  m.Scope scope$,
  AbsorbPointer target$,
) =>
    () {
      return target$.ignoringSemantics;
    };
Function _AbsorbPointer__$(m.Scope scope$) => ({
      Key? key,
      bool? absorbing,
      Widget? child,
      bool? ignoringSemantics,
    }) {
      return AbsorbPointer(
        absorbing: absorbing ?? true,
        child: child,
        ignoringSemantics: ignoringSemantics,
        key: key,
      );
    };
Function _AbsorbPointer_createRenderObject$(
  m.Scope scope$,
  AbsorbPointer target$,
) =>
    target$.createRenderObject;
Function _AbsorbPointer_updateRenderObject$(
  m.Scope scope$,
  AbsorbPointer target$,
) =>
    target$.updateRenderObject;
Function _AbsorbPointer_debugFillProperties$(
  m.Scope scope$,
  AbsorbPointer target$,
) =>
    target$.debugFillProperties;
Function MetaData_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MetaData;
Function MetaData_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MetaData;
Function _MetaData_metaData$(
  m.Scope scope$,
  MetaData target$,
) =>
    () {
      return target$.metaData;
    };
Function _MetaData_behavior$(
  m.Scope scope$,
  MetaData target$,
) =>
    () {
      return target$.behavior;
    };
Function _MetaData__$(m.Scope scope$) => ({
      Key? key,
      dynamic? metaData,
      HitTestBehavior? behavior,
      Widget? child,
    }) {
      return MetaData(
        behavior: behavior ?? HitTestBehavior.deferToChild,
        child: child,
        key: key,
        metaData: metaData,
      );
    };
Function _MetaData_createRenderObject$(
  m.Scope scope$,
  MetaData target$,
) =>
    target$.createRenderObject;
Function _MetaData_updateRenderObject$(
  m.Scope scope$,
  MetaData target$,
) =>
    target$.updateRenderObject;
Function _MetaData_debugFillProperties$(
  m.Scope scope$,
  MetaData target$,
) =>
    target$.debugFillProperties;
Function Semantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Semantics;
Function Semantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Semantics;
Function _Semantics_properties$(
  m.Scope scope$,
  Semantics target$,
) =>
    () {
      return target$.properties;
    };
Function _Semantics_container$(
  m.Scope scope$,
  Semantics target$,
) =>
    () {
      return target$.container;
    };
Function _Semantics_explicitChildNodes$(
  m.Scope scope$,
  Semantics target$,
) =>
    () {
      return target$.explicitChildNodes;
    };
Function _Semantics_excludeSemantics$(
  m.Scope scope$,
  Semantics target$,
) =>
    () {
      return target$.excludeSemantics;
    };
Function _Semantics__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      bool? container,
      bool? explicitChildNodes,
      bool? excludeSemantics,
      bool? enabled,
      bool? checked,
      bool? mixed,
      bool? selected,
      bool? toggled,
      bool? button,
      bool? slider,
      bool? keyboardKey,
      bool? link,
      bool? header,
      bool? textField,
      bool? readOnly,
      bool? focusable,
      bool? focused,
      bool? inMutuallyExclusiveGroup,
      bool? obscured,
      bool? multiline,
      bool? scopesRoute,
      bool? namesRoute,
      bool? hidden,
      bool? image,
      bool? liveRegion,
      int? maxValueLength,
      int? currentValueLength,
      String? label,
      AttributedString? attributedLabel,
      String? value,
      AttributedString? attributedValue,
      String? increasedValue,
      AttributedString? attributedIncreasedValue,
      String? decreasedValue,
      AttributedString? attributedDecreasedValue,
      String? hint,
      AttributedString? attributedHint,
      String? tooltip,
      String? onTapHint,
      String? onLongPressHint,
      TextDirection? textDirection,
      SemanticsSortKey? sortKey,
      SemanticsTag? tagForChildren,
      m.FunctionPointer? onTap,
      m.FunctionPointer? onLongPress,
      m.FunctionPointer? onScrollLeft,
      m.FunctionPointer? onScrollRight,
      m.FunctionPointer? onScrollUp,
      m.FunctionPointer? onScrollDown,
      m.FunctionPointer? onIncrease,
      m.FunctionPointer? onDecrease,
      m.FunctionPointer? onCopy,
      m.FunctionPointer? onCut,
      m.FunctionPointer? onPaste,
      m.FunctionPointer? onDismiss,
      m.FunctionPointer? onMoveCursorForwardByCharacter,
      m.FunctionPointer? onMoveCursorBackwardByCharacter,
      m.FunctionPointer? onSetSelection,
      m.FunctionPointer? onSetText,
      m.FunctionPointer? onDidGainAccessibilityFocus,
      m.FunctionPointer? onDidLoseAccessibilityFocus,
      Map? customSemanticsActions,
    }) {
      void onCopyProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onCopy!,
            [],
            {},
          );
      void onCutProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onCut!,
            [],
            {},
          );
      void onDecreaseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDecrease!,
            [],
            {},
          );
      void onDidGainAccessibilityFocusProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDidGainAccessibilityFocus!,
            [],
            {},
          );
      void onDidLoseAccessibilityFocusProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            onDidLoseAccessibilityFocus!,
            [],
            {},
          );
      void onDismissProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDismiss!,
            [],
            {},
          );
      void onIncreaseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onIncrease!,
            [],
            {},
          );
      void onLongPressProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onLongPress!,
            [],
            {},
          );
      void onMoveCursorBackwardByCharacterProxy(
              bool onMoveCursorBackwardByCharacter_extendSelection$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onMoveCursorBackwardByCharacter!,
            [onMoveCursorBackwardByCharacter_extendSelection$],
            {},
          );
      void onMoveCursorForwardByCharacterProxy(
              bool onMoveCursorForwardByCharacter_extendSelection$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onMoveCursorForwardByCharacter!,
            [onMoveCursorForwardByCharacter_extendSelection$],
            {},
          );
      void onPasteProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPaste!,
            [],
            {},
          );
      void onScrollDownProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollDown!,
            [],
            {},
          );
      void onScrollLeftProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollLeft!,
            [],
            {},
          );
      void onScrollRightProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollRight!,
            [],
            {},
          );
      void onScrollUpProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onScrollUp!,
            [],
            {},
          );
      void onSetSelectionProxy(TextSelection onSetSelection_selection$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSetSelection!,
            [onSetSelection_selection$],
            {},
          );
      void onSetTextProxy(String onSetText_text$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSetText!,
            [onSetText_text$],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      return Semantics(
        attributedDecreasedValue: attributedDecreasedValue,
        attributedHint: attributedHint,
        attributedIncreasedValue: attributedIncreasedValue,
        attributedLabel: attributedLabel,
        attributedValue: attributedValue,
        button: button,
        checked: checked,
        child: child,
        container: container ?? false,
        currentValueLength: currentValueLength,
        customSemanticsActions: customSemanticsActions == null
            ? null
            : Map.from(customSemanticsActions),
        decreasedValue: decreasedValue,
        enabled: enabled,
        excludeSemantics: excludeSemantics ?? false,
        explicitChildNodes: explicitChildNodes ?? false,
        focusable: focusable,
        focused: focused,
        header: header,
        hidden: hidden,
        hint: hint,
        image: image,
        inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
        increasedValue: increasedValue,
        key: key,
        keyboardKey: keyboardKey,
        label: label,
        link: link,
        liveRegion: liveRegion,
        maxValueLength: maxValueLength,
        mixed: mixed,
        multiline: multiline,
        namesRoute: namesRoute,
        obscured: obscured,
        onCopy: onCopy == null ? null : onCopyProxy,
        onCut: onCut == null ? null : onCutProxy,
        onDecrease: onDecrease == null ? null : onDecreaseProxy,
        onDidGainAccessibilityFocus: onDidGainAccessibilityFocus == null
            ? null
            : onDidGainAccessibilityFocusProxy,
        onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus == null
            ? null
            : onDidLoseAccessibilityFocusProxy,
        onDismiss: onDismiss == null ? null : onDismissProxy,
        onIncrease: onIncrease == null ? null : onIncreaseProxy,
        onLongPress: onLongPress == null ? null : onLongPressProxy,
        onLongPressHint: onLongPressHint,
        onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter == null
            ? null
            : onMoveCursorBackwardByCharacterProxy,
        onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter == null
            ? null
            : onMoveCursorForwardByCharacterProxy,
        onPaste: onPaste == null ? null : onPasteProxy,
        onScrollDown: onScrollDown == null ? null : onScrollDownProxy,
        onScrollLeft: onScrollLeft == null ? null : onScrollLeftProxy,
        onScrollRight: onScrollRight == null ? null : onScrollRightProxy,
        onScrollUp: onScrollUp == null ? null : onScrollUpProxy,
        onSetSelection: onSetSelection == null ? null : onSetSelectionProxy,
        onSetText: onSetText == null ? null : onSetTextProxy,
        onTap: onTap == null ? null : onTapProxy,
        onTapHint: onTapHint,
        readOnly: readOnly,
        scopesRoute: scopesRoute,
        selected: selected,
        slider: slider,
        sortKey: sortKey,
        tagForChildren: tagForChildren,
        textDirection: textDirection,
        textField: textField,
        toggled: toggled,
        tooltip: tooltip,
        value: value,
      );
    };
Function _Semantics_fromProperties_$(m.Scope scope$) =>
    Semantics.fromProperties;
Function _Semantics_createRenderObject$(
  m.Scope scope$,
  Semantics target$,
) =>
    target$.createRenderObject;
Function _Semantics_updateRenderObject$(
  m.Scope scope$,
  Semantics target$,
) =>
    target$.updateRenderObject;
Function _Semantics_debugFillProperties$(
  m.Scope scope$,
  Semantics target$,
) =>
    target$.debugFillProperties;
Function MergeSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MergeSemantics;
Function MergeSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MergeSemantics;
Function _MergeSemantics__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
    }) {
      return MergeSemantics(
        child: child,
        key: key,
      );
    };
Function _MergeSemantics_createRenderObject$(
  m.Scope scope$,
  MergeSemantics target$,
) =>
    target$.createRenderObject;
Function BlockSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BlockSemantics;
Function BlockSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BlockSemantics;
Function _BlockSemantics_blocking$(
  m.Scope scope$,
  BlockSemantics target$,
) =>
    () {
      return target$.blocking;
    };
Function _BlockSemantics__$(m.Scope scope$) => ({
      Key? key,
      bool? blocking,
      Widget? child,
    }) {
      return BlockSemantics(
        blocking: blocking ?? true,
        child: child,
        key: key,
      );
    };
Function _BlockSemantics_createRenderObject$(
  m.Scope scope$,
  BlockSemantics target$,
) =>
    target$.createRenderObject;
Function _BlockSemantics_updateRenderObject$(
  m.Scope scope$,
  BlockSemantics target$,
) =>
    target$.updateRenderObject;
Function _BlockSemantics_debugFillProperties$(
  m.Scope scope$,
  BlockSemantics target$,
) =>
    target$.debugFillProperties;
Function ExcludeSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ExcludeSemantics;
Function ExcludeSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ExcludeSemantics;
Function _ExcludeSemantics_excluding$(
  m.Scope scope$,
  ExcludeSemantics target$,
) =>
    () {
      return target$.excluding;
    };
Function _ExcludeSemantics__$(m.Scope scope$) => ({
      Key? key,
      bool? excluding,
      Widget? child,
    }) {
      return ExcludeSemantics(
        child: child,
        excluding: excluding ?? true,
        key: key,
      );
    };
Function _ExcludeSemantics_createRenderObject$(
  m.Scope scope$,
  ExcludeSemantics target$,
) =>
    target$.createRenderObject;
Function _ExcludeSemantics_updateRenderObject$(
  m.Scope scope$,
  ExcludeSemantics target$,
) =>
    target$.updateRenderObject;
Function _ExcludeSemantics_debugFillProperties$(
  m.Scope scope$,
  ExcludeSemantics target$,
) =>
    target$.debugFillProperties;
Function IndexedSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as IndexedSemantics;
Function IndexedSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is IndexedSemantics;
Function _IndexedSemantics_index$(
  m.Scope scope$,
  IndexedSemantics target$,
) =>
    () {
      return target$.index;
    };
Function _IndexedSemantics__$(m.Scope scope$) => ({
      Key? key,
      required int index,
      Widget? child,
    }) {
      return IndexedSemantics(
        child: child,
        index: index,
        key: key,
      );
    };
Function _IndexedSemantics_createRenderObject$(
  m.Scope scope$,
  IndexedSemantics target$,
) =>
    target$.createRenderObject;
Function _IndexedSemantics_updateRenderObject$(
  m.Scope scope$,
  IndexedSemantics target$,
) =>
    target$.updateRenderObject;
Function _IndexedSemantics_debugFillProperties$(
  m.Scope scope$,
  IndexedSemantics target$,
) =>
    target$.debugFillProperties;
Function KeyedSubtree_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as KeyedSubtree;
Function KeyedSubtree_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is KeyedSubtree;
Function _KeyedSubtree_child$(
  m.Scope scope$,
  KeyedSubtree target$,
) =>
    () {
      return target$.child;
    };
Function _KeyedSubtree__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
    }) {
      return KeyedSubtree(
        child: child,
        key: key,
      );
    };
Function _KeyedSubtree_wrap_$(m.Scope scope$) => KeyedSubtree.wrap;
Function _KeyedSubtree_ensureUniqueKeysForList$(m.Scope scope$) =>
    KeyedSubtree.ensureUniqueKeysForList;
Function _KeyedSubtree_build$(
  m.Scope scope$,
  KeyedSubtree target$,
) =>
    target$.build;
Function Builder_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Builder;
Function Builder_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Builder;
Function _Builder_builder$(
  m.Scope scope$,
  Builder target$,
) =>
    () {
      return target$.builder;
    };
Function _Builder__$(m.Scope scope$) => ({
      Key? key,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(BuildContext builder_context$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [builder_context$],
            {},
          );
      return Builder(
        builder: builderProxy,
        key: key,
      );
    };
Function _Builder_build$(
  m.Scope scope$,
  Builder target$,
) =>
    target$.build;
Function StatefulBuilder_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StatefulBuilder;
Function StatefulBuilder_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StatefulBuilder;
Function _StatefulBuilder_builder$(
  m.Scope scope$,
  StatefulBuilder target$,
) =>
    () {
      return target$.builder;
    };
Function _StatefulBuilder__$(m.Scope scope$) => ({
      Key? key,
      required m.FunctionPointer builder,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        void Function(void Function()) builder_setState$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder,
            [
              builder_context$,
              builder_setState$,
            ],
            {},
          );
      return StatefulBuilder(
        builder: builderProxy,
        key: key,
      );
    };
Function _StatefulBuilder_createState$(
  m.Scope scope$,
  StatefulBuilder target$,
) =>
    target$.createState;
Function ColoredBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ColoredBox;
Function ColoredBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ColoredBox;
Function _ColoredBox_color$(
  m.Scope scope$,
  ColoredBox target$,
) =>
    () {
      return target$.color;
    };
Function _ColoredBox__$(m.Scope scope$) => ({
      required Color color,
      Widget? child,
      Key? key,
    }) {
      return ColoredBox(
        child: child,
        color: color,
        key: key,
      );
    };
Function _ColoredBox_createRenderObject$(
  m.Scope scope$,
  ColoredBox target$,
) =>
    target$.createRenderObject;
Function _ColoredBox_updateRenderObject$(
  m.Scope scope$,
  ColoredBox target$,
) =>
    target$.updateRenderObject;
Function _ColoredBox_debugFillProperties$(
  m.Scope scope$,
  ColoredBox target$,
) =>
    target$.debugFillProperties;
Function _getAxisDirectionFromAxisReverseAndDirectionality$(m.Scope scope$) =>
    getAxisDirectionFromAxisReverseAndDirectionality;
