// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/scroll_position_with_single_context.dart';
import 'dart:math';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/scroll_activity.dart';
import 'package:flutter/src/widgets/scroll_context.dart';
import 'package:flutter/src/widgets/scroll_notification.dart';
import 'package:flutter/src/widgets/scroll_physics.dart';
import 'package:flutter/src/widgets/scroll_position.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/scroll_position_with_single_context.dart',
  {
    'ScrollPositionWithSingleContext.': _ScrollPositionWithSingleContext__$,
    'ScrollPositionWithSingleContext.hold':
        _ScrollPositionWithSingleContext_hold$,
    'ScrollPositionWithSingleContext.drag':
        _ScrollPositionWithSingleContext_drag$,
  },
  {},
  {
    'ScrollPositionWithSingleContext': m.ClassMirror(
      'ScrollPositionWithSingleContext',
      {
        '#as': ScrollPositionWithSingleContext_as$,
        '#is': ScrollPositionWithSingleContext_is$,
        'axisDirection': _ScrollPositionWithSingleContext_axisDirection$,
        'userScrollDirection':
            _ScrollPositionWithSingleContext_userScrollDirection$,
        'setPixels': _ScrollPositionWithSingleContext_setPixels$,
        'absorb': _ScrollPositionWithSingleContext_absorb$,
        'applyNewDimensions':
            _ScrollPositionWithSingleContext_applyNewDimensions$,
        'beginActivity': _ScrollPositionWithSingleContext_beginActivity$,
        'applyUserOffset': _ScrollPositionWithSingleContext_applyUserOffset$,
        'goIdle': _ScrollPositionWithSingleContext_goIdle$,
        'goBallistic': _ScrollPositionWithSingleContext_goBallistic$,
        'updateUserScrollDirection':
            _ScrollPositionWithSingleContext_updateUserScrollDirection$,
        'animateTo': _ScrollPositionWithSingleContext_animateTo$,
        'jumpTo': _ScrollPositionWithSingleContext_jumpTo$,
        'pointerScroll': _ScrollPositionWithSingleContext_pointerScroll$,
        'dispose': _ScrollPositionWithSingleContext_dispose$,
        'debugFillDescription':
            _ScrollPositionWithSingleContext_debugFillDescription$,
      },
      {},
    )
  },
);
Function ScrollPositionWithSingleContext_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ScrollPositionWithSingleContext;
Function ScrollPositionWithSingleContext_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ScrollPositionWithSingleContext;
Function _ScrollPositionWithSingleContext_axisDirection$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    () {
      return target$.axisDirection;
    };
Function _ScrollPositionWithSingleContext_userScrollDirection$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    () {
      return target$.userScrollDirection;
    };
Function _ScrollPositionWithSingleContext__$(m.Scope scope$) => ({
      required ScrollPhysics physics,
      required ScrollContext context,
      double? initialPixels,
      bool? keepScrollOffset,
      ScrollPosition? oldPosition,
      String? debugLabel,
    }) {
      return ScrollPositionWithSingleContext(
        context: context,
        debugLabel: debugLabel,
        initialPixels: initialPixels ?? 0.0,
        keepScrollOffset: keepScrollOffset ?? true,
        oldPosition: oldPosition,
        physics: physics,
      );
    };
Function _ScrollPositionWithSingleContext_setPixels$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.setPixels;
Function _ScrollPositionWithSingleContext_absorb$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.absorb;
Function _ScrollPositionWithSingleContext_applyNewDimensions$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.applyNewDimensions;
Function _ScrollPositionWithSingleContext_beginActivity$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.beginActivity;
Function _ScrollPositionWithSingleContext_applyUserOffset$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.applyUserOffset;
Function _ScrollPositionWithSingleContext_goIdle$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.goIdle;
Function _ScrollPositionWithSingleContext_goBallistic$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.goBallistic;
Function _ScrollPositionWithSingleContext_updateUserScrollDirection$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.updateUserScrollDirection;
Function _ScrollPositionWithSingleContext_animateTo$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.animateTo;
Function _ScrollPositionWithSingleContext_jumpTo$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.jumpTo;
Function _ScrollPositionWithSingleContext_pointerScroll$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.pointerScroll;
Function _ScrollPositionWithSingleContext_hold$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    (m.FunctionPointer holdCancelCallback) {
      void holdCancelCallbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            holdCancelCallback,
            [],
            {},
          );
      return target$.hold(holdCancelCallbackProxy);
    };
Function _ScrollPositionWithSingleContext_drag$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    (
      DragStartDetails details,
      m.FunctionPointer dragCancelCallback,
    ) {
      void dragCancelCallbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            dragCancelCallback,
            [],
            {},
          );
      return target$.drag(
        details,
        dragCancelCallbackProxy,
      );
    };
Function _ScrollPositionWithSingleContext_dispose$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.dispose;
Function _ScrollPositionWithSingleContext_debugFillDescription$(
  m.Scope scope$,
  ScrollPositionWithSingleContext target$,
) =>
    target$.debugFillDescription;
