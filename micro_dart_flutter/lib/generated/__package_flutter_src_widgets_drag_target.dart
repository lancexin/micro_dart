// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/drag_target.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/debug.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/media_query.dart';
import 'package:flutter/src/widgets/overlay.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/drag_target.dart',
  {
    'Draggable.createRecognizer': _Draggable_createRecognizer$,
    'LongPressDraggable.createRecognizer':
        _LongPressDraggable_createRecognizer$,
    'childDragAnchorStrategy': _childDragAnchorStrategy$,
    'pointerDragAnchorStrategy': _pointerDragAnchorStrategy$,
  },
  {},
  {
    'Draggable': m.ClassMirror(
      'Draggable',
      {
        '#as': Draggable_as$,
        '#is': Draggable_is$,
        'data': _Draggable_data$,
        'axis': _Draggable_axis$,
        'child': _Draggable_child$,
        'childWhenDragging': _Draggable_childWhenDragging$,
        'feedback': _Draggable_feedback$,
        'feedbackOffset': _Draggable_feedbackOffset$,
        'dragAnchorStrategy': _Draggable_dragAnchorStrategy$,
        'ignoringFeedbackSemantics': _Draggable_ignoringFeedbackSemantics$,
        'ignoringFeedbackPointer': _Draggable_ignoringFeedbackPointer$,
        'affinity': _Draggable_affinity$,
        'maxSimultaneousDrags': _Draggable_maxSimultaneousDrags$,
        'onDragStarted': _Draggable_onDragStarted$,
        'onDragUpdate': _Draggable_onDragUpdate$,
        'onDraggableCanceled': _Draggable_onDraggableCanceled$,
        'onDragCompleted': _Draggable_onDragCompleted$,
        'onDragEnd': _Draggable_onDragEnd$,
        'rootOverlay': _Draggable_rootOverlay$,
        'hitTestBehavior': _Draggable_hitTestBehavior$,
        'allowedButtonsFilter': _Draggable_allowedButtonsFilter$,
        'createState': _Draggable_createState$,
      },
      {},
    ),
    'LongPressDraggable': m.ClassMirror(
      'LongPressDraggable',
      {
        '#as': LongPressDraggable_as$,
        '#is': LongPressDraggable_is$,
        'hapticFeedbackOnStart': _LongPressDraggable_hapticFeedbackOnStart$,
        'delay': _LongPressDraggable_delay$,
      },
      {},
    ),
    'DraggableDetails': m.ClassMirror(
      'DraggableDetails',
      {
        '#as': DraggableDetails_as$,
        '#is': DraggableDetails_is$,
        'wasAccepted': _DraggableDetails_wasAccepted$,
        'velocity': _DraggableDetails_velocity$,
        'offset': _DraggableDetails_offset$,
      },
      {},
    ),
    'DragTargetDetails': m.ClassMirror(
      'DragTargetDetails',
      {
        '#as': DragTargetDetails_as$,
        '#is': DragTargetDetails_is$,
        'data': _DragTargetDetails_data$,
        'offset': _DragTargetDetails_offset$,
      },
      {},
    ),
    'DragTarget': m.ClassMirror(
      'DragTarget',
      {
        '#as': DragTarget_as$,
        '#is': DragTarget_is$,
        'builder': _DragTarget_builder$,
        'onWillAccept': _DragTarget_onWillAccept$,
        'onAccept': _DragTarget_onAccept$,
        'onAcceptWithDetails': _DragTarget_onAcceptWithDetails$,
        'onLeave': _DragTarget_onLeave$,
        'onMove': _DragTarget_onMove$,
        'hitTestBehavior': _DragTarget_hitTestBehavior$,
        'createState': _DragTarget_createState$,
      },
      {},
    ),
  },
);
Function Draggable_as$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as Draggable<T>;
Function Draggable_is$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is Draggable<T>;
T? _Draggable_data$<T extends Object>(Draggable<T> target) {
  return target.data;
}

Axis? _Draggable_axis$<T extends Object>(Draggable<T> target) {
  return target.axis;
}

Widget _Draggable_child$<T extends Object>(Draggable<T> target) {
  return target.child;
}

Widget? _Draggable_childWhenDragging$<T extends Object>(Draggable<T> target) {
  return target.childWhenDragging;
}

Widget _Draggable_feedback$<T extends Object>(Draggable<T> target) {
  return target.feedback;
}

Offset _Draggable_feedbackOffset$<T extends Object>(Draggable<T> target) {
  return target.feedbackOffset;
}

Offset Function(Draggable<Object>, BuildContext, Offset)
    _Draggable_dragAnchorStrategy$<T extends Object>(Draggable<T> target) {
  return target.dragAnchorStrategy;
}

bool _Draggable_ignoringFeedbackSemantics$<T extends Object>(
    Draggable<T> target) {
  return target.ignoringFeedbackSemantics;
}

bool _Draggable_ignoringFeedbackPointer$<T extends Object>(
    Draggable<T> target) {
  return target.ignoringFeedbackPointer;
}

Axis? _Draggable_affinity$<T extends Object>(Draggable<T> target) {
  return target.affinity;
}

int? _Draggable_maxSimultaneousDrags$<T extends Object>(Draggable<T> target) {
  return target.maxSimultaneousDrags;
}

void Function()? _Draggable_onDragStarted$<T extends Object>(
    Draggable<T> target) {
  return target.onDragStarted;
}

void Function(DragUpdateDetails)? _Draggable_onDragUpdate$<T extends Object>(
    Draggable<T> target) {
  return target.onDragUpdate;
}

void Function(Velocity, Offset)?
    _Draggable_onDraggableCanceled$<T extends Object>(Draggable<T> target) {
  return target.onDraggableCanceled;
}

void Function()? _Draggable_onDragCompleted$<T extends Object>(
    Draggable<T> target) {
  return target.onDragCompleted;
}

void Function(DraggableDetails)? _Draggable_onDragEnd$<T extends Object>(
    Draggable<T> target) {
  return target.onDragEnd;
}

bool _Draggable_rootOverlay$<T extends Object>(Draggable<T> target) {
  return target.rootOverlay;
}

HitTestBehavior _Draggable_hitTestBehavior$<T extends Object>(
    Draggable<T> target) {
  return target.hitTestBehavior;
}

bool Function(int)? _Draggable_allowedButtonsFilter$<T extends Object>(
    Draggable<T> target) {
  return target.allowedButtonsFilter;
}

Function _Draggable_createRecognizer$<T extends Object>(
  m.Scope scope,
  Draggable<T> target,
) =>
    (m.FunctionPointer onStart) {
      Drag? onStartProxy(Offset onStart_position) =>
          scope.engine.callFunctionPointer(
            scope,
            onStart,
            [onStart_position],
            {},
          );
      return target.createRecognizer(onStartProxy);
    };
Function _Draggable_createState$<T extends Object>(
  m.Scope scope,
  Draggable<T> target,
) =>
    target.createState;
Function LongPressDraggable_as$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as LongPressDraggable<T>;
Function LongPressDraggable_is$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is LongPressDraggable<T>;
bool _LongPressDraggable_hapticFeedbackOnStart$<T extends Object>(
    LongPressDraggable<T> target) {
  return target.hapticFeedbackOnStart;
}

Duration _LongPressDraggable_delay$<T extends Object>(
    LongPressDraggable<T> target) {
  return target.delay;
}

Function _LongPressDraggable_createRecognizer$<T extends Object>(
  m.Scope scope,
  LongPressDraggable<T> target,
) =>
    (m.FunctionPointer onStart) {
      Drag? onStartProxy(Offset onStart_position) =>
          scope.engine.callFunctionPointer(
            scope,
            onStart,
            [onStart_position],
            {},
          );
      return target.createRecognizer(onStartProxy);
    };
Function DraggableDetails_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as DraggableDetails;
Function DraggableDetails_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is DraggableDetails;
bool _DraggableDetails_wasAccepted$(DraggableDetails target) {
  return target.wasAccepted;
}

Velocity _DraggableDetails_velocity$(DraggableDetails target) {
  return target.velocity;
}

Offset _DraggableDetails_offset$(DraggableDetails target) {
  return target.offset;
}

Function DragTargetDetails_as$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as DragTargetDetails<T>;
Function DragTargetDetails_is$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is DragTargetDetails<T>;
T _DragTargetDetails_data$<T>(DragTargetDetails<T> target) {
  return target.data;
}

Offset _DragTargetDetails_offset$<T>(DragTargetDetails<T> target) {
  return target.offset;
}

Function DragTarget_as$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as DragTarget<T>;
Function DragTarget_is$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is DragTarget<T>;
Widget Function(BuildContext, List<T?>, List<dynamic>)
    _DragTarget_builder$<T extends Object>(DragTarget<T> target) {
  return target.builder;
}

bool Function(T?)? _DragTarget_onWillAccept$<T extends Object>(
    DragTarget<T> target) {
  return target.onWillAccept;
}

void Function(T)? _DragTarget_onAccept$<T extends Object>(
    DragTarget<T> target) {
  return target.onAccept;
}

void Function(DragTargetDetails<T>)?
    _DragTarget_onAcceptWithDetails$<T extends Object>(DragTarget<T> target) {
  return target.onAcceptWithDetails;
}

void Function(T?)? _DragTarget_onLeave$<T extends Object>(
    DragTarget<T> target) {
  return target.onLeave;
}

void Function(DragTargetDetails<T>)? _DragTarget_onMove$<T extends Object>(
    DragTarget<T> target) {
  return target.onMove;
}

HitTestBehavior _DragTarget_hitTestBehavior$<T extends Object>(
    DragTarget<T> target) {
  return target.hitTestBehavior;
}

Function _DragTarget_createState$<T extends Object>(
  m.Scope scope,
  DragTarget<T> target,
) =>
    target.createState;
Function _childDragAnchorStrategy$(m.Scope scope) => childDragAnchorStrategy;
Function _pointerDragAnchorStrategy$(m.Scope scope) =>
    pointerDragAnchorStrategy;
