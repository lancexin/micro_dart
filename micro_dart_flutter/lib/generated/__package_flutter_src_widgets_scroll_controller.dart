// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/scroll_controller.dart';
import 'package:flutter/animation.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/scroll_context.dart';
import 'package:flutter/src/widgets/scroll_physics.dart';
import 'package:flutter/src/widgets/scroll_position.dart';
import 'package:flutter/src/widgets/scroll_position_with_single_context.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/scroll_controller.dart',
  {},
  {},
  {
    'ScrollController': m.ClassMirror(
      'ScrollController',
      {
        '#as': ScrollController_as$,
        '#is': ScrollController_is$,
        'keepScrollOffset': _ScrollController_keepScrollOffset$,
        'debugLabel': _ScrollController_debugLabel$,
        'initialScrollOffset': _ScrollController_initialScrollOffset$,
        'positions': _ScrollController_positions$,
        'hasClients': _ScrollController_hasClients$,
        'position': _ScrollController_position$,
        'offset': _ScrollController_offset$,
        'animateTo': _ScrollController_animateTo$,
        'jumpTo': _ScrollController_jumpTo$,
        'attach': _ScrollController_attach$,
        'detach': _ScrollController_detach$,
        'dispose': _ScrollController_dispose$,
        'createScrollPosition': _ScrollController_createScrollPosition$,
        'toString': _ScrollController_toString$,
        'debugFillDescription': _ScrollController_debugFillDescription$,
      },
      {},
    ),
    'TrackingScrollController': m.ClassMirror(
      'TrackingScrollController',
      {
        '#as': TrackingScrollController_as$,
        '#is': TrackingScrollController_is$,
        'mostRecentlyUpdatedPosition':
            _TrackingScrollController_mostRecentlyUpdatedPosition$,
        'initialScrollOffset': _TrackingScrollController_initialScrollOffset$,
        'attach': _TrackingScrollController_attach$,
        'detach': _TrackingScrollController_detach$,
        'dispose': _TrackingScrollController_dispose$,
      },
      {},
    ),
  },
);
Function ScrollController_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ScrollController;
Function ScrollController_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ScrollController;
bool _ScrollController_keepScrollOffset$(ScrollController target) {
  return target.keepScrollOffset;
}

String? _ScrollController_debugLabel$(ScrollController target) {
  return target.debugLabel;
}

double _ScrollController_initialScrollOffset$(ScrollController target) {
  return target.initialScrollOffset;
}

Iterable<ScrollPosition> _ScrollController_positions$(ScrollController target) {
  return target.positions;
}

bool _ScrollController_hasClients$(ScrollController target) {
  return target.hasClients;
}

ScrollPosition _ScrollController_position$(ScrollController target) {
  return target.position;
}

double _ScrollController_offset$(ScrollController target) {
  return target.offset;
}

Function _ScrollController_animateTo$(
  m.Scope scope,
  ScrollController target,
) =>
    target.animateTo;
Function _ScrollController_jumpTo$(
  m.Scope scope,
  ScrollController target,
) =>
    target.jumpTo;
Function _ScrollController_attach$(
  m.Scope scope,
  ScrollController target,
) =>
    target.attach;
Function _ScrollController_detach$(
  m.Scope scope,
  ScrollController target,
) =>
    target.detach;
Function _ScrollController_dispose$(
  m.Scope scope,
  ScrollController target,
) =>
    target.dispose;
Function _ScrollController_createScrollPosition$(
  m.Scope scope,
  ScrollController target,
) =>
    target.createScrollPosition;
Function _ScrollController_toString$(
  m.Scope scope,
  ScrollController target,
) =>
    target.toString;
Function _ScrollController_debugFillDescription$(
  m.Scope scope,
  ScrollController target,
) =>
    target.debugFillDescription;
Function TrackingScrollController_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as TrackingScrollController;
Function TrackingScrollController_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is TrackingScrollController;
ScrollPosition? _TrackingScrollController_mostRecentlyUpdatedPosition$(
    TrackingScrollController target) {
  return target.mostRecentlyUpdatedPosition;
}

double _TrackingScrollController_initialScrollOffset$(
    TrackingScrollController target) {
  return target.initialScrollOffset;
}

Function _TrackingScrollController_attach$(
  m.Scope scope,
  TrackingScrollController target,
) =>
    target.attach;
Function _TrackingScrollController_detach$(
  m.Scope scope,
  TrackingScrollController target,
) =>
    target.detach;
Function _TrackingScrollController_dispose$(
  m.Scope scope,
  TrackingScrollController target,
) =>
    target.dispose;
