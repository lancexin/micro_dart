// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/scroll_controller.dart';
import 'package:flutter/animation.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/scroll_context.dart';
import 'package:flutter/src/widgets/scroll_physics.dart';
import 'package:flutter/src/widgets/scroll_position.dart';
import 'package:flutter/src/widgets/scroll_position_with_single_context.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/scroll_controller.dart',
  {
    'ScrollController.': _ScrollController__$,
    'TrackingScrollController.': _TrackingScrollController__$,
  },
  {},
  {
    'ScrollController': m.ClassMirror(
      'ScrollController',
      {
        '#as': ScrollController_as$,
        '#is': ScrollController_is$,
        'keepScrollOffset': _ScrollController_keepScrollOffset$,
        'debugLabel': _ScrollController_debugLabel$,
        'initialScrollOffset': _ScrollController_initialScrollOffset$,
        'positions': _ScrollController_positions$,
        'hasClients': _ScrollController_hasClients$,
        'position': _ScrollController_position$,
        'offset': _ScrollController_offset$,
        'animateTo': _ScrollController_animateTo$,
        'jumpTo': _ScrollController_jumpTo$,
        'attach': _ScrollController_attach$,
        'detach': _ScrollController_detach$,
        'dispose': _ScrollController_dispose$,
        'createScrollPosition': _ScrollController_createScrollPosition$,
        'toString': _ScrollController_toString$,
        'debugFillDescription': _ScrollController_debugFillDescription$,
      },
      {},
    ),
    'TrackingScrollController': m.ClassMirror(
      'TrackingScrollController',
      {
        '#as': TrackingScrollController_as$,
        '#is': TrackingScrollController_is$,
        'mostRecentlyUpdatedPosition':
            _TrackingScrollController_mostRecentlyUpdatedPosition$,
        'initialScrollOffset': _TrackingScrollController_initialScrollOffset$,
        'attach': _TrackingScrollController_attach$,
        'detach': _TrackingScrollController_detach$,
        'dispose': _TrackingScrollController_dispose$,
      },
      {},
    ),
  },
);
Function ScrollController_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ScrollController;
Function ScrollController_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ScrollController;
Function _ScrollController_keepScrollOffset$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.keepScrollOffset;
    };
Function _ScrollController_debugLabel$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.debugLabel;
    };
Function _ScrollController_initialScrollOffset$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.initialScrollOffset;
    };
Function _ScrollController_positions$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.positions;
    };
Function _ScrollController_hasClients$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.hasClients;
    };
Function _ScrollController_position$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.position;
    };
Function _ScrollController_offset$(
  m.Scope scope$,
  ScrollController target$,
) =>
    () {
      return target$.offset;
    };
Function _ScrollController__$(m.Scope scope$) => ({
      double? initialScrollOffset,
      bool? keepScrollOffset,
      String? debugLabel,
    }) {
      return ScrollController(
        debugLabel: debugLabel,
        initialScrollOffset: initialScrollOffset ?? 0.0,
        keepScrollOffset: keepScrollOffset ?? true,
      );
    };
Function _ScrollController_animateTo$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.animateTo;
Function _ScrollController_jumpTo$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.jumpTo;
Function _ScrollController_attach$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.attach;
Function _ScrollController_detach$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.detach;
Function _ScrollController_dispose$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.dispose;
Function _ScrollController_createScrollPosition$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.createScrollPosition;
Function _ScrollController_toString$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.toString;
Function _ScrollController_debugFillDescription$(
  m.Scope scope$,
  ScrollController target$,
) =>
    target$.debugFillDescription;
Function TrackingScrollController_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TrackingScrollController;
Function TrackingScrollController_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TrackingScrollController;
Function _TrackingScrollController_mostRecentlyUpdatedPosition$(
  m.Scope scope$,
  TrackingScrollController target$,
) =>
    () {
      return target$.mostRecentlyUpdatedPosition;
    };
Function _TrackingScrollController_initialScrollOffset$(
  m.Scope scope$,
  TrackingScrollController target$,
) =>
    () {
      return target$.initialScrollOffset;
    };
Function _TrackingScrollController__$(m.Scope scope$) => ({
      double? initialScrollOffset,
      bool? keepScrollOffset,
      String? debugLabel,
    }) {
      return TrackingScrollController(
        debugLabel: debugLabel,
        initialScrollOffset: initialScrollOffset ?? 0.0,
        keepScrollOffset: keepScrollOffset ?? true,
      );
    };
Function _TrackingScrollController_attach$(
  m.Scope scope$,
  TrackingScrollController target$,
) =>
    target$.attach;
Function _TrackingScrollController_detach$(
  m.Scope scope$,
  TrackingScrollController target$,
) =>
    target$.detach;
Function _TrackingScrollController_dispose$(
  m.Scope scope$,
  TrackingScrollController target$,
) =>
    target$.dispose;
