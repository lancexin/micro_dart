// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/text_painter.dart';
import 'dart:math' show max, min;
import 'dart:ui'
    show
        BoxHeightStyle,
        BoxWidthStyle,
        LineMetrics,
        Paragraph,
        ParagraphBuilder,
        ParagraphConstraints,
        ParagraphStyle,
        PlaceholderAlignment,
        TextHeightBehavior,
        TextStyle;
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/placeholder_span.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/painting/text_span.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/text_painter.dart',
  {
    'PlaceholderDimensions.empty': _PlaceholderDimensions_empty$,
    'PlaceholderDimensions.': _PlaceholderDimensions__$,
    'TextPainter.': _TextPainter__$,
    'TextPainter.computeWidth': _TextPainter_computeWidth$,
    'TextPainter.computeMaxIntrinsicWidth':
        _TextPainter_computeMaxIntrinsicWidth$,
    'TextOverflow.clip': _TextOverflow_clip$,
    'TextOverflow.fade': _TextOverflow_fade$,
    'TextOverflow.ellipsis': _TextOverflow_ellipsis$,
    'TextOverflow.visible': _TextOverflow_visible$,
    'TextOverflow.values': _TextOverflow_values$,
    'TextWidthBasis.parent': _TextWidthBasis_parent$,
    'TextWidthBasis.longestLine': _TextWidthBasis_longestLine$,
    'TextWidthBasis.values': _TextWidthBasis_values$,
  },
  {},
  {
    'PlaceholderDimensions': m.ClassMirror(
      'PlaceholderDimensions',
      {
        '#as': PlaceholderDimensions_as$,
        '#is': PlaceholderDimensions_is$,
        'size': _PlaceholderDimensions_size$,
        'alignment': _PlaceholderDimensions_alignment$,
        'baselineOffset': _PlaceholderDimensions_baselineOffset$,
        'baseline': _PlaceholderDimensions_baseline$,
        'hashCode': _PlaceholderDimensions_hashCode$,
        '==': _PlaceholderDimensions_eq$$,
        'toString': _PlaceholderDimensions_toString$,
      },
      {},
    ),
    'WordBoundary': m.ClassMirror(
      'WordBoundary',
      {
        '#as': WordBoundary_as$,
        '#is': WordBoundary_is$,
        'moveByWordBoundary': _WordBoundary_moveByWordBoundary$,
        'getTextBoundaryAt': _WordBoundary_getTextBoundaryAt$,
      },
      {},
    ),
    'TextPainter': m.ClassMirror(
      'TextPainter',
      {
        '#as': TextPainter_as$,
        '#is': TextPainter_is$,
        'text': _TextPainter_text$,
        'plainText': _TextPainter_plainText$,
        'textAlign': _TextPainter_textAlign$,
        'textDirection': _TextPainter_textDirection$,
        'textScaleFactor': _TextPainter_textScaleFactor$,
        'ellipsis': _TextPainter_ellipsis$,
        'locale': _TextPainter_locale$,
        'maxLines': _TextPainter_maxLines$,
        'strutStyle': _TextPainter_strutStyle$,
        'textWidthBasis': _TextPainter_textWidthBasis$,
        'textHeightBehavior': _TextPainter_textHeightBehavior$,
        'inlinePlaceholderBoxes': _TextPainter_inlinePlaceholderBoxes$,
        'preferredLineHeight': _TextPainter_preferredLineHeight$,
        'minIntrinsicWidth': _TextPainter_minIntrinsicWidth$,
        'maxIntrinsicWidth': _TextPainter_maxIntrinsicWidth$,
        'width': _TextPainter_width$,
        'height': _TextPainter_height$,
        'size': _TextPainter_size$,
        'didExceedMaxLines': _TextPainter_didExceedMaxLines$,
        'wordBoundaries': _TextPainter_wordBoundaries$,
        'debugDisposed': _TextPainter_debugDisposed$,
        'markNeedsLayout': _TextPainter_markNeedsLayout$,
        'setPlaceholderDimensions': _TextPainter_setPlaceholderDimensions$,
        'computeDistanceToActualBaseline':
            _TextPainter_computeDistanceToActualBaseline$,
        'layout': _TextPainter_layout$,
        'paint': _TextPainter_paint$,
        'getOffsetAfter': _TextPainter_getOffsetAfter$,
        'getOffsetBefore': _TextPainter_getOffsetBefore$,
        'getOffsetForCaret': _TextPainter_getOffsetForCaret$,
        'getFullHeightForCaret': _TextPainter_getFullHeightForCaret$,
        'getBoxesForSelection': _TextPainter_getBoxesForSelection$,
        'getPositionForOffset': _TextPainter_getPositionForOffset$,
        'getWordBoundary': _TextPainter_getWordBoundary$,
        'getLineBoundary': _TextPainter_getLineBoundary$,
        'computeLineMetrics': _TextPainter_computeLineMetrics$,
        'dispose': _TextPainter_dispose$,
      },
      {
        'text': _TextPainter_text_set$,
        'textAlign': _TextPainter_textAlign_set$,
        'textDirection': _TextPainter_textDirection_set$,
        'textScaleFactor': _TextPainter_textScaleFactor_set$,
        'ellipsis': _TextPainter_ellipsis_set$,
        'locale': _TextPainter_locale_set$,
        'maxLines': _TextPainter_maxLines_set$,
        'strutStyle': _TextPainter_strutStyle_set$,
        'textWidthBasis': _TextPainter_textWidthBasis_set$,
        'textHeightBehavior': _TextPainter_textHeightBehavior_set$,
      },
    ),
    'TextOverflow': m.ClassMirror(
      'TextOverflow',
      {},
      {},
    ),
    'TextWidthBasis': m.ClassMirror(
      'TextWidthBasis',
      {},
      {},
    ),
  },
);
Function PlaceholderDimensions_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PlaceholderDimensions;
Function PlaceholderDimensions_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PlaceholderDimensions;
Function _PlaceholderDimensions_empty$(m.Scope scope$) =>
    () => PlaceholderDimensions.empty;
Function _PlaceholderDimensions_size$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    () {
      return target$.size;
    };
Function _PlaceholderDimensions_alignment$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    () {
      return target$.alignment;
    };
Function _PlaceholderDimensions_baselineOffset$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    () {
      return target$.baselineOffset;
    };
Function _PlaceholderDimensions_baseline$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    () {
      return target$.baseline;
    };
Function _PlaceholderDimensions_hashCode$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    () {
      return target$.hashCode;
    };
Function _PlaceholderDimensions__$(m.Scope scope$) => ({
      required Size size,
      required PlaceholderAlignment alignment,
      TextBaseline? baseline,
      double? baselineOffset,
    }) {
      return PlaceholderDimensions(
        alignment: alignment,
        baseline: baseline,
        baselineOffset: baselineOffset,
        size: size,
      );
    };
Function _PlaceholderDimensions_eq$$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    (Object other$) => target$ == other$;
Function _PlaceholderDimensions_toString$(
  m.Scope scope$,
  PlaceholderDimensions target$,
) =>
    target$.toString;
Function WordBoundary_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as WordBoundary;
Function WordBoundary_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is WordBoundary;
Function _WordBoundary_moveByWordBoundary$(
  m.Scope scope$,
  WordBoundary target$,
) =>
    () {
      return target$.moveByWordBoundary;
    };
Function _WordBoundary_getTextBoundaryAt$(
  m.Scope scope$,
  WordBoundary target$,
) =>
    target$.getTextBoundaryAt;
Function TextPainter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextPainter;
Function TextPainter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextPainter;
Function _TextPainter_text$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.text;
    };
void _TextPainter_text_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.text = other$;
    };
Function _TextPainter_plainText$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.plainText;
    };
Function _TextPainter_textAlign$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.textAlign;
    };
void _TextPainter_textAlign_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.textAlign = other$;
    };
Function _TextPainter_textDirection$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.textDirection;
    };
void _TextPainter_textDirection_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _TextPainter_textScaleFactor$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.textScaleFactor;
    };
void _TextPainter_textScaleFactor_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.textScaleFactor = other$;
    };
Function _TextPainter_ellipsis$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.ellipsis;
    };
void _TextPainter_ellipsis_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.ellipsis = other$;
    };
Function _TextPainter_locale$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.locale;
    };
void _TextPainter_locale_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.locale = other$;
    };
Function _TextPainter_maxLines$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.maxLines;
    };
void _TextPainter_maxLines_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.maxLines = other$;
    };
Function _TextPainter_strutStyle$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.strutStyle;
    };
void _TextPainter_strutStyle_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.strutStyle = other$;
    };
Function _TextPainter_textWidthBasis$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.textWidthBasis;
    };
void _TextPainter_textWidthBasis_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.textWidthBasis = other$;
    };
Function _TextPainter_textHeightBehavior$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.textHeightBehavior;
    };
void _TextPainter_textHeightBehavior_set$(
  m.Scope scope$,
  TextPainter target$,
) =>
    (dynamic other$) {
      target$.textHeightBehavior = other$;
    };
Function _TextPainter_inlinePlaceholderBoxes$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.inlinePlaceholderBoxes;
    };

Function _TextPainter_preferredLineHeight$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.preferredLineHeight;
    };
Function _TextPainter_minIntrinsicWidth$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.minIntrinsicWidth;
    };
Function _TextPainter_maxIntrinsicWidth$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.maxIntrinsicWidth;
    };
Function _TextPainter_width$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.width;
    };
Function _TextPainter_height$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.height;
    };
Function _TextPainter_size$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.size;
    };
Function _TextPainter_didExceedMaxLines$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.didExceedMaxLines;
    };
Function _TextPainter_wordBoundaries$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.wordBoundaries;
    };
Function _TextPainter_debugDisposed$(
  m.Scope scope$,
  TextPainter target$,
) =>
    () {
      return target$.debugDisposed;
    };
Function _TextPainter__$(m.Scope scope$) => ({
      InlineSpan? text,
      TextAlign? textAlign,
      TextDirection? textDirection,
      double? textScaleFactor,
      int? maxLines,
      String? ellipsis,
      Locale? locale,
      StrutStyle? strutStyle,
      TextWidthBasis? textWidthBasis,
      TextHeightBehavior? textHeightBehavior,
    }) {
      return TextPainter(
        ellipsis: ellipsis,
        locale: locale,
        maxLines: maxLines,
        strutStyle: strutStyle,
        text: text,
        textAlign: textAlign ?? TextAlign.start,
        textDirection: textDirection,
        textHeightBehavior: textHeightBehavior,
        textScaleFactor: textScaleFactor ?? 1.0,
        textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
      );
    };
Function _TextPainter_computeWidth$(m.Scope scope$) => TextPainter.computeWidth;
Function _TextPainter_computeMaxIntrinsicWidth$(m.Scope scope$) =>
    TextPainter.computeMaxIntrinsicWidth;
Function _TextPainter_markNeedsLayout$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.markNeedsLayout;
Function _TextPainter_setPlaceholderDimensions$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.setPlaceholderDimensions;
Function _TextPainter_computeDistanceToActualBaseline$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.computeDistanceToActualBaseline;
Function _TextPainter_layout$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.layout;
Function _TextPainter_paint$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.paint;
Function _TextPainter_getOffsetAfter$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getOffsetAfter;
Function _TextPainter_getOffsetBefore$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getOffsetBefore;
Function _TextPainter_getOffsetForCaret$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getOffsetForCaret;
Function _TextPainter_getFullHeightForCaret$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getFullHeightForCaret;
Function _TextPainter_getBoxesForSelection$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getBoxesForSelection;
Function _TextPainter_getPositionForOffset$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getPositionForOffset;
Function _TextPainter_getWordBoundary$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getWordBoundary;
Function _TextPainter_getLineBoundary$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.getLineBoundary;
Function _TextPainter_computeLineMetrics$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.computeLineMetrics;
Function _TextPainter_dispose$(
  m.Scope scope$,
  TextPainter target$,
) =>
    target$.dispose;
Function _TextOverflow_clip$(m.Scope scope$) => () => TextOverflow.clip;
Function _TextOverflow_fade$(m.Scope scope$) => () => TextOverflow.fade;
Function _TextOverflow_ellipsis$(m.Scope scope$) => () => TextOverflow.ellipsis;
Function _TextOverflow_visible$(m.Scope scope$) => () => TextOverflow.visible;
Function _TextOverflow_values$(m.Scope scope$) => () => TextOverflow.values;
Function _TextWidthBasis_parent$(m.Scope scope$) => () => TextWidthBasis.parent;
Function _TextWidthBasis_longestLine$(m.Scope scope$) =>
    () => TextWidthBasis.longestLine;
Function _TextWidthBasis_values$(m.Scope scope$) => () => TextWidthBasis.values;
