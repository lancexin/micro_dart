// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:collection';
import 'dart:convert'
    show
        ascii,
        base64,
        Base64Codec,
        Encoding,
        latin1,
        StringConversionSink,
        utf8;
import 'dart:math' show Random;
import 'dart:typed_data' show Uint8List;

const libraryMirror = m.LibraryMirror(
  'dart:core',
  {
    'deprecated': _deprecated$,
    'override': _override$,
    'BigInt.zero': _BigInt_zero$,
    'BigInt.one': _BigInt_one$,
    'BigInt.two': _BigInt_two$,
    'BigInt.parse': _BigInt_parse$,
    'BigInt.tryParse': _BigInt_tryParse$,
    'bool.parse': _bool_parse$,
    'bool.tryParse': _bool_tryParse$,
    'Comparable.compare': _Comparable_compare$,
    'DateTime.monday': _DateTime_monday$,
    'DateTime.tuesday': _DateTime_tuesday$,
    'DateTime.wednesday': _DateTime_wednesday$,
    'DateTime.thursday': _DateTime_thursday$,
    'DateTime.friday': _DateTime_friday$,
    'DateTime.saturday': _DateTime_saturday$,
    'DateTime.sunday': _DateTime_sunday$,
    'DateTime.daysPerWeek': _DateTime_daysPerWeek$,
    'DateTime.january': _DateTime_january$,
    'DateTime.february': _DateTime_february$,
    'DateTime.march': _DateTime_march$,
    'DateTime.april': _DateTime_april$,
    'DateTime.may': _DateTime_may$,
    'DateTime.june': _DateTime_june$,
    'DateTime.july': _DateTime_july$,
    'DateTime.august': _DateTime_august$,
    'DateTime.september': _DateTime_september$,
    'DateTime.october': _DateTime_october$,
    'DateTime.november': _DateTime_november$,
    'DateTime.december': _DateTime_december$,
    'DateTime.monthsPerYear': _DateTime_monthsPerYear$,
    'DateTime.parse': _DateTime_parse$,
    'DateTime.tryParse': _DateTime_tryParse$,
    'double.nan': _double_nan$,
    'double.infinity': _double_infinity$,
    'double.negativeInfinity': _double_negativeInfinity$,
    'double.minPositive': _double_minPositive$,
    'double.maxFinite': _double_maxFinite$,
    'double.parse': _double_parse$,
    'double.tryParse': _double_tryParse$,
    'Duration.microsecondsPerMillisecond':
        _Duration_microsecondsPerMillisecond$,
    'Duration.millisecondsPerSecond': _Duration_millisecondsPerSecond$,
    'Duration.secondsPerMinute': _Duration_secondsPerMinute$,
    'Duration.minutesPerHour': _Duration_minutesPerHour$,
    'Duration.hoursPerDay': _Duration_hoursPerDay$,
    'Duration.microsecondsPerSecond': _Duration_microsecondsPerSecond$,
    'Duration.microsecondsPerMinute': _Duration_microsecondsPerMinute$,
    'Duration.microsecondsPerHour': _Duration_microsecondsPerHour$,
    'Duration.microsecondsPerDay': _Duration_microsecondsPerDay$,
    'Duration.millisecondsPerMinute': _Duration_millisecondsPerMinute$,
    'Duration.millisecondsPerHour': _Duration_millisecondsPerHour$,
    'Duration.millisecondsPerDay': _Duration_millisecondsPerDay$,
    'Duration.secondsPerHour': _Duration_secondsPerHour$,
    'Duration.secondsPerDay': _Duration_secondsPerDay$,
    'Duration.minutesPerDay': _Duration_minutesPerDay$,
    'Duration.zero': _Duration_zero$,
    'Enum.compareByIndex': _Enum_compareByIndex$,
    'Enum.compareByName': _Enum_compareByName$,
    'Error.safeToString': _Error_safeToString$,
    'Error.throwWithStackTrace': _Error_throwWithStackTrace$,
    'ArgumentError.checkNotNull': _ArgumentError_checkNotNull$,
    'RangeError.checkValueInInterval': _RangeError_checkValueInInterval$,
    'RangeError.checkValidIndex': _RangeError_checkValidIndex$,
    'RangeError.checkValidRange': _RangeError_checkValidRange$,
    'RangeError.checkNotNegative': _RangeError_checkNotNegative$,
    'IndexError.check': _IndexError_check$,
    'Function.apply': _Function_apply$,
    'identical': _identical$,
    'identityHashCode': _identityHashCode$,
    'int.parse': _int_parse$,
    'int.tryParse': _int_tryParse$,
    'Iterable.castFrom': _Iterable_castFrom$,
    'Iterable.iterableToShortString': _Iterable_iterableToShortString$,
    'Iterable.iterableToFullString': _Iterable_iterableToFullString$,
    'List.castFrom': _List_castFrom$,
    'List.copyRange': _List_copyRange$,
    'List.writeIterable': _List_writeIterable$,
    'Map.castFrom': _Map_castFrom$,
    'num.tryParse': _num_tryParse$,
    'Object.hash': _Object_hash$,
    'Object.hashAll': _Object_hashAll$,
    'Object.hashAllUnordered': _Object_hashAllUnordered$,
    'print': _print$,
    'RegExp.escape': _RegExp_escape$,
    'StackTrace.empty': _StackTrace_empty$,
    'StackTrace.current': _StackTrace_current$,
    'Symbol.unaryMinus': _Symbol_unaryMinus$,
    'Symbol.empty': _Symbol_empty$,
    'Uri.base': _Uri_base$,
    'Uri.parse': _Uri_parse$,
    'Uri.tryParse': _Uri_tryParse$,
    'Uri.encodeComponent': _Uri_encodeComponent$,
    'Uri.encodeQueryComponent': _Uri_encodeQueryComponent$,
    'Uri.decodeComponent': _Uri_decodeComponent$,
    'Uri.decodeQueryComponent': _Uri_decodeQueryComponent$,
    'Uri.encodeFull': _Uri_encodeFull$,
    'Uri.decodeFull': _Uri_decodeFull$,
    'Uri.splitQueryString': _Uri_splitQueryString$,
    'Uri.parseIPv4Address': _Uri_parseIPv4Address$,
    'Uri.parseIPv6Address': _Uri_parseIPv6Address$,
    'UriData.parse': _UriData_parse$,
  },
  {},
  {
    'Deprecated': m.ClassMirror(
      'Deprecated',
      {
        'message': _Deprecated_message$,
        'toString': _Deprecated_toString$,
      },
      {},
    ),
    'pragma': m.ClassMirror(
      'pragma',
      {
        'name': _pragma_name$,
        'options': _pragma_options$,
      },
      {},
    ),
    'BigInt': m.ClassMirror(
      'BigInt',
      {
        'bitLength': _BigInt_bitLength$,
        'sign': _BigInt_sign$,
        'isEven': _BigInt_isEven$,
        'isOdd': _BigInt_isOdd$,
        'isNegative': _BigInt_isNegative$,
        'isValidInt': _BigInt_isValidInt$,
        'abs': _BigInt_abs$,
        'remainder': _BigInt_remainder$,
        'compareTo': _BigInt_compareTo$,
        'pow': _BigInt_pow$,
        'modPow': _BigInt_modPow$,
        'modInverse': _BigInt_modInverse$,
        'gcd': _BigInt_gcd$,
        'toUnsigned': _BigInt_toUnsigned$,
        'toSigned': _BigInt_toSigned$,
        'toInt': _BigInt_toInt$,
        'toDouble': _BigInt_toDouble$,
        'toString': _BigInt_toString$,
        'toRadixString': _BigInt_toRadixString$,
      },
      {},
    ),
    'bool': m.ClassMirror(
      'bool',
      {
        'hashCode': _bool_hashCode$,
        'toString': _bool_toString$,
      },
      {},
    ),
    'Comparable': m.ClassMirror(
      'Comparable',
      {'compareTo': _Comparable_compareTo$},
      {},
    ),
    'DateTime': m.ClassMirror(
      'DateTime',
      {
        'isUtc': _DateTime_isUtc$,
        'hashCode': _DateTime_hashCode$,
        'millisecondsSinceEpoch': _DateTime_millisecondsSinceEpoch$,
        'microsecondsSinceEpoch': _DateTime_microsecondsSinceEpoch$,
        'timeZoneName': _DateTime_timeZoneName$,
        'timeZoneOffset': _DateTime_timeZoneOffset$,
        'year': _DateTime_year$,
        'month': _DateTime_month$,
        'day': _DateTime_day$,
        'hour': _DateTime_hour$,
        'minute': _DateTime_minute$,
        'second': _DateTime_second$,
        'millisecond': _DateTime_millisecond$,
        'microsecond': _DateTime_microsecond$,
        'weekday': _DateTime_weekday$,
        'isBefore': _DateTime_isBefore$,
        'isAfter': _DateTime_isAfter$,
        'isAtSameMomentAs': _DateTime_isAtSameMomentAs$,
        'compareTo': _DateTime_compareTo$,
        'toLocal': _DateTime_toLocal$,
        'toUtc': _DateTime_toUtc$,
        'toString': _DateTime_toString$,
        'toIso8601String': _DateTime_toIso8601String$,
        'add': _DateTime_add$,
        'subtract': _DateTime_subtract$,
        'difference': _DateTime_difference$,
      },
      {},
    ),
    'double': m.ClassMirror(
      'double',
      {
        'sign': _double_sign$,
        'remainder': _double_remainder$,
        'abs': _double_abs$,
        'round': _double_round$,
        'floor': _double_floor$,
        'ceil': _double_ceil$,
        'truncate': _double_truncate$,
        'roundToDouble': _double_roundToDouble$,
        'floorToDouble': _double_floorToDouble$,
        'ceilToDouble': _double_ceilToDouble$,
        'truncateToDouble': _double_truncateToDouble$,
        'toString': _double_toString$,
      },
      {},
    ),
    'Duration': m.ClassMirror(
      'Duration',
      {
        'inDays': _Duration_inDays$,
        'inHours': _Duration_inHours$,
        'inMinutes': _Duration_inMinutes$,
        'inSeconds': _Duration_inSeconds$,
        'inMilliseconds': _Duration_inMilliseconds$,
        'inMicroseconds': _Duration_inMicroseconds$,
        'hashCode': _Duration_hashCode$,
        'isNegative': _Duration_isNegative$,
        'compareTo': _Duration_compareTo$,
        'toString': _Duration_toString$,
        'abs': _Duration_abs$,
      },
      {},
    ),
    'Enum': m.ClassMirror(
      'Enum',
      {'index': _Enum_index$},
      {},
    ),
    'Error': m.ClassMirror(
      'Error',
      {'stackTrace': _Error_stackTrace$},
      {},
    ),
    'AssertionError': m.ClassMirror(
      'AssertionError',
      {
        'message': _AssertionError_message$,
        'toString': _AssertionError_toString$,
      },
      {},
    ),
    'TypeError': m.ClassMirror(
      'TypeError',
      {},
      {},
    ),
    'ArgumentError': m.ClassMirror(
      'ArgumentError',
      {
        'invalidValue': _ArgumentError_invalidValue$,
        'name': _ArgumentError_name$,
        'message': _ArgumentError_message$,
        'toString': _ArgumentError_toString$,
      },
      {},
    ),
    'RangeError': m.ClassMirror(
      'RangeError',
      {
        'start': _RangeError_start$,
        'end': _RangeError_end$,
        'invalidValue': _RangeError_invalidValue$,
      },
      {},
    ),
    'IndexError': m.ClassMirror(
      'IndexError',
      {
        'indexable': _IndexError_indexable$,
        'length': _IndexError_length$,
        'invalidValue': _IndexError_invalidValue$,
        'start': _IndexError_start$,
        'end': _IndexError_end$,
      },
      {},
    ),
    'NoSuchMethodError': m.ClassMirror(
      'NoSuchMethodError',
      {'toString': _NoSuchMethodError_toString$},
      {},
    ),
    'UnsupportedError': m.ClassMirror(
      'UnsupportedError',
      {
        'message': _UnsupportedError_message$,
        'toString': _UnsupportedError_toString$,
      },
      {},
    ),
    'UnimplementedError': m.ClassMirror(
      'UnimplementedError',
      {
        'message': _UnimplementedError_message$,
        'toString': _UnimplementedError_toString$,
      },
      {},
    ),
    'StateError': m.ClassMirror(
      'StateError',
      {
        'message': _StateError_message$,
        'toString': _StateError_toString$,
      },
      {},
    ),
    'ConcurrentModificationError': m.ClassMirror(
      'ConcurrentModificationError',
      {
        'modifiedObject': _ConcurrentModificationError_modifiedObject$,
        'toString': _ConcurrentModificationError_toString$,
      },
      {},
    ),
    'OutOfMemoryError': m.ClassMirror(
      'OutOfMemoryError',
      {
        'stackTrace': _OutOfMemoryError_stackTrace$,
        'toString': _OutOfMemoryError_toString$,
      },
      {},
    ),
    'StackOverflowError': m.ClassMirror(
      'StackOverflowError',
      {
        'stackTrace': _StackOverflowError_stackTrace$,
        'toString': _StackOverflowError_toString$,
      },
      {},
    ),
    'Exception': m.ClassMirror(
      'Exception',
      {},
      {},
    ),
    'FormatException': m.ClassMirror(
      'FormatException',
      {
        'message': _FormatException_message$,
        'source': _FormatException_source$,
        'offset': _FormatException_offset$,
        'toString': _FormatException_toString$,
      },
      {},
    ),
    'Function': m.ClassMirror(
      'Function',
      {'hashCode': _Function_hashCode$},
      {},
    ),
    'int': m.ClassMirror(
      'int',
      {
        'isEven': _int_isEven$,
        'isOdd': _int_isOdd$,
        'bitLength': _int_bitLength$,
        'sign': _int_sign$,
        'modPow': _int_modPow$,
        'modInverse': _int_modInverse$,
        'gcd': _int_gcd$,
        'toUnsigned': _int_toUnsigned$,
        'toSigned': _int_toSigned$,
        'abs': _int_abs$,
        'round': _int_round$,
        'floor': _int_floor$,
        'ceil': _int_ceil$,
        'truncate': _int_truncate$,
        'roundToDouble': _int_roundToDouble$,
        'floorToDouble': _int_floorToDouble$,
        'ceilToDouble': _int_ceilToDouble$,
        'truncateToDouble': _int_truncateToDouble$,
        'toString': _int_toString$,
        'toRadixString': _int_toRadixString$,
      },
      {},
    ),
    'Invocation': m.ClassMirror(
      'Invocation',
      {
        'memberName': _Invocation_memberName$,
        'typeArguments': _Invocation_typeArguments$,
        'positionalArguments': _Invocation_positionalArguments$,
        'namedArguments': _Invocation_namedArguments$,
        'isMethod': _Invocation_isMethod$,
        'isGetter': _Invocation_isGetter$,
        'isSetter': _Invocation_isSetter$,
        'isAccessor': _Invocation_isAccessor$,
      },
      {},
    ),
    'Iterable': m.ClassMirror(
      'Iterable',
      {
        'iterator': _Iterable_iterator$,
        'length': _Iterable_length$,
        'isEmpty': _Iterable_isEmpty$,
        'isNotEmpty': _Iterable_isNotEmpty$,
        'first': _Iterable_first$,
        'last': _Iterable_last$,
        'single': _Iterable_single$,
        'cast': _Iterable_cast$,
        'followedBy': _Iterable_followedBy$,
        'whereType': _Iterable_whereType$,
        'contains': _Iterable_contains$,
        'join': _Iterable_join$,
        'toList': _Iterable_toList$,
        'toSet': _Iterable_toSet$,
        'take': _Iterable_take$,
        'skip': _Iterable_skip$,
        'elementAt': _Iterable_elementAt$,
        'toString': _Iterable_toString$,
      },
      {},
    ),
    'Iterator': m.ClassMirror(
      'Iterator',
      {
        'current': _Iterator_current$,
        'moveNext': _Iterator_moveNext$,
      },
      {},
    ),
    'List': m.ClassMirror(
      'List',
      {
        'length': _List_length$,
        'reversed': _List_reversed$,
        'cast': _List_cast$,
        'add': _List_add$,
        'addAll': _List_addAll$,
        'shuffle': _List_shuffle$,
        'indexOf': _List_indexOf$,
        'lastIndexOf': _List_lastIndexOf$,
        'clear': _List_clear$,
        'insert': _List_insert$,
        'insertAll': _List_insertAll$,
        'setAll': _List_setAll$,
        'remove': _List_remove$,
        'removeAt': _List_removeAt$,
        'removeLast': _List_removeLast$,
        'sublist': _List_sublist$,
        'getRange': _List_getRange$,
        'setRange': _List_setRange$,
        'removeRange': _List_removeRange$,
        'fillRange': _List_fillRange$,
        'replaceRange': _List_replaceRange$,
        'asMap': _List_asMap$,
      },
      {
        'first': _List_first_set$,
        'last': _List_last_set$,
        'length': _List_length_set$,
      },
    ),
    'Map': m.ClassMirror(
      'Map',
      {
        'entries': _Map_entries$,
        'keys': _Map_keys$,
        'values': _Map_values$,
        'length': _Map_length$,
        'isEmpty': _Map_isEmpty$,
        'isNotEmpty': _Map_isNotEmpty$,
        'cast': _Map_cast$,
        'containsValue': _Map_containsValue$,
        'containsKey': _Map_containsKey$,
        'addEntries': _Map_addEntries$,
        'addAll': _Map_addAll$,
        'remove': _Map_remove$,
        'clear': _Map_clear$,
      },
      {},
    ),
    'MapEntry': m.ClassMirror(
      'MapEntry',
      {
        'key': _MapEntry_key$,
        'value': _MapEntry_value$,
        'toString': _MapEntry_toString$,
      },
      {},
    ),
    'Null': m.ClassMirror(
      'Null',
      {
        'hashCode': _Null_hashCode$,
        'toString': _Null_toString$,
      },
      {},
    ),
    'num': m.ClassMirror(
      'num',
      {
        'hashCode': _num_hashCode$,
        'isNaN': _num_isNaN$,
        'isNegative': _num_isNegative$,
        'isInfinite': _num_isInfinite$,
        'isFinite': _num_isFinite$,
        'sign': _num_sign$,
        'compareTo': _num_compareTo$,
        'remainder': _num_remainder$,
        'abs': _num_abs$,
        'round': _num_round$,
        'floor': _num_floor$,
        'ceil': _num_ceil$,
        'truncate': _num_truncate$,
        'roundToDouble': _num_roundToDouble$,
        'floorToDouble': _num_floorToDouble$,
        'ceilToDouble': _num_ceilToDouble$,
        'truncateToDouble': _num_truncateToDouble$,
        'clamp': _num_clamp$,
        'toInt': _num_toInt$,
        'toDouble': _num_toDouble$,
        'toStringAsFixed': _num_toStringAsFixed$,
        'toStringAsExponential': _num_toStringAsExponential$,
        'toStringAsPrecision': _num_toStringAsPrecision$,
        'toString': _num_toString$,
      },
      {},
    ),
    'Object': m.ClassMirror(
      'Object',
      {
        'hashCode': _Object_hashCode$,
        'runtimeType': _Object_runtimeType$,
        'toString': _Object_toString$,
        'noSuchMethod': _Object_noSuchMethod$,
      },
      {},
    ),
    'Pattern': m.ClassMirror(
      'Pattern',
      {
        'allMatches': _Pattern_allMatches$,
        'matchAsPrefix': _Pattern_matchAsPrefix$,
      },
      {},
    ),
    'Match': m.ClassMirror(
      'Match',
      {
        'start': _Match_start$,
        'end': _Match_end$,
        'groupCount': _Match_groupCount$,
        'input': _Match_input$,
        'pattern': _Match_pattern$,
        'group': _Match_group$,
        'groups': _Match_groups$,
      },
      {},
    ),
    'RegExp': m.ClassMirror(
      'RegExp',
      {
        'pattern': _RegExp_pattern$,
        'isMultiLine': _RegExp_isMultiLine$,
        'isCaseSensitive': _RegExp_isCaseSensitive$,
        'isUnicode': _RegExp_isUnicode$,
        'isDotAll': _RegExp_isDotAll$,
        'firstMatch': _RegExp_firstMatch$,
        'allMatches': _RegExp_allMatches$,
        'hasMatch': _RegExp_hasMatch$,
        'stringMatch': _RegExp_stringMatch$,
      },
      {},
    ),
    'RegExpMatch': m.ClassMirror(
      'RegExpMatch',
      {
        'groupNames': _RegExpMatch_groupNames$,
        'pattern': _RegExpMatch_pattern$,
        'namedGroup': _RegExpMatch_namedGroup$,
      },
      {},
    ),
    'Set': m.ClassMirror(
      'Set',
      {
        'iterator': _Set_iterator$,
        'cast': _Set_cast$,
        'contains': _Set_contains$,
        'add': _Set_add$,
        'addAll': _Set_addAll$,
        'remove': _Set_remove$,
        'lookup': _Set_lookup$,
        'removeAll': _Set_removeAll$,
        'retainAll': _Set_retainAll$,
        'containsAll': _Set_containsAll$,
        'intersection': _Set_intersection$,
        'union': _Set_union$,
        'difference': _Set_difference$,
        'clear': _Set_clear$,
        'toSet': _Set_toSet$,
      },
      {},
    ),
    'Sink': m.ClassMirror(
      'Sink',
      {
        'add': _Sink_add$,
        'close': _Sink_close$,
      },
      {},
    ),
    'StackTrace': m.ClassMirror(
      'StackTrace',
      {'toString': _StackTrace_toString$},
      {},
    ),
    'Stopwatch': m.ClassMirror(
      'Stopwatch',
      {
        'frequency': _Stopwatch_frequency$,
        'elapsedTicks': _Stopwatch_elapsedTicks$,
        'elapsed': _Stopwatch_elapsed$,
        'elapsedMicroseconds': _Stopwatch_elapsedMicroseconds$,
        'elapsedMilliseconds': _Stopwatch_elapsedMilliseconds$,
        'isRunning': _Stopwatch_isRunning$,
        'start': _Stopwatch_start$,
        'stop': _Stopwatch_stop$,
        'reset': _Stopwatch_reset$,
      },
      {},
    ),
    'String': m.ClassMirror(
      'String',
      {
        'length': _String_length$,
        'hashCode': _String_hashCode$,
        'isEmpty': _String_isEmpty$,
        'isNotEmpty': _String_isNotEmpty$,
        'codeUnits': _String_codeUnits$,
        'runes': _String_runes$,
        'codeUnitAt': _String_codeUnitAt$,
        'compareTo': _String_compareTo$,
        'endsWith': _String_endsWith$,
        'startsWith': _String_startsWith$,
        'indexOf': _String_indexOf$,
        'lastIndexOf': _String_lastIndexOf$,
        'substring': _String_substring$,
        'trim': _String_trim$,
        'trimLeft': _String_trimLeft$,
        'trimRight': _String_trimRight$,
        'padLeft': _String_padLeft$,
        'padRight': _String_padRight$,
        'contains': _String_contains$,
        'replaceFirst': _String_replaceFirst$,
        'replaceAll': _String_replaceAll$,
        'replaceRange': _String_replaceRange$,
        'split': _String_split$,
        'toLowerCase': _String_toLowerCase$,
        'toUpperCase': _String_toUpperCase$,
      },
      {},
    ),
    'Runes': m.ClassMirror(
      'Runes',
      {
        'string': _Runes_string$,
        'iterator': _Runes_iterator$,
        'last': _Runes_last$,
      },
      {},
    ),
    'RuneIterator': m.ClassMirror(
      'RuneIterator',
      {
        'string': _RuneIterator_string$,
        'rawIndex': _RuneIterator_rawIndex$,
        'current': _RuneIterator_current$,
        'currentSize': _RuneIterator_currentSize$,
        'currentAsString': _RuneIterator_currentAsString$,
        'reset': _RuneIterator_reset$,
        'moveNext': _RuneIterator_moveNext$,
        'movePrevious': _RuneIterator_movePrevious$,
      },
      {'rawIndex': _RuneIterator_rawIndex_set$},
    ),
    'StringBuffer': m.ClassMirror(
      'StringBuffer',
      {
        'length': _StringBuffer_length$,
        'isEmpty': _StringBuffer_isEmpty$,
        'isNotEmpty': _StringBuffer_isNotEmpty$,
        'write': _StringBuffer_write$,
        'writeCharCode': _StringBuffer_writeCharCode$,
        'writeAll': _StringBuffer_writeAll$,
        'writeln': _StringBuffer_writeln$,
        'clear': _StringBuffer_clear$,
        'toString': _StringBuffer_toString$,
      },
      {},
    ),
    'StringSink': m.ClassMirror(
      'StringSink',
      {
        'write': _StringSink_write$,
        'writeAll': _StringSink_writeAll$,
        'writeln': _StringSink_writeln$,
        'writeCharCode': _StringSink_writeCharCode$,
      },
      {},
    ),
    'Symbol': m.ClassMirror(
      'Symbol',
      {'hashCode': _Symbol_hashCode$},
      {},
    ),
    'Type': m.ClassMirror(
      'Type',
      {
        'hashCode': _Type_hashCode$,
        'toString': _Type_toString$,
      },
      {},
    ),
    'Uri': m.ClassMirror(
      'Uri',
      {
        'scheme': _Uri_scheme$,
        'authority': _Uri_authority$,
        'userInfo': _Uri_userInfo$,
        'host': _Uri_host$,
        'port': _Uri_port$,
        'path': _Uri_path$,
        'query': _Uri_query$,
        'fragment': _Uri_fragment$,
        'pathSegments': _Uri_pathSegments$,
        'queryParameters': _Uri_queryParameters$,
        'queryParametersAll': _Uri_queryParametersAll$,
        'isAbsolute': _Uri_isAbsolute$,
        'hasScheme': _Uri_hasScheme$,
        'hasAuthority': _Uri_hasAuthority$,
        'hasPort': _Uri_hasPort$,
        'hasQuery': _Uri_hasQuery$,
        'hasFragment': _Uri_hasFragment$,
        'hasEmptyPath': _Uri_hasEmptyPath$,
        'hasAbsolutePath': _Uri_hasAbsolutePath$,
        'origin': _Uri_origin$,
        'data': _Uri_data$,
        'hashCode': _Uri_hashCode$,
        'isScheme': _Uri_isScheme$,
        'toFilePath': _Uri_toFilePath$,
        'toString': _Uri_toString$,
        'replace': _Uri_replace$,
        'removeFragment': _Uri_removeFragment$,
        'resolve': _Uri_resolve$,
        'resolveUri': _Uri_resolveUri$,
        'normalizePath': _Uri_normalizePath$,
      },
      {},
    ),
    'UriData': m.ClassMirror(
      'UriData',
      {
        'uri': _UriData_uri$,
        'mimeType': _UriData_mimeType$,
        'charset': _UriData_charset$,
        'isBase64': _UriData_isBase64$,
        'contentText': _UriData_contentText$,
        'parameters': _UriData_parameters$,
        'isMimeType': _UriData_isMimeType$,
        'isCharset': _UriData_isCharset$,
        'isEncoding': _UriData_isEncoding$,
        'contentAsBytes': _UriData_contentAsBytes$,
        'contentAsString': _UriData_contentAsString$,
        'toString': _UriData_toString$,
      },
      {},
    ),
    'Expando': m.ClassMirror(
      'Expando',
      {
        'name': _Expando_name$,
        'toString': _Expando_toString$,
      },
      {},
    ),
    'WeakReference': m.ClassMirror(
      'WeakReference',
      {'target': _WeakReference_target$},
      {},
    ),
    'Finalizer': m.ClassMirror(
      'Finalizer',
      {
        'attach': _Finalizer_attach$,
        'detach': _Finalizer_detach$,
      },
      {},
    ),
  },
);
Deprecated _deprecated$() {
  return deprecated;
}

Object _override$() {
  return override;
}

String _Deprecated_message$(Deprecated target) {
  return target.message;
}

Function _Deprecated_toString$(
  m.Scope scope,
  Deprecated target,
) =>
    target.toString;
String _pragma_name$(pragma target) {
  return target.name;
}

Object? _pragma_options$(pragma target) {
  return target.options;
}

BigInt _BigInt_zero$() {
  return BigInt.zero;
}

BigInt _BigInt_one$() {
  return BigInt.one;
}

BigInt _BigInt_two$() {
  return BigInt.two;
}

int _BigInt_bitLength$(BigInt target) {
  return target.bitLength;
}

int _BigInt_sign$(BigInt target) {
  return target.sign;
}

bool _BigInt_isEven$(BigInt target) {
  return target.isEven;
}

bool _BigInt_isOdd$(BigInt target) {
  return target.isOdd;
}

bool _BigInt_isNegative$(BigInt target) {
  return target.isNegative;
}

bool _BigInt_isValidInt$(BigInt target) {
  return target.isValidInt;
}

Function _BigInt_parse$(m.Scope scope) => BigInt.parse;
Function _BigInt_tryParse$(m.Scope scope) => BigInt.tryParse;
Function _BigInt_abs$(
  m.Scope scope,
  BigInt target,
) =>
    target.abs;
Function _BigInt_remainder$(
  m.Scope scope,
  BigInt target,
) =>
    target.remainder;
Function _BigInt_compareTo$(
  m.Scope scope,
  BigInt target,
) =>
    target.compareTo;
Function _BigInt_pow$(
  m.Scope scope,
  BigInt target,
) =>
    target.pow;
Function _BigInt_modPow$(
  m.Scope scope,
  BigInt target,
) =>
    target.modPow;
Function _BigInt_modInverse$(
  m.Scope scope,
  BigInt target,
) =>
    target.modInverse;
Function _BigInt_gcd$(
  m.Scope scope,
  BigInt target,
) =>
    target.gcd;
Function _BigInt_toUnsigned$(
  m.Scope scope,
  BigInt target,
) =>
    target.toUnsigned;
Function _BigInt_toSigned$(
  m.Scope scope,
  BigInt target,
) =>
    target.toSigned;
Function _BigInt_toInt$(
  m.Scope scope,
  BigInt target,
) =>
    target.toInt;
Function _BigInt_toDouble$(
  m.Scope scope,
  BigInt target,
) =>
    target.toDouble;
Function _BigInt_toString$(
  m.Scope scope,
  BigInt target,
) =>
    target.toString;
Function _BigInt_toRadixString$(
  m.Scope scope,
  BigInt target,
) =>
    target.toRadixString;
int _bool_hashCode$(bool target) {
  return target.hashCode;
}

Function _bool_parse$(m.Scope scope) => bool.parse;
Function _bool_tryParse$(m.Scope scope) => bool.tryParse;
Function _bool_toString$(
  m.Scope scope,
  bool target,
) =>
    target.toString;
Function _Comparable_compareTo$<T>(
  m.Scope scope,
  Comparable<T> target,
) =>
    target.compareTo;
Function _Comparable_compare$(m.Scope scope) => Comparable.compare;
int _DateTime_monday$() {
  return DateTime.monday;
}

int _DateTime_tuesday$() {
  return DateTime.tuesday;
}

int _DateTime_wednesday$() {
  return DateTime.wednesday;
}

int _DateTime_thursday$() {
  return DateTime.thursday;
}

int _DateTime_friday$() {
  return DateTime.friday;
}

int _DateTime_saturday$() {
  return DateTime.saturday;
}

int _DateTime_sunday$() {
  return DateTime.sunday;
}

int _DateTime_daysPerWeek$() {
  return DateTime.daysPerWeek;
}

int _DateTime_january$() {
  return DateTime.january;
}

int _DateTime_february$() {
  return DateTime.february;
}

int _DateTime_march$() {
  return DateTime.march;
}

int _DateTime_april$() {
  return DateTime.april;
}

int _DateTime_may$() {
  return DateTime.may;
}

int _DateTime_june$() {
  return DateTime.june;
}

int _DateTime_july$() {
  return DateTime.july;
}

int _DateTime_august$() {
  return DateTime.august;
}

int _DateTime_september$() {
  return DateTime.september;
}

int _DateTime_october$() {
  return DateTime.october;
}

int _DateTime_november$() {
  return DateTime.november;
}

int _DateTime_december$() {
  return DateTime.december;
}

int _DateTime_monthsPerYear$() {
  return DateTime.monthsPerYear;
}

bool _DateTime_isUtc$(DateTime target) {
  return target.isUtc;
}

int _DateTime_hashCode$(DateTime target) {
  return target.hashCode;
}

int _DateTime_millisecondsSinceEpoch$(DateTime target) {
  return target.millisecondsSinceEpoch;
}

int _DateTime_microsecondsSinceEpoch$(DateTime target) {
  return target.microsecondsSinceEpoch;
}

String _DateTime_timeZoneName$(DateTime target) {
  return target.timeZoneName;
}

Duration _DateTime_timeZoneOffset$(DateTime target) {
  return target.timeZoneOffset;
}

int _DateTime_year$(DateTime target) {
  return target.year;
}

int _DateTime_month$(DateTime target) {
  return target.month;
}

int _DateTime_day$(DateTime target) {
  return target.day;
}

int _DateTime_hour$(DateTime target) {
  return target.hour;
}

int _DateTime_minute$(DateTime target) {
  return target.minute;
}

int _DateTime_second$(DateTime target) {
  return target.second;
}

int _DateTime_millisecond$(DateTime target) {
  return target.millisecond;
}

int _DateTime_microsecond$(DateTime target) {
  return target.microsecond;
}

int _DateTime_weekday$(DateTime target) {
  return target.weekday;
}

Function _DateTime_parse$(m.Scope scope) => DateTime.parse;
Function _DateTime_tryParse$(m.Scope scope) => DateTime.tryParse;
Function _DateTime_isBefore$(
  m.Scope scope,
  DateTime target,
) =>
    target.isBefore;
Function _DateTime_isAfter$(
  m.Scope scope,
  DateTime target,
) =>
    target.isAfter;
Function _DateTime_isAtSameMomentAs$(
  m.Scope scope,
  DateTime target,
) =>
    target.isAtSameMomentAs;
Function _DateTime_compareTo$(
  m.Scope scope,
  DateTime target,
) =>
    target.compareTo;
Function _DateTime_toLocal$(
  m.Scope scope,
  DateTime target,
) =>
    target.toLocal;
Function _DateTime_toUtc$(
  m.Scope scope,
  DateTime target,
) =>
    target.toUtc;
Function _DateTime_toString$(
  m.Scope scope,
  DateTime target,
) =>
    target.toString;
Function _DateTime_toIso8601String$(
  m.Scope scope,
  DateTime target,
) =>
    target.toIso8601String;
Function _DateTime_add$(
  m.Scope scope,
  DateTime target,
) =>
    target.add;
Function _DateTime_subtract$(
  m.Scope scope,
  DateTime target,
) =>
    target.subtract;
Function _DateTime_difference$(
  m.Scope scope,
  DateTime target,
) =>
    target.difference;
double _double_nan$() {
  return double.nan;
}

double _double_infinity$() {
  return double.infinity;
}

double _double_negativeInfinity$() {
  return double.negativeInfinity;
}

double _double_minPositive$() {
  return double.minPositive;
}

double _double_maxFinite$() {
  return double.maxFinite;
}

double _double_sign$(double target) {
  return target.sign;
}

Function _double_remainder$(
  m.Scope scope,
  double target,
) =>
    target.remainder;
Function _double_abs$(
  m.Scope scope,
  double target,
) =>
    target.abs;
Function _double_round$(
  m.Scope scope,
  double target,
) =>
    target.round;
Function _double_floor$(
  m.Scope scope,
  double target,
) =>
    target.floor;
Function _double_ceil$(
  m.Scope scope,
  double target,
) =>
    target.ceil;
Function _double_truncate$(
  m.Scope scope,
  double target,
) =>
    target.truncate;
Function _double_roundToDouble$(
  m.Scope scope,
  double target,
) =>
    target.roundToDouble;
Function _double_floorToDouble$(
  m.Scope scope,
  double target,
) =>
    target.floorToDouble;
Function _double_ceilToDouble$(
  m.Scope scope,
  double target,
) =>
    target.ceilToDouble;
Function _double_truncateToDouble$(
  m.Scope scope,
  double target,
) =>
    target.truncateToDouble;
Function _double_toString$(
  m.Scope scope,
  double target,
) =>
    target.toString;
Function _double_parse$(m.Scope scope) => double.parse;
Function _double_tryParse$(m.Scope scope) => double.tryParse;
int _Duration_microsecondsPerMillisecond$() {
  return Duration.microsecondsPerMillisecond;
}

int _Duration_millisecondsPerSecond$() {
  return Duration.millisecondsPerSecond;
}

int _Duration_secondsPerMinute$() {
  return Duration.secondsPerMinute;
}

int _Duration_minutesPerHour$() {
  return Duration.minutesPerHour;
}

int _Duration_hoursPerDay$() {
  return Duration.hoursPerDay;
}

int _Duration_microsecondsPerSecond$() {
  return Duration.microsecondsPerSecond;
}

int _Duration_microsecondsPerMinute$() {
  return Duration.microsecondsPerMinute;
}

int _Duration_microsecondsPerHour$() {
  return Duration.microsecondsPerHour;
}

int _Duration_microsecondsPerDay$() {
  return Duration.microsecondsPerDay;
}

int _Duration_millisecondsPerMinute$() {
  return Duration.millisecondsPerMinute;
}

int _Duration_millisecondsPerHour$() {
  return Duration.millisecondsPerHour;
}

int _Duration_millisecondsPerDay$() {
  return Duration.millisecondsPerDay;
}

int _Duration_secondsPerHour$() {
  return Duration.secondsPerHour;
}

int _Duration_secondsPerDay$() {
  return Duration.secondsPerDay;
}

int _Duration_minutesPerDay$() {
  return Duration.minutesPerDay;
}

Duration _Duration_zero$() {
  return Duration.zero;
}

int _Duration_inDays$(Duration target) {
  return target.inDays;
}

int _Duration_inHours$(Duration target) {
  return target.inHours;
}

int _Duration_inMinutes$(Duration target) {
  return target.inMinutes;
}

int _Duration_inSeconds$(Duration target) {
  return target.inSeconds;
}

int _Duration_inMilliseconds$(Duration target) {
  return target.inMilliseconds;
}

int _Duration_inMicroseconds$(Duration target) {
  return target.inMicroseconds;
}

int _Duration_hashCode$(Duration target) {
  return target.hashCode;
}

bool _Duration_isNegative$(Duration target) {
  return target.isNegative;
}

Function _Duration_compareTo$(
  m.Scope scope,
  Duration target,
) =>
    target.compareTo;
Function _Duration_toString$(
  m.Scope scope,
  Duration target,
) =>
    target.toString;
Function _Duration_abs$(
  m.Scope scope,
  Duration target,
) =>
    target.abs;
int _Enum_index$(Enum target) {
  return target.index;
}

Function _Enum_compareByIndex$<T extends Enum>(m.Scope scope) =>
    Enum.compareByIndex<T>;
Function _Enum_compareByName$<T extends Enum>(m.Scope scope) =>
    Enum.compareByName<T>;
StackTrace? _Error_stackTrace$(Error target) {
  return target.stackTrace;
}

Function _Error_safeToString$(m.Scope scope) => Error.safeToString;
Function _Error_throwWithStackTrace$(m.Scope scope) =>
    Error.throwWithStackTrace;
Object? _AssertionError_message$(AssertionError target) {
  return target.message;
}

Function _AssertionError_toString$(
  m.Scope scope,
  AssertionError target,
) =>
    target.toString;
dynamic _ArgumentError_invalidValue$(ArgumentError target) {
  return target.invalidValue;
}

String? _ArgumentError_name$(ArgumentError target) {
  return target.name;
}

dynamic _ArgumentError_message$(ArgumentError target) {
  return target.message;
}

Function _ArgumentError_checkNotNull$<T>(m.Scope scope) =>
    ArgumentError.checkNotNull<T>;
Function _ArgumentError_toString$(
  m.Scope scope,
  ArgumentError target,
) =>
    target.toString;
num? _RangeError_start$(RangeError target) {
  return target.start;
}

num? _RangeError_end$(RangeError target) {
  return target.end;
}

num? _RangeError_invalidValue$(RangeError target) {
  return target.invalidValue;
}

Function _RangeError_checkValueInInterval$(m.Scope scope) =>
    RangeError.checkValueInInterval;
Function _RangeError_checkValidIndex$(m.Scope scope) =>
    RangeError.checkValidIndex;
Function _RangeError_checkValidRange$(m.Scope scope) =>
    RangeError.checkValidRange;
Function _RangeError_checkNotNegative$(m.Scope scope) =>
    RangeError.checkNotNegative;
Object? _IndexError_indexable$(IndexError target) {
  return target.indexable;
}

int _IndexError_length$(IndexError target) {
  return target.length;
}

int _IndexError_invalidValue$(IndexError target) {
  return target.invalidValue;
}

int _IndexError_start$(IndexError target) {
  return target.start;
}

int _IndexError_end$(IndexError target) {
  return target.end;
}

Function _IndexError_check$(m.Scope scope) => IndexError.check;
Function _NoSuchMethodError_toString$(
  m.Scope scope,
  NoSuchMethodError target,
) =>
    target.toString;
String? _UnsupportedError_message$(UnsupportedError target) {
  return target.message;
}

Function _UnsupportedError_toString$(
  m.Scope scope,
  UnsupportedError target,
) =>
    target.toString;
String? _UnimplementedError_message$(UnimplementedError target) {
  return target.message;
}

Function _UnimplementedError_toString$(
  m.Scope scope,
  UnimplementedError target,
) =>
    target.toString;
String _StateError_message$(StateError target) {
  return target.message;
}

Function _StateError_toString$(
  m.Scope scope,
  StateError target,
) =>
    target.toString;
Object? _ConcurrentModificationError_modifiedObject$(
    ConcurrentModificationError target) {
  return target.modifiedObject;
}

Function _ConcurrentModificationError_toString$(
  m.Scope scope,
  ConcurrentModificationError target,
) =>
    target.toString;
StackTrace? _OutOfMemoryError_stackTrace$(OutOfMemoryError target) {
  return target.stackTrace;
}

Function _OutOfMemoryError_toString$(
  m.Scope scope,
  OutOfMemoryError target,
) =>
    target.toString;
StackTrace? _StackOverflowError_stackTrace$(StackOverflowError target) {
  return target.stackTrace;
}

Function _StackOverflowError_toString$(
  m.Scope scope,
  StackOverflowError target,
) =>
    target.toString;
String _FormatException_message$(FormatException target) {
  return target.message;
}

dynamic _FormatException_source$(FormatException target) {
  return target.source;
}

int? _FormatException_offset$(FormatException target) {
  return target.offset;
}

Function _FormatException_toString$(
  m.Scope scope,
  FormatException target,
) =>
    target.toString;
int _Function_hashCode$(Function target) {
  return target.hashCode;
}

Function _Function_apply$(m.Scope scope) => Function.apply;
Function _identical$(m.Scope scope) => identical;
Function _identityHashCode$(m.Scope scope) => identityHashCode;
bool _int_isEven$(int target) {
  return target.isEven;
}

bool _int_isOdd$(int target) {
  return target.isOdd;
}

int _int_bitLength$(int target) {
  return target.bitLength;
}

int _int_sign$(int target) {
  return target.sign;
}

Function _int_modPow$(
  m.Scope scope,
  int target,
) =>
    target.modPow;
Function _int_modInverse$(
  m.Scope scope,
  int target,
) =>
    target.modInverse;
Function _int_gcd$(
  m.Scope scope,
  int target,
) =>
    target.gcd;
Function _int_toUnsigned$(
  m.Scope scope,
  int target,
) =>
    target.toUnsigned;
Function _int_toSigned$(
  m.Scope scope,
  int target,
) =>
    target.toSigned;
Function _int_abs$(
  m.Scope scope,
  int target,
) =>
    target.abs;
Function _int_round$(
  m.Scope scope,
  int target,
) =>
    target.round;
Function _int_floor$(
  m.Scope scope,
  int target,
) =>
    target.floor;
Function _int_ceil$(
  m.Scope scope,
  int target,
) =>
    target.ceil;
Function _int_truncate$(
  m.Scope scope,
  int target,
) =>
    target.truncate;
Function _int_roundToDouble$(
  m.Scope scope,
  int target,
) =>
    target.roundToDouble;
Function _int_floorToDouble$(
  m.Scope scope,
  int target,
) =>
    target.floorToDouble;
Function _int_ceilToDouble$(
  m.Scope scope,
  int target,
) =>
    target.ceilToDouble;
Function _int_truncateToDouble$(
  m.Scope scope,
  int target,
) =>
    target.truncateToDouble;
Function _int_toString$(
  m.Scope scope,
  int target,
) =>
    target.toString;
Function _int_toRadixString$(
  m.Scope scope,
  int target,
) =>
    target.toRadixString;
Function _int_parse$(m.Scope scope) => int.parse;
Function _int_tryParse$(m.Scope scope) => int.tryParse;
Symbol _Invocation_memberName$(Invocation target) {
  return target.memberName;
}

List<Type> _Invocation_typeArguments$(Invocation target) {
  return target.typeArguments;
}

List<dynamic> _Invocation_positionalArguments$(Invocation target) {
  return target.positionalArguments;
}

Map<Symbol, dynamic> _Invocation_namedArguments$(Invocation target) {
  return target.namedArguments;
}

bool _Invocation_isMethod$(Invocation target) {
  return target.isMethod;
}

bool _Invocation_isGetter$(Invocation target) {
  return target.isGetter;
}

bool _Invocation_isSetter$(Invocation target) {
  return target.isSetter;
}

bool _Invocation_isAccessor$(Invocation target) {
  return target.isAccessor;
}

Iterator<E> _Iterable_iterator$<E>(Iterable<E> target) {
  return target.iterator;
}

int _Iterable_length$<E>(Iterable<E> target) {
  return target.length;
}

bool _Iterable_isEmpty$<E>(Iterable<E> target) {
  return target.isEmpty;
}

bool _Iterable_isNotEmpty$<E>(Iterable<E> target) {
  return target.isNotEmpty;
}

E _Iterable_first$<E>(Iterable<E> target) {
  return target.first;
}

E _Iterable_last$<E>(Iterable<E> target) {
  return target.last;
}

E _Iterable_single$<E>(Iterable<E> target) {
  return target.single;
}

Function _Iterable_castFrom$<S, T>(m.Scope scope) => Iterable.castFrom<S, T>;
Function _Iterable_cast$<E, R>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.cast<R>;
Function _Iterable_followedBy$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.followedBy;
Function _Iterable_whereType$<E, T>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.whereType<T>;
Function _Iterable_contains$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.contains;
Function _Iterable_join$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.join;
Function _Iterable_toList$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.toList;
Function _Iterable_toSet$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.toSet;
Function _Iterable_take$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.take;
Function _Iterable_skip$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.skip;
Function _Iterable_elementAt$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.elementAt;
Function _Iterable_toString$<E>(
  m.Scope scope,
  Iterable<E> target,
) =>
    target.toString;
Function _Iterable_iterableToShortString$(m.Scope scope) =>
    Iterable.iterableToShortString;
Function _Iterable_iterableToFullString$(m.Scope scope) =>
    Iterable.iterableToFullString;
E _Iterator_current$<E>(Iterator<E> target) {
  return target.current;
}

Function _Iterator_moveNext$<E>(
  m.Scope scope,
  Iterator<E> target,
) =>
    target.moveNext;
void _List_first_set$<E>(
  List<E> target,
  E other,
) {
  target.first = other;
}

void _List_last_set$<E>(
  List<E> target,
  E other,
) {
  target.last = other;
}

int _List_length$<E>(List<E> target) {
  return target.length;
}

void _List_length_set$<E>(
  List<E> target,
  int other,
) {
  target.length = other;
}

Iterable<E> _List_reversed$<E>(List<E> target) {
  return target.reversed;
}

Function _List_castFrom$<S, T>(m.Scope scope) => List.castFrom<S, T>;
Function _List_copyRange$<T>(m.Scope scope) => List.copyRange<T>;
Function _List_writeIterable$<T>(m.Scope scope) => List.writeIterable<T>;
Function _List_cast$<E, R>(
  m.Scope scope,
  List<E> target,
) =>
    target.cast<R>;
Function _List_add$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.add;
Function _List_addAll$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.addAll;
Function _List_shuffle$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.shuffle;
Function _List_indexOf$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.indexOf;
Function _List_lastIndexOf$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.lastIndexOf;
Function _List_clear$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.clear;
Function _List_insert$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.insert;
Function _List_insertAll$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.insertAll;
Function _List_setAll$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.setAll;
Function _List_remove$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.remove;
Function _List_removeAt$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.removeAt;
Function _List_removeLast$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.removeLast;
Function _List_sublist$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.sublist;
Function _List_getRange$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.getRange;
Function _List_setRange$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.setRange;
Function _List_removeRange$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.removeRange;
Function _List_fillRange$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.fillRange;
Function _List_replaceRange$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.replaceRange;
Function _List_asMap$<E>(
  m.Scope scope,
  List<E> target,
) =>
    target.asMap;
Iterable<MapEntry<K, V>> _Map_entries$<K, V>(Map<K, V> target) {
  return target.entries;
}

Iterable<K> _Map_keys$<K, V>(Map<K, V> target) {
  return target.keys;
}

Iterable<V> _Map_values$<K, V>(Map<K, V> target) {
  return target.values;
}

int _Map_length$<K, V>(Map<K, V> target) {
  return target.length;
}

bool _Map_isEmpty$<K, V>(Map<K, V> target) {
  return target.isEmpty;
}

bool _Map_isNotEmpty$<K, V>(Map<K, V> target) {
  return target.isNotEmpty;
}

Function _Map_castFrom$<K, V, K2, V2>(m.Scope scope) =>
    Map.castFrom<K, V, K2, V2>;
Function _Map_cast$<K, V, RK, RV>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.cast<RK, RV>;
Function _Map_containsValue$<K, V>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.containsValue;
Function _Map_containsKey$<K, V>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.containsKey;
Function _Map_addEntries$<K, V>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.addEntries;
Function _Map_addAll$<K, V>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.addAll;
Function _Map_remove$<K, V>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.remove;
Function _Map_clear$<K, V>(
  m.Scope scope,
  Map<K, V> target,
) =>
    target.clear;
K _MapEntry_key$<K, V>(MapEntry<K, V> target) {
  return target.key;
}

V _MapEntry_value$<K, V>(MapEntry<K, V> target) {
  return target.value;
}

Function _MapEntry_toString$<K, V>(
  m.Scope scope,
  MapEntry<K, V> target,
) =>
    target.toString;
int _Null_hashCode$(Null target) {
  return target.hashCode;
}

Function _Null_toString$(
  m.Scope scope,
  Null target,
) =>
    target.toString;
int _num_hashCode$(num target) {
  return target.hashCode;
}

bool _num_isNaN$(num target) {
  return target.isNaN;
}

bool _num_isNegative$(num target) {
  return target.isNegative;
}

bool _num_isInfinite$(num target) {
  return target.isInfinite;
}

bool _num_isFinite$(num target) {
  return target.isFinite;
}

num _num_sign$(num target) {
  return target.sign;
}

Function _num_compareTo$(
  m.Scope scope,
  num target,
) =>
    target.compareTo;
Function _num_remainder$(
  m.Scope scope,
  num target,
) =>
    target.remainder;
Function _num_abs$(
  m.Scope scope,
  num target,
) =>
    target.abs;
Function _num_round$(
  m.Scope scope,
  num target,
) =>
    target.round;
Function _num_floor$(
  m.Scope scope,
  num target,
) =>
    target.floor;
Function _num_ceil$(
  m.Scope scope,
  num target,
) =>
    target.ceil;
Function _num_truncate$(
  m.Scope scope,
  num target,
) =>
    target.truncate;
Function _num_roundToDouble$(
  m.Scope scope,
  num target,
) =>
    target.roundToDouble;
Function _num_floorToDouble$(
  m.Scope scope,
  num target,
) =>
    target.floorToDouble;
Function _num_ceilToDouble$(
  m.Scope scope,
  num target,
) =>
    target.ceilToDouble;
Function _num_truncateToDouble$(
  m.Scope scope,
  num target,
) =>
    target.truncateToDouble;
Function _num_clamp$(
  m.Scope scope,
  num target,
) =>
    target.clamp;
Function _num_toInt$(
  m.Scope scope,
  num target,
) =>
    target.toInt;
Function _num_toDouble$(
  m.Scope scope,
  num target,
) =>
    target.toDouble;
Function _num_toStringAsFixed$(
  m.Scope scope,
  num target,
) =>
    target.toStringAsFixed;
Function _num_toStringAsExponential$(
  m.Scope scope,
  num target,
) =>
    target.toStringAsExponential;
Function _num_toStringAsPrecision$(
  m.Scope scope,
  num target,
) =>
    target.toStringAsPrecision;
Function _num_toString$(
  m.Scope scope,
  num target,
) =>
    target.toString;
Function _num_tryParse$(m.Scope scope) => num.tryParse;
int _Object_hashCode$(Object target) {
  return target.hashCode;
}

Type _Object_runtimeType$(Object target) {
  return target.runtimeType;
}

Function _Object_toString$(
  m.Scope scope,
  Object target,
) =>
    target.toString;
Function _Object_noSuchMethod$(
  m.Scope scope,
  Object target,
) =>
    target.noSuchMethod;
Function _Object_hash$(m.Scope scope) => Object.hash;
Function _Object_hashAll$(m.Scope scope) => Object.hashAll;
Function _Object_hashAllUnordered$(m.Scope scope) => Object.hashAllUnordered;
Function _Pattern_allMatches$(
  m.Scope scope,
  Pattern target,
) =>
    target.allMatches;
Function _Pattern_matchAsPrefix$(
  m.Scope scope,
  Pattern target,
) =>
    target.matchAsPrefix;
int _Match_start$(Match target) {
  return target.start;
}

int _Match_end$(Match target) {
  return target.end;
}

int _Match_groupCount$(Match target) {
  return target.groupCount;
}

String _Match_input$(Match target) {
  return target.input;
}

Pattern _Match_pattern$(Match target) {
  return target.pattern;
}

Function _Match_group$(
  m.Scope scope,
  Match target,
) =>
    target.group;
Function _Match_groups$(
  m.Scope scope,
  Match target,
) =>
    target.groups;
Function _print$(m.Scope scope) => print;
String _RegExp_pattern$(RegExp target) {
  return target.pattern;
}

bool _RegExp_isMultiLine$(RegExp target) {
  return target.isMultiLine;
}

bool _RegExp_isCaseSensitive$(RegExp target) {
  return target.isCaseSensitive;
}

bool _RegExp_isUnicode$(RegExp target) {
  return target.isUnicode;
}

bool _RegExp_isDotAll$(RegExp target) {
  return target.isDotAll;
}

Function _RegExp_escape$(m.Scope scope) => RegExp.escape;
Function _RegExp_firstMatch$(
  m.Scope scope,
  RegExp target,
) =>
    target.firstMatch;
Function _RegExp_allMatches$(
  m.Scope scope,
  RegExp target,
) =>
    target.allMatches;
Function _RegExp_hasMatch$(
  m.Scope scope,
  RegExp target,
) =>
    target.hasMatch;
Function _RegExp_stringMatch$(
  m.Scope scope,
  RegExp target,
) =>
    target.stringMatch;
Iterable<String> _RegExpMatch_groupNames$(RegExpMatch target) {
  return target.groupNames;
}

RegExp _RegExpMatch_pattern$(RegExpMatch target) {
  return target.pattern;
}

Function _RegExpMatch_namedGroup$(
  m.Scope scope,
  RegExpMatch target,
) =>
    target.namedGroup;
Iterator<E> _Set_iterator$<E>(Set<E> target) {
  return target.iterator;
}

Function _Set_cast$<E, R>(
  m.Scope scope,
  Set<E> target,
) =>
    target.cast<R>;
Function _Set_contains$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.contains;
Function _Set_add$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.add;
Function _Set_addAll$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.addAll;
Function _Set_remove$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.remove;
Function _Set_lookup$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.lookup;
Function _Set_removeAll$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.removeAll;
Function _Set_retainAll$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.retainAll;
Function _Set_containsAll$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.containsAll;
Function _Set_intersection$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.intersection;
Function _Set_union$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.union;
Function _Set_difference$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.difference;
Function _Set_clear$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.clear;
Function _Set_toSet$<E>(
  m.Scope scope,
  Set<E> target,
) =>
    target.toSet;
Function _Sink_add$<T>(
  m.Scope scope,
  Sink<T> target,
) =>
    target.add;
Function _Sink_close$<T>(
  m.Scope scope,
  Sink<T> target,
) =>
    target.close;
dynamic _StackTrace_empty$() {
  return StackTrace.empty;
}

StackTrace _StackTrace_current$() {
  return StackTrace.current;
}

Function _StackTrace_toString$(
  m.Scope scope,
  StackTrace target,
) =>
    target.toString;
int _Stopwatch_frequency$(Stopwatch target) {
  return target.frequency;
}

int _Stopwatch_elapsedTicks$(Stopwatch target) {
  return target.elapsedTicks;
}

Duration _Stopwatch_elapsed$(Stopwatch target) {
  return target.elapsed;
}

int _Stopwatch_elapsedMicroseconds$(Stopwatch target) {
  return target.elapsedMicroseconds;
}

int _Stopwatch_elapsedMilliseconds$(Stopwatch target) {
  return target.elapsedMilliseconds;
}

bool _Stopwatch_isRunning$(Stopwatch target) {
  return target.isRunning;
}

Function _Stopwatch_start$(
  m.Scope scope,
  Stopwatch target,
) =>
    target.start;
Function _Stopwatch_stop$(
  m.Scope scope,
  Stopwatch target,
) =>
    target.stop;
Function _Stopwatch_reset$(
  m.Scope scope,
  Stopwatch target,
) =>
    target.reset;
int _String_length$(String target) {
  return target.length;
}

int _String_hashCode$(String target) {
  return target.hashCode;
}

bool _String_isEmpty$(String target) {
  return target.isEmpty;
}

bool _String_isNotEmpty$(String target) {
  return target.isNotEmpty;
}

List<int> _String_codeUnits$(String target) {
  return target.codeUnits;
}

Runes _String_runes$(String target) {
  return target.runes;
}

Function _String_codeUnitAt$(
  m.Scope scope,
  String target,
) =>
    target.codeUnitAt;
Function _String_compareTo$(
  m.Scope scope,
  String target,
) =>
    target.compareTo;
Function _String_endsWith$(
  m.Scope scope,
  String target,
) =>
    target.endsWith;
Function _String_startsWith$(
  m.Scope scope,
  String target,
) =>
    target.startsWith;
Function _String_indexOf$(
  m.Scope scope,
  String target,
) =>
    target.indexOf;
Function _String_lastIndexOf$(
  m.Scope scope,
  String target,
) =>
    target.lastIndexOf;
Function _String_substring$(
  m.Scope scope,
  String target,
) =>
    target.substring;
Function _String_trim$(
  m.Scope scope,
  String target,
) =>
    target.trim;
Function _String_trimLeft$(
  m.Scope scope,
  String target,
) =>
    target.trimLeft;
Function _String_trimRight$(
  m.Scope scope,
  String target,
) =>
    target.trimRight;
Function _String_padLeft$(
  m.Scope scope,
  String target,
) =>
    target.padLeft;
Function _String_padRight$(
  m.Scope scope,
  String target,
) =>
    target.padRight;
Function _String_contains$(
  m.Scope scope,
  String target,
) =>
    target.contains;
Function _String_replaceFirst$(
  m.Scope scope,
  String target,
) =>
    target.replaceFirst;
Function _String_replaceAll$(
  m.Scope scope,
  String target,
) =>
    target.replaceAll;
Function _String_replaceRange$(
  m.Scope scope,
  String target,
) =>
    target.replaceRange;
Function _String_split$(
  m.Scope scope,
  String target,
) =>
    target.split;
Function _String_toLowerCase$(
  m.Scope scope,
  String target,
) =>
    target.toLowerCase;
Function _String_toUpperCase$(
  m.Scope scope,
  String target,
) =>
    target.toUpperCase;
String _Runes_string$(Runes target) {
  return target.string;
}

RuneIterator _Runes_iterator$(Runes target) {
  return target.iterator;
}

int _Runes_last$(Runes target) {
  return target.last;
}

String _RuneIterator_string$(RuneIterator target) {
  return target.string;
}

int _RuneIterator_rawIndex$(RuneIterator target) {
  return target.rawIndex;
}

void _RuneIterator_rawIndex_set$(
  RuneIterator target,
  int other,
) {
  target.rawIndex = other;
}

int _RuneIterator_current$(RuneIterator target) {
  return target.current;
}

int _RuneIterator_currentSize$(RuneIterator target) {
  return target.currentSize;
}

String _RuneIterator_currentAsString$(RuneIterator target) {
  return target.currentAsString;
}

Function _RuneIterator_reset$(
  m.Scope scope,
  RuneIterator target,
) =>
    target.reset;
Function _RuneIterator_moveNext$(
  m.Scope scope,
  RuneIterator target,
) =>
    target.moveNext;
Function _RuneIterator_movePrevious$(
  m.Scope scope,
  RuneIterator target,
) =>
    target.movePrevious;
int _StringBuffer_length$(StringBuffer target) {
  return target.length;
}

bool _StringBuffer_isEmpty$(StringBuffer target) {
  return target.isEmpty;
}

bool _StringBuffer_isNotEmpty$(StringBuffer target) {
  return target.isNotEmpty;
}

Function _StringBuffer_write$(
  m.Scope scope,
  StringBuffer target,
) =>
    target.write;
Function _StringBuffer_writeCharCode$(
  m.Scope scope,
  StringBuffer target,
) =>
    target.writeCharCode;
Function _StringBuffer_writeAll$(
  m.Scope scope,
  StringBuffer target,
) =>
    target.writeAll;
Function _StringBuffer_writeln$(
  m.Scope scope,
  StringBuffer target,
) =>
    target.writeln;
Function _StringBuffer_clear$(
  m.Scope scope,
  StringBuffer target,
) =>
    target.clear;
Function _StringBuffer_toString$(
  m.Scope scope,
  StringBuffer target,
) =>
    target.toString;
Function _StringSink_write$(
  m.Scope scope,
  StringSink target,
) =>
    target.write;
Function _StringSink_writeAll$(
  m.Scope scope,
  StringSink target,
) =>
    target.writeAll;
Function _StringSink_writeln$(
  m.Scope scope,
  StringSink target,
) =>
    target.writeln;
Function _StringSink_writeCharCode$(
  m.Scope scope,
  StringSink target,
) =>
    target.writeCharCode;
Symbol _Symbol_unaryMinus$() {
  return Symbol.unaryMinus;
}

Symbol _Symbol_empty$() {
  return Symbol.empty;
}

int _Symbol_hashCode$(Symbol target) {
  return target.hashCode;
}

int _Type_hashCode$(Type target) {
  return target.hashCode;
}

Function _Type_toString$(
  m.Scope scope,
  Type target,
) =>
    target.toString;
Uri _Uri_base$() {
  return Uri.base;
}

String _Uri_scheme$(Uri target) {
  return target.scheme;
}

String _Uri_authority$(Uri target) {
  return target.authority;
}

String _Uri_userInfo$(Uri target) {
  return target.userInfo;
}

String _Uri_host$(Uri target) {
  return target.host;
}

int _Uri_port$(Uri target) {
  return target.port;
}

String _Uri_path$(Uri target) {
  return target.path;
}

String _Uri_query$(Uri target) {
  return target.query;
}

String _Uri_fragment$(Uri target) {
  return target.fragment;
}

List<String> _Uri_pathSegments$(Uri target) {
  return target.pathSegments;
}

Map<String, String> _Uri_queryParameters$(Uri target) {
  return target.queryParameters;
}

Map<String, List<String>> _Uri_queryParametersAll$(Uri target) {
  return target.queryParametersAll;
}

bool _Uri_isAbsolute$(Uri target) {
  return target.isAbsolute;
}

bool _Uri_hasScheme$(Uri target) {
  return target.hasScheme;
}

bool _Uri_hasAuthority$(Uri target) {
  return target.hasAuthority;
}

bool _Uri_hasPort$(Uri target) {
  return target.hasPort;
}

bool _Uri_hasQuery$(Uri target) {
  return target.hasQuery;
}

bool _Uri_hasFragment$(Uri target) {
  return target.hasFragment;
}

bool _Uri_hasEmptyPath$(Uri target) {
  return target.hasEmptyPath;
}

bool _Uri_hasAbsolutePath$(Uri target) {
  return target.hasAbsolutePath;
}

String _Uri_origin$(Uri target) {
  return target.origin;
}

UriData? _Uri_data$(Uri target) {
  return target.data;
}

int _Uri_hashCode$(Uri target) {
  return target.hashCode;
}

Function _Uri_isScheme$(
  m.Scope scope,
  Uri target,
) =>
    target.isScheme;
Function _Uri_toFilePath$(
  m.Scope scope,
  Uri target,
) =>
    target.toFilePath;
Function _Uri_toString$(
  m.Scope scope,
  Uri target,
) =>
    target.toString;
Function _Uri_replace$(
  m.Scope scope,
  Uri target,
) =>
    target.replace;
Function _Uri_removeFragment$(
  m.Scope scope,
  Uri target,
) =>
    target.removeFragment;
Function _Uri_resolve$(
  m.Scope scope,
  Uri target,
) =>
    target.resolve;
Function _Uri_resolveUri$(
  m.Scope scope,
  Uri target,
) =>
    target.resolveUri;
Function _Uri_normalizePath$(
  m.Scope scope,
  Uri target,
) =>
    target.normalizePath;
Function _Uri_parse$(m.Scope scope) => Uri.parse;
Function _Uri_tryParse$(m.Scope scope) => Uri.tryParse;
Function _Uri_encodeComponent$(m.Scope scope) => Uri.encodeComponent;
Function _Uri_encodeQueryComponent$(m.Scope scope) => Uri.encodeQueryComponent;
Function _Uri_decodeComponent$(m.Scope scope) => Uri.decodeComponent;
Function _Uri_decodeQueryComponent$(m.Scope scope) => Uri.decodeQueryComponent;
Function _Uri_encodeFull$(m.Scope scope) => Uri.encodeFull;
Function _Uri_decodeFull$(m.Scope scope) => Uri.decodeFull;
Function _Uri_splitQueryString$(m.Scope scope) => Uri.splitQueryString;
Function _Uri_parseIPv4Address$(m.Scope scope) => Uri.parseIPv4Address;
Function _Uri_parseIPv6Address$(m.Scope scope) => Uri.parseIPv6Address;
Uri _UriData_uri$(UriData target) {
  return target.uri;
}

String _UriData_mimeType$(UriData target) {
  return target.mimeType;
}

String _UriData_charset$(UriData target) {
  return target.charset;
}

bool _UriData_isBase64$(UriData target) {
  return target.isBase64;
}

String _UriData_contentText$(UriData target) {
  return target.contentText;
}

Map<String, String> _UriData_parameters$(UriData target) {
  return target.parameters;
}

Function _UriData_parse$(m.Scope scope) => UriData.parse;
Function _UriData_isMimeType$(
  m.Scope scope,
  UriData target,
) =>
    target.isMimeType;
Function _UriData_isCharset$(
  m.Scope scope,
  UriData target,
) =>
    target.isCharset;
Function _UriData_isEncoding$(
  m.Scope scope,
  UriData target,
) =>
    target.isEncoding;
Function _UriData_contentAsBytes$(
  m.Scope scope,
  UriData target,
) =>
    target.contentAsBytes;
Function _UriData_contentAsString$(
  m.Scope scope,
  UriData target,
) =>
    target.contentAsString;
Function _UriData_toString$(
  m.Scope scope,
  UriData target,
) =>
    target.toString;
String? _Expando_name$<T extends Object>(Expando<T> target) {
  return target.name;
}

Function _Expando_toString$<T extends Object>(
  m.Scope scope,
  Expando<T> target,
) =>
    target.toString;
T? _WeakReference_target$<T extends Object>(WeakReference<T> target) {
  return target.target;
}

Function _Finalizer_attach$<T>(
  m.Scope scope,
  Finalizer<T> target,
) =>
    target.attach;
Function _Finalizer_detach$<T>(
  m.Scope scope,
  Finalizer<T> target,
) =>
    target.detach;
