// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/rendering/texture.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/rendering/object.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/rendering/texture.dart',
  {'TextureBox.': _TextureBox__$},
  {},
  {
    'TextureBox': m.ClassMirror(
      'TextureBox',
      {
        '#as': TextureBox_as$,
        '#is': TextureBox_is$,
        'textureId': _TextureBox_textureId$,
        'freeze': _TextureBox_freeze$,
        'filterQuality': _TextureBox_filterQuality$,
        'sizedByParent': _TextureBox_sizedByParent$,
        'alwaysNeedsCompositing': _TextureBox_alwaysNeedsCompositing$,
        'isRepaintBoundary': _TextureBox_isRepaintBoundary$,
        'computeDryLayout': _TextureBox_computeDryLayout$,
        'hitTestSelf': _TextureBox_hitTestSelf$,
        'paint': _TextureBox_paint$,
      },
      {
        'textureId': _TextureBox_textureId_set$,
        'freeze': _TextureBox_freeze_set$,
        'filterQuality': _TextureBox_filterQuality_set$,
      },
    )
  },
);
Function TextureBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextureBox;
Function TextureBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextureBox;
Function _TextureBox_textureId$(
  m.Scope scope$,
  TextureBox target$,
) =>
    () {
      return target$.textureId;
    };
void _TextureBox_textureId_set$(
  m.Scope scope$,
  TextureBox target$,
) =>
    (dynamic other$) {
      target$.textureId = other$;
    };
Function _TextureBox_freeze$(
  m.Scope scope$,
  TextureBox target$,
) =>
    () {
      return target$.freeze;
    };
void _TextureBox_freeze_set$(
  m.Scope scope$,
  TextureBox target$,
) =>
    (dynamic other$) {
      target$.freeze = other$;
    };
Function _TextureBox_filterQuality$(
  m.Scope scope$,
  TextureBox target$,
) =>
    () {
      return target$.filterQuality;
    };
void _TextureBox_filterQuality_set$(
  m.Scope scope$,
  TextureBox target$,
) =>
    (dynamic other$) {
      target$.filterQuality = other$;
    };
Function _TextureBox_sizedByParent$(
  m.Scope scope$,
  TextureBox target$,
) =>
    () {
      return target$.sizedByParent;
    };
Function _TextureBox_alwaysNeedsCompositing$(
  m.Scope scope$,
  TextureBox target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _TextureBox_isRepaintBoundary$(
  m.Scope scope$,
  TextureBox target$,
) =>
    () {
      return target$.isRepaintBoundary;
    };
Function _TextureBox__$(m.Scope scope$) => ({
      required int textureId,
      bool? freeze,
      FilterQuality? filterQuality,
    }) {
      return TextureBox(
        filterQuality: filterQuality ?? FilterQuality.low,
        freeze: freeze ?? false,
        textureId: textureId,
      );
    };
Function _TextureBox_computeDryLayout$(
  m.Scope scope$,
  TextureBox target$,
) =>
    target$.computeDryLayout;
Function _TextureBox_hitTestSelf$(
  m.Scope scope$,
  TextureBox target$,
) =>
    target$.hitTestSelf;
Function _TextureBox_paint$(
  m.Scope scope$,
  TextureBox target$,
) =>
    target$.paint;
