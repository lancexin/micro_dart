// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/menu_anchor.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/button_style.dart';
import 'package:flutter/src/material/button_style_button.dart';
import 'package:flutter/src/material/checkbox.dart';
import 'package:flutter/src/material/color_scheme.dart';
import 'package:flutter/src/material/colors.dart';
import 'package:flutter/src/material/constants.dart';
import 'package:flutter/src/material/icons.dart';
import 'package:flutter/src/material/ink_well.dart';
import 'package:flutter/src/material/material.dart';
import 'package:flutter/src/material/material_localizations.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/menu_bar_theme.dart';
import 'package:flutter/src/material/menu_button_theme.dart';
import 'package:flutter/src/material/menu_style.dart';
import 'package:flutter/src/material/menu_theme.dart';
import 'package:flutter/src/material/radio.dart';
import 'package:flutter/src/material/text_button.dart';
import 'package:flutter/src/material/theme.dart';
import 'package:flutter/src/material/theme_data.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/menu_anchor.dart',
  {
    'MenuAnchor.': _MenuAnchor__$,
    'MenuController.': _MenuController__$,
    'MenuBar.': _MenuBar__$,
    'MenuItemButton.': _MenuItemButton__$,
    'MenuItemButton.styleFrom': _MenuItemButton_styleFrom$,
    'CheckboxMenuButton.': _CheckboxMenuButton__$,
    'RadioMenuButton.': _RadioMenuButton__$,
    'SubmenuButton.': _SubmenuButton__$,
    'SubmenuButton.styleFrom': _SubmenuButton_styleFrom$,
    'DismissMenuAction.': _DismissMenuAction__$,
    'MenuAcceleratorCallbackBinding.': _MenuAcceleratorCallbackBinding__$,
    'MenuAcceleratorCallbackBinding.maybeOf':
        _MenuAcceleratorCallbackBinding_maybeOf$,
    'MenuAcceleratorCallbackBinding.of': _MenuAcceleratorCallbackBinding_of$,
    'MenuAcceleratorLabel.': _MenuAcceleratorLabel__$,
    'MenuAcceleratorLabel.defaultLabelBuilder':
        _MenuAcceleratorLabel_defaultLabelBuilder$,
    'MenuAcceleratorLabel.stripAcceleratorMarkers':
        _MenuAcceleratorLabel_stripAcceleratorMarkers$,
  },
  {},
  {
    'MenuAnchor': m.ClassMirror(
      'MenuAnchor',
      {
        '#as': MenuAnchor_as$,
        '#is': MenuAnchor_is$,
        'controller': _MenuAnchor_controller$,
        'childFocusNode': _MenuAnchor_childFocusNode$,
        'style': _MenuAnchor_style$,
        'alignmentOffset': _MenuAnchor_alignmentOffset$,
        'clipBehavior': _MenuAnchor_clipBehavior$,
        'anchorTapClosesMenu': _MenuAnchor_anchorTapClosesMenu$,
        'onOpen': _MenuAnchor_onOpen$,
        'onClose': _MenuAnchor_onClose$,
        'crossAxisUnconstrained': _MenuAnchor_crossAxisUnconstrained$,
        'menuChildren': _MenuAnchor_menuChildren$,
        'builder': _MenuAnchor_builder$,
        'child': _MenuAnchor_child$,
        'createState': _MenuAnchor_createState$,
        'debugDescribeChildren': _MenuAnchor_debugDescribeChildren$,
        'debugFillProperties': _MenuAnchor_debugFillProperties$,
      },
      {},
    ),
    'MenuController': m.ClassMirror(
      'MenuController',
      {
        '#as': MenuController_as$,
        '#is': MenuController_is$,
        'isOpen': _MenuController_isOpen$,
        'close': _MenuController_close$,
        'open': _MenuController_open$,
      },
      {},
    ),
    'MenuBar': m.ClassMirror(
      'MenuBar',
      {
        '#as': MenuBar_as$,
        '#is': MenuBar_is$,
        'style': _MenuBar_style$,
        'clipBehavior': _MenuBar_clipBehavior$,
        'controller': _MenuBar_controller$,
        'children': _MenuBar_children$,
        'build': _MenuBar_build$,
        'debugDescribeChildren': _MenuBar_debugDescribeChildren$,
        'debugFillProperties': _MenuBar_debugFillProperties$,
      },
      {},
    ),
    'MenuItemButton': m.ClassMirror(
      'MenuItemButton',
      {
        '#as': MenuItemButton_as$,
        '#is': MenuItemButton_is$,
        'onPressed': _MenuItemButton_onPressed$,
        'onHover': _MenuItemButton_onHover$,
        'requestFocusOnHover': _MenuItemButton_requestFocusOnHover$,
        'onFocusChange': _MenuItemButton_onFocusChange$,
        'focusNode': _MenuItemButton_focusNode$,
        'shortcut': _MenuItemButton_shortcut$,
        'style': _MenuItemButton_style$,
        'statesController': _MenuItemButton_statesController$,
        'clipBehavior': _MenuItemButton_clipBehavior$,
        'leadingIcon': _MenuItemButton_leadingIcon$,
        'trailingIcon': _MenuItemButton_trailingIcon$,
        'closeOnActivate': _MenuItemButton_closeOnActivate$,
        'child': _MenuItemButton_child$,
        'enabled': _MenuItemButton_enabled$,
        'createState': _MenuItemButton_createState$,
        'defaultStyleOf': _MenuItemButton_defaultStyleOf$,
        'themeStyleOf': _MenuItemButton_themeStyleOf$,
        'debugFillProperties': _MenuItemButton_debugFillProperties$,
      },
      {},
    ),
    'CheckboxMenuButton': m.ClassMirror(
      'CheckboxMenuButton',
      {
        '#as': CheckboxMenuButton_as$,
        '#is': CheckboxMenuButton_is$,
        'value': _CheckboxMenuButton_value$,
        'tristate': _CheckboxMenuButton_tristate$,
        'isError': _CheckboxMenuButton_isError$,
        'onChanged': _CheckboxMenuButton_onChanged$,
        'onHover': _CheckboxMenuButton_onHover$,
        'onFocusChange': _CheckboxMenuButton_onFocusChange$,
        'focusNode': _CheckboxMenuButton_focusNode$,
        'shortcut': _CheckboxMenuButton_shortcut$,
        'style': _CheckboxMenuButton_style$,
        'statesController': _CheckboxMenuButton_statesController$,
        'clipBehavior': _CheckboxMenuButton_clipBehavior$,
        'trailingIcon': _CheckboxMenuButton_trailingIcon$,
        'closeOnActivate': _CheckboxMenuButton_closeOnActivate$,
        'child': _CheckboxMenuButton_child$,
        'enabled': _CheckboxMenuButton_enabled$,
        'build': _CheckboxMenuButton_build$,
      },
      {},
    ),
    'RadioMenuButton': m.ClassMirror(
      'RadioMenuButton',
      {
        '#as': RadioMenuButton_as$,
        '#is': RadioMenuButton_is$,
        'value': _RadioMenuButton_value$,
        'groupValue': _RadioMenuButton_groupValue$,
        'toggleable': _RadioMenuButton_toggleable$,
        'onChanged': _RadioMenuButton_onChanged$,
        'onHover': _RadioMenuButton_onHover$,
        'onFocusChange': _RadioMenuButton_onFocusChange$,
        'focusNode': _RadioMenuButton_focusNode$,
        'shortcut': _RadioMenuButton_shortcut$,
        'style': _RadioMenuButton_style$,
        'statesController': _RadioMenuButton_statesController$,
        'clipBehavior': _RadioMenuButton_clipBehavior$,
        'trailingIcon': _RadioMenuButton_trailingIcon$,
        'closeOnActivate': _RadioMenuButton_closeOnActivate$,
        'child': _RadioMenuButton_child$,
        'enabled': _RadioMenuButton_enabled$,
        'build': _RadioMenuButton_build$,
      },
      {},
    ),
    'SubmenuButton': m.ClassMirror(
      'SubmenuButton',
      {
        '#as': SubmenuButton_as$,
        '#is': SubmenuButton_is$,
        'onHover': _SubmenuButton_onHover$,
        'onFocusChange': _SubmenuButton_onFocusChange$,
        'onOpen': _SubmenuButton_onOpen$,
        'onClose': _SubmenuButton_onClose$,
        'style': _SubmenuButton_style$,
        'menuStyle': _SubmenuButton_menuStyle$,
        'alignmentOffset': _SubmenuButton_alignmentOffset$,
        'clipBehavior': _SubmenuButton_clipBehavior$,
        'focusNode': _SubmenuButton_focusNode$,
        'statesController': _SubmenuButton_statesController$,
        'leadingIcon': _SubmenuButton_leadingIcon$,
        'trailingIcon': _SubmenuButton_trailingIcon$,
        'menuChildren': _SubmenuButton_menuChildren$,
        'child': _SubmenuButton_child$,
        'createState': _SubmenuButton_createState$,
        'defaultStyleOf': _SubmenuButton_defaultStyleOf$,
        'themeStyleOf': _SubmenuButton_themeStyleOf$,
        'debugDescribeChildren': _SubmenuButton_debugDescribeChildren$,
        'debugFillProperties': _SubmenuButton_debugFillProperties$,
      },
      {},
    ),
    'DismissMenuAction': m.ClassMirror(
      'DismissMenuAction',
      {
        '#as': DismissMenuAction_as$,
        '#is': DismissMenuAction_is$,
        'controller': _DismissMenuAction_controller$,
        'invoke': _DismissMenuAction_invoke$,
        'isEnabled': _DismissMenuAction_isEnabled$,
      },
      {},
    ),
    'MenuAcceleratorCallbackBinding': m.ClassMirror(
      'MenuAcceleratorCallbackBinding',
      {
        '#as': MenuAcceleratorCallbackBinding_as$,
        '#is': MenuAcceleratorCallbackBinding_is$,
        'onInvoke': _MenuAcceleratorCallbackBinding_onInvoke$,
        'hasSubmenu': _MenuAcceleratorCallbackBinding_hasSubmenu$,
        'updateShouldNotify':
            _MenuAcceleratorCallbackBinding_updateShouldNotify$,
      },
      {},
    ),
    'MenuAcceleratorLabel': m.ClassMirror(
      'MenuAcceleratorLabel',
      {
        '#as': MenuAcceleratorLabel_as$,
        '#is': MenuAcceleratorLabel_is$,
        'label': _MenuAcceleratorLabel_label$,
        'builder': _MenuAcceleratorLabel_builder$,
        'displayLabel': _MenuAcceleratorLabel_displayLabel$,
        'hasAccelerator': _MenuAcceleratorLabel_hasAccelerator$,
        'createState': _MenuAcceleratorLabel_createState$,
        'toString': _MenuAcceleratorLabel_toString$,
        'debugFillProperties': _MenuAcceleratorLabel_debugFillProperties$,
      },
      {},
    ),
  },
);
Function MenuAnchor_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MenuAnchor;
Function MenuAnchor_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MenuAnchor;
Function _MenuAnchor_controller$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.controller;
    };
Function _MenuAnchor_childFocusNode$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.childFocusNode;
    };
Function _MenuAnchor_style$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.style;
    };
Function _MenuAnchor_alignmentOffset$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.alignmentOffset;
    };
Function _MenuAnchor_clipBehavior$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _MenuAnchor_anchorTapClosesMenu$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.anchorTapClosesMenu;
    };
Function _MenuAnchor_onOpen$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.onOpen;
    };
Function _MenuAnchor_onClose$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.onClose;
    };
Function _MenuAnchor_crossAxisUnconstrained$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.crossAxisUnconstrained;
    };
Function _MenuAnchor_menuChildren$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.menuChildren;
    };
Function _MenuAnchor_builder$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.builder;
    };
Function _MenuAnchor_child$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    () {
      return target$.child;
    };
Function _MenuAnchor__$(m.Scope scope$) => ({
      Key? key,
      MenuController? controller,
      FocusNode? childFocusNode,
      MenuStyle? style,
      Offset? alignmentOffset,
      Clip? clipBehavior,
      bool? anchorTapClosesMenu,
      m.FunctionPointer? onOpen,
      m.FunctionPointer? onClose,
      bool? crossAxisUnconstrained,
      required List menuChildren,
      m.FunctionPointer? builder,
      Widget? child,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        MenuController builder_controller$,
        Widget? builder_child$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder!,
            [
              builder_context$,
              builder_controller$,
              builder_child$,
            ],
            {},
          );
      void onCloseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onClose!,
            [],
            {},
          );
      void onOpenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onOpen!,
            [],
            {},
          );
      return MenuAnchor(
        alignmentOffset: alignmentOffset ?? Offset.zero,
        anchorTapClosesMenu: anchorTapClosesMenu ?? false,
        builder: builder == null ? null : builderProxy,
        child: child,
        childFocusNode: childFocusNode,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        controller: controller,
        crossAxisUnconstrained: crossAxisUnconstrained ?? true,
        key: key,
        menuChildren: List.from(menuChildren),
        onClose: onClose == null ? null : onCloseProxy,
        onOpen: onOpen == null ? null : onOpenProxy,
        style: style,
      );
    };
Function _MenuAnchor_createState$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    target$.createState;
Function _MenuAnchor_debugDescribeChildren$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    target$.debugDescribeChildren;
Function _MenuAnchor_debugFillProperties$(
  m.Scope scope$,
  MenuAnchor target$,
) =>
    target$.debugFillProperties;
Function MenuController_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MenuController;
Function MenuController_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MenuController;
Function _MenuController_isOpen$(
  m.Scope scope$,
  MenuController target$,
) =>
    () {
      return target$.isOpen;
    };
Function _MenuController__$(m.Scope scope$) => () {
      return MenuController();
    };
Function _MenuController_close$(
  m.Scope scope$,
  MenuController target$,
) =>
    target$.close;
Function _MenuController_open$(
  m.Scope scope$,
  MenuController target$,
) =>
    target$.open;
Function MenuBar_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MenuBar;
Function MenuBar_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MenuBar;
Function _MenuBar_style$(
  m.Scope scope$,
  MenuBar target$,
) =>
    () {
      return target$.style;
    };
Function _MenuBar_clipBehavior$(
  m.Scope scope$,
  MenuBar target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _MenuBar_controller$(
  m.Scope scope$,
  MenuBar target$,
) =>
    () {
      return target$.controller;
    };
Function _MenuBar_children$(
  m.Scope scope$,
  MenuBar target$,
) =>
    () {
      return target$.children;
    };
Function _MenuBar__$(m.Scope scope$) => ({
      Key? key,
      MenuStyle? style,
      Clip? clipBehavior,
      MenuController? controller,
      required List children,
    }) {
      return MenuBar(
        children: List.from(children),
        clipBehavior: clipBehavior ?? Clip.none,
        controller: controller,
        key: key,
        style: style,
      );
    };
Function _MenuBar_build$(
  m.Scope scope$,
  MenuBar target$,
) =>
    target$.build;
Function _MenuBar_debugDescribeChildren$(
  m.Scope scope$,
  MenuBar target$,
) =>
    target$.debugDescribeChildren;
Function _MenuBar_debugFillProperties$(
  m.Scope scope$,
  MenuBar target$,
) =>
    target$.debugFillProperties;
Function MenuItemButton_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MenuItemButton;
Function MenuItemButton_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MenuItemButton;
Function _MenuItemButton_onPressed$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.onPressed;
    };
Function _MenuItemButton_onHover$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.onHover;
    };
Function _MenuItemButton_requestFocusOnHover$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.requestFocusOnHover;
    };
Function _MenuItemButton_onFocusChange$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.onFocusChange;
    };
Function _MenuItemButton_focusNode$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.focusNode;
    };
Function _MenuItemButton_shortcut$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.shortcut;
    };
Function _MenuItemButton_style$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.style;
    };
Function _MenuItemButton_statesController$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.statesController;
    };
Function _MenuItemButton_clipBehavior$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _MenuItemButton_leadingIcon$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.leadingIcon;
    };
Function _MenuItemButton_trailingIcon$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.trailingIcon;
    };
Function _MenuItemButton_closeOnActivate$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.closeOnActivate;
    };
Function _MenuItemButton_child$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.child;
    };
Function _MenuItemButton_enabled$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    () {
      return target$.enabled;
    };
Function _MenuItemButton__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onPressed,
      m.FunctionPointer? onHover,
      bool? requestFocusOnHover,
      m.FunctionPointer? onFocusChange,
      FocusNode? focusNode,
      MenuSerializableShortcut? shortcut,
      ButtonStyle? style,
      MaterialStatesController? statesController,
      Clip? clipBehavior,
      Widget? leadingIcon,
      Widget? trailingIcon,
      bool? closeOnActivate,
      required Widget? child,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      void onHoverProxy(bool onHover_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_value$],
            {},
          );
      void onPressedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPressed!,
            [],
            {},
          );
      return MenuItemButton(
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        closeOnActivate: closeOnActivate ?? true,
        focusNode: focusNode,
        key: key,
        leadingIcon: leadingIcon,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onHover: onHover == null ? null : onHoverProxy,
        onPressed: onPressed == null ? null : onPressedProxy,
        requestFocusOnHover: requestFocusOnHover ?? true,
        shortcut: shortcut,
        statesController: statesController,
        style: style,
        trailingIcon: trailingIcon,
      );
    };
Function _MenuItemButton_createState$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    target$.createState;
Function _MenuItemButton_defaultStyleOf$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    target$.defaultStyleOf;
Function _MenuItemButton_themeStyleOf$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    target$.themeStyleOf;
Function _MenuItemButton_styleFrom$(m.Scope scope$) => MenuItemButton.styleFrom;
Function _MenuItemButton_debugFillProperties$(
  m.Scope scope$,
  MenuItemButton target$,
) =>
    target$.debugFillProperties;
Function CheckboxMenuButton_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CheckboxMenuButton;
Function CheckboxMenuButton_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CheckboxMenuButton;
Function _CheckboxMenuButton_value$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.value;
    };
Function _CheckboxMenuButton_tristate$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.tristate;
    };
Function _CheckboxMenuButton_isError$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.isError;
    };
Function _CheckboxMenuButton_onChanged$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.onChanged;
    };
Function _CheckboxMenuButton_onHover$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.onHover;
    };
Function _CheckboxMenuButton_onFocusChange$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.onFocusChange;
    };
Function _CheckboxMenuButton_focusNode$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.focusNode;
    };
Function _CheckboxMenuButton_shortcut$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.shortcut;
    };
Function _CheckboxMenuButton_style$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.style;
    };
Function _CheckboxMenuButton_statesController$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.statesController;
    };
Function _CheckboxMenuButton_clipBehavior$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _CheckboxMenuButton_trailingIcon$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.trailingIcon;
    };
Function _CheckboxMenuButton_closeOnActivate$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.closeOnActivate;
    };
Function _CheckboxMenuButton_child$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.child;
    };
Function _CheckboxMenuButton_enabled$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    () {
      return target$.enabled;
    };
Function _CheckboxMenuButton__$(m.Scope scope$) => ({
      Key? key,
      required bool? value,
      bool? tristate,
      bool? isError,
      required m.FunctionPointer? onChanged,
      m.FunctionPointer? onHover,
      m.FunctionPointer? onFocusChange,
      FocusNode? focusNode,
      MenuSerializableShortcut? shortcut,
      ButtonStyle? style,
      MaterialStatesController? statesController,
      Clip? clipBehavior,
      Widget? trailingIcon,
      bool? closeOnActivate,
      required Widget? child,
    }) {
      void onChangedProxy(bool? onChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChanged!,
            [onChanged_value$],
            {},
          );
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      void onHoverProxy(bool onHover_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_value$],
            {},
          );
      return CheckboxMenuButton(
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        closeOnActivate: closeOnActivate ?? true,
        focusNode: focusNode,
        isError: isError ?? false,
        key: key,
        onChanged: onChanged == null ? null : onChangedProxy,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onHover: onHover == null ? null : onHoverProxy,
        shortcut: shortcut,
        statesController: statesController,
        style: style,
        trailingIcon: trailingIcon,
        tristate: tristate ?? false,
        value: value,
      );
    };
Function _CheckboxMenuButton_build$(
  m.Scope scope$,
  CheckboxMenuButton target$,
) =>
    target$.build;
Function RadioMenuButton_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RadioMenuButton<T>;
Function RadioMenuButton_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RadioMenuButton<T>;
Function _RadioMenuButton_value$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.value;
    };
Function _RadioMenuButton_groupValue$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.groupValue;
    };
Function _RadioMenuButton_toggleable$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.toggleable;
    };
Function _RadioMenuButton_onChanged$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.onChanged;
    };
Function _RadioMenuButton_onHover$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.onHover;
    };
Function _RadioMenuButton_onFocusChange$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.onFocusChange;
    };
Function _RadioMenuButton_focusNode$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.focusNode;
    };
Function _RadioMenuButton_shortcut$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.shortcut;
    };
Function _RadioMenuButton_style$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.style;
    };
Function _RadioMenuButton_statesController$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.statesController;
    };
Function _RadioMenuButton_clipBehavior$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _RadioMenuButton_trailingIcon$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.trailingIcon;
    };
Function _RadioMenuButton_closeOnActivate$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.closeOnActivate;
    };
Function _RadioMenuButton_child$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.child;
    };
Function _RadioMenuButton_enabled$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    () {
      return target$.enabled;
    };
Function _RadioMenuButton__$(m.Scope scope$) => ({
      Key? key,
      required dynamic value,
      required dynamic groupValue,
      required m.FunctionPointer? onChanged,
      bool? toggleable,
      m.FunctionPointer? onHover,
      m.FunctionPointer? onFocusChange,
      FocusNode? focusNode,
      MenuSerializableShortcut? shortcut,
      ButtonStyle? style,
      MaterialStatesController? statesController,
      Clip? clipBehavior,
      Widget? trailingIcon,
      bool? closeOnActivate,
      required Widget? child,
    }) {
      void onChangedProxy(dynamic onChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChanged!,
            [onChanged_value$],
            {},
          );
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      void onHoverProxy(bool onHover_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_value$],
            {},
          );
      return RadioMenuButton(
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        closeOnActivate: closeOnActivate ?? true,
        focusNode: focusNode,
        groupValue: groupValue,
        key: key,
        onChanged: onChanged == null ? null : onChangedProxy,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onHover: onHover == null ? null : onHoverProxy,
        shortcut: shortcut,
        statesController: statesController,
        style: style,
        toggleable: toggleable ?? false,
        trailingIcon: trailingIcon,
        value: value,
      );
    };
Function _RadioMenuButton_build$<T>(
  m.Scope scope$,
  RadioMenuButton<T> target$,
) =>
    target$.build;
Function SubmenuButton_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SubmenuButton;
Function SubmenuButton_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SubmenuButton;
Function _SubmenuButton_onHover$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.onHover;
    };
Function _SubmenuButton_onFocusChange$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.onFocusChange;
    };
Function _SubmenuButton_onOpen$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.onOpen;
    };
Function _SubmenuButton_onClose$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.onClose;
    };
Function _SubmenuButton_style$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.style;
    };
Function _SubmenuButton_menuStyle$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.menuStyle;
    };
Function _SubmenuButton_alignmentOffset$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.alignmentOffset;
    };
Function _SubmenuButton_clipBehavior$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _SubmenuButton_focusNode$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.focusNode;
    };
Function _SubmenuButton_statesController$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.statesController;
    };
Function _SubmenuButton_leadingIcon$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.leadingIcon;
    };
Function _SubmenuButton_trailingIcon$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.trailingIcon;
    };
Function _SubmenuButton_menuChildren$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.menuChildren;
    };
Function _SubmenuButton_child$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    () {
      return target$.child;
    };
Function _SubmenuButton__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onHover,
      m.FunctionPointer? onFocusChange,
      m.FunctionPointer? onOpen,
      m.FunctionPointer? onClose,
      ButtonStyle? style,
      MenuStyle? menuStyle,
      Offset? alignmentOffset,
      Clip? clipBehavior,
      FocusNode? focusNode,
      MaterialStatesController? statesController,
      Widget? leadingIcon,
      Widget? trailingIcon,
      required List menuChildren,
      required Widget? child,
    }) {
      void onCloseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onClose!,
            [],
            {},
          );
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      void onHoverProxy(bool onHover_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_value$],
            {},
          );
      void onOpenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onOpen!,
            [],
            {},
          );
      return SubmenuButton(
        alignmentOffset: alignmentOffset,
        child: child,
        clipBehavior: clipBehavior ?? Clip.hardEdge,
        focusNode: focusNode,
        key: key,
        leadingIcon: leadingIcon,
        menuChildren: List.from(menuChildren),
        menuStyle: menuStyle,
        onClose: onClose == null ? null : onCloseProxy,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onHover: onHover == null ? null : onHoverProxy,
        onOpen: onOpen == null ? null : onOpenProxy,
        statesController: statesController,
        style: style,
        trailingIcon: trailingIcon,
      );
    };
Function _SubmenuButton_createState$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    target$.createState;
Function _SubmenuButton_defaultStyleOf$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    target$.defaultStyleOf;
Function _SubmenuButton_themeStyleOf$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    target$.themeStyleOf;
Function _SubmenuButton_styleFrom$(m.Scope scope$) => SubmenuButton.styleFrom;
Function _SubmenuButton_debugDescribeChildren$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    target$.debugDescribeChildren;
Function _SubmenuButton_debugFillProperties$(
  m.Scope scope$,
  SubmenuButton target$,
) =>
    target$.debugFillProperties;
Function DismissMenuAction_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DismissMenuAction;
Function DismissMenuAction_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DismissMenuAction;
Function _DismissMenuAction_controller$(
  m.Scope scope$,
  DismissMenuAction target$,
) =>
    () {
      return target$.controller;
    };
Function _DismissMenuAction__$(m.Scope scope$) =>
    ({required MenuController controller}) {
      return DismissMenuAction(controller: controller);
    };
Function _DismissMenuAction_invoke$(
  m.Scope scope$,
  DismissMenuAction target$,
) =>
    target$.invoke;
Function _DismissMenuAction_isEnabled$(
  m.Scope scope$,
  DismissMenuAction target$,
) =>
    target$.isEnabled;
Function MenuAcceleratorCallbackBinding_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MenuAcceleratorCallbackBinding;
Function MenuAcceleratorCallbackBinding_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MenuAcceleratorCallbackBinding;
Function _MenuAcceleratorCallbackBinding_onInvoke$(
  m.Scope scope$,
  MenuAcceleratorCallbackBinding target$,
) =>
    () {
      return target$.onInvoke;
    };
Function _MenuAcceleratorCallbackBinding_hasSubmenu$(
  m.Scope scope$,
  MenuAcceleratorCallbackBinding target$,
) =>
    () {
      return target$.hasSubmenu;
    };
Function _MenuAcceleratorCallbackBinding__$(m.Scope scope$) => ({
      Key? key,
      m.FunctionPointer? onInvoke,
      bool? hasSubmenu,
      required Widget child,
    }) {
      void onInvokeProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onInvoke!,
            [],
            {},
          );
      return MenuAcceleratorCallbackBinding(
        child: child,
        hasSubmenu: hasSubmenu ?? false,
        key: key,
        onInvoke: onInvoke == null ? null : onInvokeProxy,
      );
    };
Function _MenuAcceleratorCallbackBinding_updateShouldNotify$(
  m.Scope scope$,
  MenuAcceleratorCallbackBinding target$,
) =>
    target$.updateShouldNotify;
Function _MenuAcceleratorCallbackBinding_maybeOf$(m.Scope scope$) =>
    MenuAcceleratorCallbackBinding.maybeOf;
Function _MenuAcceleratorCallbackBinding_of$(m.Scope scope$) =>
    MenuAcceleratorCallbackBinding.of;
Function MenuAcceleratorLabel_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MenuAcceleratorLabel;
Function MenuAcceleratorLabel_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MenuAcceleratorLabel;
Function _MenuAcceleratorLabel_label$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    () {
      return target$.label;
    };
Function _MenuAcceleratorLabel_builder$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    () {
      return target$.builder;
    };
Function _MenuAcceleratorLabel_displayLabel$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    () {
      return target$.displayLabel;
    };
Function _MenuAcceleratorLabel_hasAccelerator$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    () {
      return target$.hasAccelerator;
    };
Function _MenuAcceleratorLabel__$(m.Scope scope$) => (
      String label, {
      Key? key,
      m.FunctionPointer? builder,
    }) {
      Widget builderProxy(
        BuildContext builder_context$,
        String builder_label$,
        int builder_index$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            builder!,
            [
              builder_context$,
              builder_label$,
              builder_index$,
            ],
            {},
          );
      return MenuAcceleratorLabel(
        label,
        builder: builder == null
            ? MenuAcceleratorLabel.defaultLabelBuilder
            : builderProxy,
        key: key,
      );
    };
Function _MenuAcceleratorLabel_defaultLabelBuilder$(m.Scope scope$) =>
    MenuAcceleratorLabel.defaultLabelBuilder;
Function _MenuAcceleratorLabel_stripAcceleratorMarkers$(m.Scope scope$) => (
      String label, {
      m.FunctionPointer? setIndex,
    }) {
      void setIndexProxy(int setIndex_index$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            setIndex!,
            [setIndex_index$],
            {},
          );
      return MenuAcceleratorLabel.stripAcceleratorMarkers(
        label,
        setIndex: setIndex == null ? null : setIndexProxy,
      );
    };
Function _MenuAcceleratorLabel_createState$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    target$.createState;
Function _MenuAcceleratorLabel_toString$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    target$.toString;
Function _MenuAcceleratorLabel_debugFillProperties$(
  m.Scope scope$,
  MenuAcceleratorLabel target$,
) =>
    target$.debugFillProperties;
