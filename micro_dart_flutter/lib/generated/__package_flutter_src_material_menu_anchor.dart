// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/menu_anchor.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/button_style.dart';
import 'package:flutter/src/material/button_style_button.dart';
import 'package:flutter/src/material/checkbox.dart';
import 'package:flutter/src/material/color_scheme.dart';
import 'package:flutter/src/material/colors.dart';
import 'package:flutter/src/material/constants.dart';
import 'package:flutter/src/material/icons.dart';
import 'package:flutter/src/material/ink_well.dart';
import 'package:flutter/src/material/material.dart';
import 'package:flutter/src/material/material_localizations.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/menu_bar_theme.dart';
import 'package:flutter/src/material/menu_button_theme.dart';
import 'package:flutter/src/material/menu_style.dart';
import 'package:flutter/src/material/menu_theme.dart';
import 'package:flutter/src/material/radio.dart';
import 'package:flutter/src/material/text_button.dart';
import 'package:flutter/src/material/theme.dart';
import 'package:flutter/src/material/theme_data.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/menu_anchor.dart',
  {
    'MenuItemButton.styleFrom': _MenuItemButton_styleFrom$,
    'SubmenuButton.styleFrom': _SubmenuButton_styleFrom$,
    'MenuAcceleratorCallbackBinding.maybeOf':
        _MenuAcceleratorCallbackBinding_maybeOf$,
    'MenuAcceleratorCallbackBinding.of': _MenuAcceleratorCallbackBinding_of$,
    'MenuAcceleratorLabel.defaultLabelBuilder':
        _MenuAcceleratorLabel_defaultLabelBuilder$,
  },
  {},
  {
    'MenuAnchor': m.ClassMirror(
      'MenuAnchor',
      {
        'controller': _MenuAnchor_controller$,
        'childFocusNode': _MenuAnchor_childFocusNode$,
        'style': _MenuAnchor_style$,
        'alignmentOffset': _MenuAnchor_alignmentOffset$,
        'clipBehavior': _MenuAnchor_clipBehavior$,
        'anchorTapClosesMenu': _MenuAnchor_anchorTapClosesMenu$,
        'onOpen': _MenuAnchor_onOpen$,
        'onClose': _MenuAnchor_onClose$,
        'crossAxisUnconstrained': _MenuAnchor_crossAxisUnconstrained$,
        'menuChildren': _MenuAnchor_menuChildren$,
        'builder': _MenuAnchor_builder$,
        'child': _MenuAnchor_child$,
        'createState': _MenuAnchor_createState$,
        'debugDescribeChildren': _MenuAnchor_debugDescribeChildren$,
        'debugFillProperties': _MenuAnchor_debugFillProperties$,
      },
      {},
    ),
    'MenuController': m.ClassMirror(
      'MenuController',
      {
        'isOpen': _MenuController_isOpen$,
        'close': _MenuController_close$,
        'open': _MenuController_open$,
      },
      {},
    ),
    'MenuBar': m.ClassMirror(
      'MenuBar',
      {
        'style': _MenuBar_style$,
        'clipBehavior': _MenuBar_clipBehavior$,
        'controller': _MenuBar_controller$,
        'children': _MenuBar_children$,
        'build': _MenuBar_build$,
        'debugDescribeChildren': _MenuBar_debugDescribeChildren$,
        'debugFillProperties': _MenuBar_debugFillProperties$,
      },
      {},
    ),
    'MenuItemButton': m.ClassMirror(
      'MenuItemButton',
      {
        'onPressed': _MenuItemButton_onPressed$,
        'onHover': _MenuItemButton_onHover$,
        'requestFocusOnHover': _MenuItemButton_requestFocusOnHover$,
        'onFocusChange': _MenuItemButton_onFocusChange$,
        'focusNode': _MenuItemButton_focusNode$,
        'shortcut': _MenuItemButton_shortcut$,
        'style': _MenuItemButton_style$,
        'statesController': _MenuItemButton_statesController$,
        'clipBehavior': _MenuItemButton_clipBehavior$,
        'leadingIcon': _MenuItemButton_leadingIcon$,
        'trailingIcon': _MenuItemButton_trailingIcon$,
        'closeOnActivate': _MenuItemButton_closeOnActivate$,
        'child': _MenuItemButton_child$,
        'enabled': _MenuItemButton_enabled$,
        'createState': _MenuItemButton_createState$,
        'defaultStyleOf': _MenuItemButton_defaultStyleOf$,
        'themeStyleOf': _MenuItemButton_themeStyleOf$,
        'debugFillProperties': _MenuItemButton_debugFillProperties$,
      },
      {},
    ),
    'CheckboxMenuButton': m.ClassMirror(
      'CheckboxMenuButton',
      {
        'value': _CheckboxMenuButton_value$,
        'tristate': _CheckboxMenuButton_tristate$,
        'isError': _CheckboxMenuButton_isError$,
        'onChanged': _CheckboxMenuButton_onChanged$,
        'onHover': _CheckboxMenuButton_onHover$,
        'onFocusChange': _CheckboxMenuButton_onFocusChange$,
        'focusNode': _CheckboxMenuButton_focusNode$,
        'shortcut': _CheckboxMenuButton_shortcut$,
        'style': _CheckboxMenuButton_style$,
        'statesController': _CheckboxMenuButton_statesController$,
        'clipBehavior': _CheckboxMenuButton_clipBehavior$,
        'trailingIcon': _CheckboxMenuButton_trailingIcon$,
        'closeOnActivate': _CheckboxMenuButton_closeOnActivate$,
        'child': _CheckboxMenuButton_child$,
        'enabled': _CheckboxMenuButton_enabled$,
        'build': _CheckboxMenuButton_build$,
      },
      {},
    ),
    'RadioMenuButton': m.ClassMirror(
      'RadioMenuButton',
      {
        'value': _RadioMenuButton_value$,
        'groupValue': _RadioMenuButton_groupValue$,
        'toggleable': _RadioMenuButton_toggleable$,
        'onChanged': _RadioMenuButton_onChanged$,
        'onHover': _RadioMenuButton_onHover$,
        'onFocusChange': _RadioMenuButton_onFocusChange$,
        'focusNode': _RadioMenuButton_focusNode$,
        'shortcut': _RadioMenuButton_shortcut$,
        'style': _RadioMenuButton_style$,
        'statesController': _RadioMenuButton_statesController$,
        'clipBehavior': _RadioMenuButton_clipBehavior$,
        'trailingIcon': _RadioMenuButton_trailingIcon$,
        'closeOnActivate': _RadioMenuButton_closeOnActivate$,
        'child': _RadioMenuButton_child$,
        'enabled': _RadioMenuButton_enabled$,
        'build': _RadioMenuButton_build$,
      },
      {},
    ),
    'SubmenuButton': m.ClassMirror(
      'SubmenuButton',
      {
        'onHover': _SubmenuButton_onHover$,
        'onFocusChange': _SubmenuButton_onFocusChange$,
        'onOpen': _SubmenuButton_onOpen$,
        'onClose': _SubmenuButton_onClose$,
        'style': _SubmenuButton_style$,
        'menuStyle': _SubmenuButton_menuStyle$,
        'alignmentOffset': _SubmenuButton_alignmentOffset$,
        'clipBehavior': _SubmenuButton_clipBehavior$,
        'focusNode': _SubmenuButton_focusNode$,
        'statesController': _SubmenuButton_statesController$,
        'leadingIcon': _SubmenuButton_leadingIcon$,
        'trailingIcon': _SubmenuButton_trailingIcon$,
        'menuChildren': _SubmenuButton_menuChildren$,
        'child': _SubmenuButton_child$,
        'createState': _SubmenuButton_createState$,
        'defaultStyleOf': _SubmenuButton_defaultStyleOf$,
        'themeStyleOf': _SubmenuButton_themeStyleOf$,
        'debugDescribeChildren': _SubmenuButton_debugDescribeChildren$,
        'debugFillProperties': _SubmenuButton_debugFillProperties$,
      },
      {},
    ),
    'DismissMenuAction': m.ClassMirror(
      'DismissMenuAction',
      {
        'controller': _DismissMenuAction_controller$,
        'invoke': _DismissMenuAction_invoke$,
        'isEnabled': _DismissMenuAction_isEnabled$,
      },
      {},
    ),
    'MenuAcceleratorCallbackBinding': m.ClassMirror(
      'MenuAcceleratorCallbackBinding',
      {
        'onInvoke': _MenuAcceleratorCallbackBinding_onInvoke$,
        'hasSubmenu': _MenuAcceleratorCallbackBinding_hasSubmenu$,
        'updateShouldNotify':
            _MenuAcceleratorCallbackBinding_updateShouldNotify$,
      },
      {},
    ),
    'MenuAcceleratorLabel': m.ClassMirror(
      'MenuAcceleratorLabel',
      {
        'label': _MenuAcceleratorLabel_label$,
        'builder': _MenuAcceleratorLabel_builder$,
        'displayLabel': _MenuAcceleratorLabel_displayLabel$,
        'hasAccelerator': _MenuAcceleratorLabel_hasAccelerator$,
        'createState': _MenuAcceleratorLabel_createState$,
        'toString': _MenuAcceleratorLabel_toString$,
        'debugFillProperties': _MenuAcceleratorLabel_debugFillProperties$,
      },
      {},
    ),
  },
);
MenuController? _MenuAnchor_controller$(MenuAnchor target) {
  return target.controller;
}

FocusNode? _MenuAnchor_childFocusNode$(MenuAnchor target) {
  return target.childFocusNode;
}

MenuStyle? _MenuAnchor_style$(MenuAnchor target) {
  return target.style;
}

Offset? _MenuAnchor_alignmentOffset$(MenuAnchor target) {
  return target.alignmentOffset;
}

Clip _MenuAnchor_clipBehavior$(MenuAnchor target) {
  return target.clipBehavior;
}

bool _MenuAnchor_anchorTapClosesMenu$(MenuAnchor target) {
  return target.anchorTapClosesMenu;
}

void Function()? _MenuAnchor_onOpen$(MenuAnchor target) {
  return target.onOpen;
}

void Function()? _MenuAnchor_onClose$(MenuAnchor target) {
  return target.onClose;
}

bool _MenuAnchor_crossAxisUnconstrained$(MenuAnchor target) {
  return target.crossAxisUnconstrained;
}

List<Widget> _MenuAnchor_menuChildren$(MenuAnchor target) {
  return target.menuChildren;
}

Widget Function(BuildContext, MenuController, Widget?)? _MenuAnchor_builder$(
    MenuAnchor target) {
  return target.builder;
}

Widget? _MenuAnchor_child$(MenuAnchor target) {
  return target.child;
}

Function _MenuAnchor_createState$(
  m.Scope scope,
  MenuAnchor target,
) =>
    target.createState;
Function _MenuAnchor_debugDescribeChildren$(
  m.Scope scope,
  MenuAnchor target,
) =>
    target.debugDescribeChildren;
Function _MenuAnchor_debugFillProperties$(
  m.Scope scope,
  MenuAnchor target,
) =>
    target.debugFillProperties;
bool _MenuController_isOpen$(MenuController target) {
  return target.isOpen;
}

Function _MenuController_close$(
  m.Scope scope,
  MenuController target,
) =>
    target.close;
Function _MenuController_open$(
  m.Scope scope,
  MenuController target,
) =>
    target.open;
MenuStyle? _MenuBar_style$(MenuBar target) {
  return target.style;
}

Clip _MenuBar_clipBehavior$(MenuBar target) {
  return target.clipBehavior;
}

MenuController? _MenuBar_controller$(MenuBar target) {
  return target.controller;
}

List<Widget> _MenuBar_children$(MenuBar target) {
  return target.children;
}

Function _MenuBar_build$(
  m.Scope scope,
  MenuBar target,
) =>
    target.build;
Function _MenuBar_debugDescribeChildren$(
  m.Scope scope,
  MenuBar target,
) =>
    target.debugDescribeChildren;
Function _MenuBar_debugFillProperties$(
  m.Scope scope,
  MenuBar target,
) =>
    target.debugFillProperties;
void Function()? _MenuItemButton_onPressed$(MenuItemButton target) {
  return target.onPressed;
}

void Function(bool)? _MenuItemButton_onHover$(MenuItemButton target) {
  return target.onHover;
}

bool _MenuItemButton_requestFocusOnHover$(MenuItemButton target) {
  return target.requestFocusOnHover;
}

void Function(bool)? _MenuItemButton_onFocusChange$(MenuItemButton target) {
  return target.onFocusChange;
}

FocusNode? _MenuItemButton_focusNode$(MenuItemButton target) {
  return target.focusNode;
}

MenuSerializableShortcut? _MenuItemButton_shortcut$(MenuItemButton target) {
  return target.shortcut;
}

ButtonStyle? _MenuItemButton_style$(MenuItemButton target) {
  return target.style;
}

MaterialStatesController? _MenuItemButton_statesController$(
    MenuItemButton target) {
  return target.statesController;
}

Clip _MenuItemButton_clipBehavior$(MenuItemButton target) {
  return target.clipBehavior;
}

Widget? _MenuItemButton_leadingIcon$(MenuItemButton target) {
  return target.leadingIcon;
}

Widget? _MenuItemButton_trailingIcon$(MenuItemButton target) {
  return target.trailingIcon;
}

bool _MenuItemButton_closeOnActivate$(MenuItemButton target) {
  return target.closeOnActivate;
}

Widget? _MenuItemButton_child$(MenuItemButton target) {
  return target.child;
}

bool _MenuItemButton_enabled$(MenuItemButton target) {
  return target.enabled;
}

Function _MenuItemButton_createState$(
  m.Scope scope,
  MenuItemButton target,
) =>
    target.createState;
Function _MenuItemButton_defaultStyleOf$(
  m.Scope scope,
  MenuItemButton target,
) =>
    target.defaultStyleOf;
Function _MenuItemButton_themeStyleOf$(
  m.Scope scope,
  MenuItemButton target,
) =>
    target.themeStyleOf;
Function _MenuItemButton_styleFrom$(m.Scope scope) => MenuItemButton.styleFrom;
Function _MenuItemButton_debugFillProperties$(
  m.Scope scope,
  MenuItemButton target,
) =>
    target.debugFillProperties;
bool? _CheckboxMenuButton_value$(CheckboxMenuButton target) {
  return target.value;
}

bool _CheckboxMenuButton_tristate$(CheckboxMenuButton target) {
  return target.tristate;
}

bool _CheckboxMenuButton_isError$(CheckboxMenuButton target) {
  return target.isError;
}

void Function(bool?)? _CheckboxMenuButton_onChanged$(
    CheckboxMenuButton target) {
  return target.onChanged;
}

void Function(bool)? _CheckboxMenuButton_onHover$(CheckboxMenuButton target) {
  return target.onHover;
}

void Function(bool)? _CheckboxMenuButton_onFocusChange$(
    CheckboxMenuButton target) {
  return target.onFocusChange;
}

FocusNode? _CheckboxMenuButton_focusNode$(CheckboxMenuButton target) {
  return target.focusNode;
}

MenuSerializableShortcut? _CheckboxMenuButton_shortcut$(
    CheckboxMenuButton target) {
  return target.shortcut;
}

ButtonStyle? _CheckboxMenuButton_style$(CheckboxMenuButton target) {
  return target.style;
}

MaterialStatesController? _CheckboxMenuButton_statesController$(
    CheckboxMenuButton target) {
  return target.statesController;
}

Clip _CheckboxMenuButton_clipBehavior$(CheckboxMenuButton target) {
  return target.clipBehavior;
}

Widget? _CheckboxMenuButton_trailingIcon$(CheckboxMenuButton target) {
  return target.trailingIcon;
}

bool _CheckboxMenuButton_closeOnActivate$(CheckboxMenuButton target) {
  return target.closeOnActivate;
}

Widget? _CheckboxMenuButton_child$(CheckboxMenuButton target) {
  return target.child;
}

bool _CheckboxMenuButton_enabled$(CheckboxMenuButton target) {
  return target.enabled;
}

Function _CheckboxMenuButton_build$(
  m.Scope scope,
  CheckboxMenuButton target,
) =>
    target.build;
T _RadioMenuButton_value$<T>(RadioMenuButton<T> target) {
  return target.value;
}

T? _RadioMenuButton_groupValue$<T>(RadioMenuButton<T> target) {
  return target.groupValue;
}

bool _RadioMenuButton_toggleable$<T>(RadioMenuButton<T> target) {
  return target.toggleable;
}

void Function(T?)? _RadioMenuButton_onChanged$<T>(RadioMenuButton<T> target) {
  return target.onChanged;
}

void Function(bool)? _RadioMenuButton_onHover$<T>(RadioMenuButton<T> target) {
  return target.onHover;
}

void Function(bool)? _RadioMenuButton_onFocusChange$<T>(
    RadioMenuButton<T> target) {
  return target.onFocusChange;
}

FocusNode? _RadioMenuButton_focusNode$<T>(RadioMenuButton<T> target) {
  return target.focusNode;
}

MenuSerializableShortcut? _RadioMenuButton_shortcut$<T>(
    RadioMenuButton<T> target) {
  return target.shortcut;
}

ButtonStyle? _RadioMenuButton_style$<T>(RadioMenuButton<T> target) {
  return target.style;
}

MaterialStatesController? _RadioMenuButton_statesController$<T>(
    RadioMenuButton<T> target) {
  return target.statesController;
}

Clip _RadioMenuButton_clipBehavior$<T>(RadioMenuButton<T> target) {
  return target.clipBehavior;
}

Widget? _RadioMenuButton_trailingIcon$<T>(RadioMenuButton<T> target) {
  return target.trailingIcon;
}

bool _RadioMenuButton_closeOnActivate$<T>(RadioMenuButton<T> target) {
  return target.closeOnActivate;
}

Widget? _RadioMenuButton_child$<T>(RadioMenuButton<T> target) {
  return target.child;
}

bool _RadioMenuButton_enabled$<T>(RadioMenuButton<T> target) {
  return target.enabled;
}

Function _RadioMenuButton_build$<T>(
  m.Scope scope,
  RadioMenuButton<T> target,
) =>
    target.build;
void Function(bool)? _SubmenuButton_onHover$(SubmenuButton target) {
  return target.onHover;
}

void Function(bool)? _SubmenuButton_onFocusChange$(SubmenuButton target) {
  return target.onFocusChange;
}

void Function()? _SubmenuButton_onOpen$(SubmenuButton target) {
  return target.onOpen;
}

void Function()? _SubmenuButton_onClose$(SubmenuButton target) {
  return target.onClose;
}

ButtonStyle? _SubmenuButton_style$(SubmenuButton target) {
  return target.style;
}

MenuStyle? _SubmenuButton_menuStyle$(SubmenuButton target) {
  return target.menuStyle;
}

Offset? _SubmenuButton_alignmentOffset$(SubmenuButton target) {
  return target.alignmentOffset;
}

Clip _SubmenuButton_clipBehavior$(SubmenuButton target) {
  return target.clipBehavior;
}

FocusNode? _SubmenuButton_focusNode$(SubmenuButton target) {
  return target.focusNode;
}

MaterialStatesController? _SubmenuButton_statesController$(
    SubmenuButton target) {
  return target.statesController;
}

Widget? _SubmenuButton_leadingIcon$(SubmenuButton target) {
  return target.leadingIcon;
}

Widget? _SubmenuButton_trailingIcon$(SubmenuButton target) {
  return target.trailingIcon;
}

List<Widget> _SubmenuButton_menuChildren$(SubmenuButton target) {
  return target.menuChildren;
}

Widget? _SubmenuButton_child$(SubmenuButton target) {
  return target.child;
}

Function _SubmenuButton_createState$(
  m.Scope scope,
  SubmenuButton target,
) =>
    target.createState;
Function _SubmenuButton_defaultStyleOf$(
  m.Scope scope,
  SubmenuButton target,
) =>
    target.defaultStyleOf;
Function _SubmenuButton_themeStyleOf$(
  m.Scope scope,
  SubmenuButton target,
) =>
    target.themeStyleOf;
Function _SubmenuButton_styleFrom$(m.Scope scope) => SubmenuButton.styleFrom;
Function _SubmenuButton_debugDescribeChildren$(
  m.Scope scope,
  SubmenuButton target,
) =>
    target.debugDescribeChildren;
Function _SubmenuButton_debugFillProperties$(
  m.Scope scope,
  SubmenuButton target,
) =>
    target.debugFillProperties;
MenuController _DismissMenuAction_controller$(DismissMenuAction target) {
  return target.controller;
}

Function _DismissMenuAction_invoke$(
  m.Scope scope,
  DismissMenuAction target,
) =>
    target.invoke;
Function _DismissMenuAction_isEnabled$(
  m.Scope scope,
  DismissMenuAction target,
) =>
    target.isEnabled;
void Function()? _MenuAcceleratorCallbackBinding_onInvoke$(
    MenuAcceleratorCallbackBinding target) {
  return target.onInvoke;
}

bool _MenuAcceleratorCallbackBinding_hasSubmenu$(
    MenuAcceleratorCallbackBinding target) {
  return target.hasSubmenu;
}

Function _MenuAcceleratorCallbackBinding_updateShouldNotify$(
  m.Scope scope,
  MenuAcceleratorCallbackBinding target,
) =>
    target.updateShouldNotify;
Function _MenuAcceleratorCallbackBinding_maybeOf$(m.Scope scope) =>
    MenuAcceleratorCallbackBinding.maybeOf;
Function _MenuAcceleratorCallbackBinding_of$(m.Scope scope) =>
    MenuAcceleratorCallbackBinding.of;
String _MenuAcceleratorLabel_label$(MenuAcceleratorLabel target) {
  return target.label;
}

Widget Function(BuildContext, String, int) _MenuAcceleratorLabel_builder$(
    MenuAcceleratorLabel target) {
  return target.builder;
}

String _MenuAcceleratorLabel_displayLabel$(MenuAcceleratorLabel target) {
  return target.displayLabel;
}

bool _MenuAcceleratorLabel_hasAccelerator$(MenuAcceleratorLabel target) {
  return target.hasAccelerator;
}

Function _MenuAcceleratorLabel_defaultLabelBuilder$(m.Scope scope) =>
    MenuAcceleratorLabel.defaultLabelBuilder;
Function _MenuAcceleratorLabel_createState$(
  m.Scope scope,
  MenuAcceleratorLabel target,
) =>
    target.createState;
Function _MenuAcceleratorLabel_toString$(
  m.Scope scope,
  MenuAcceleratorLabel target,
) =>
    target.toString;
Function _MenuAcceleratorLabel_debugFillProperties$(
  m.Scope scope,
  MenuAcceleratorLabel target,
) =>
    target.debugFillProperties;
