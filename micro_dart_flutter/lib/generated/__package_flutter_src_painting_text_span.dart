// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:flutter/painting.dart';
import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/text_span.dart',
  {
    'TextSpan.': _TextSpan__$,
    'TextSpan.visitChildren': _TextSpan_visitChildren$,
  },
  {},
  {
    'TextSpan': m.ClassMirror(
      'TextSpan',
      {
        '#as': TextSpan_as$,
        '#is': TextSpan_is$,
        'text': _TextSpan_text$,
        'children': _TextSpan_children$,
        'recognizer': _TextSpan_recognizer$,
        'mouseCursor': _TextSpan_mouseCursor$,
        'onEnter': _TextSpan_onEnter$,
        'onExit': _TextSpan_onExit$,
        'semanticsLabel': _TextSpan_semanticsLabel$,
        'locale': _TextSpan_locale$,
        'spellOut': _TextSpan_spellOut$,
        'cursor': _TextSpan_cursor$,
        'validForMouseTracker': _TextSpan_validForMouseTracker$,
        'hashCode': _TextSpan_hashCode$,
        'handleEvent': _TextSpan_handleEvent$,
        'build': _TextSpan_build$,
        'getSpanForPositionVisitor': _TextSpan_getSpanForPositionVisitor$,
        'computeToPlainText': _TextSpan_computeToPlainText$,
        'computeSemanticsInformation': _TextSpan_computeSemanticsInformation$,
        'codeUnitAtVisitor': _TextSpan_codeUnitAtVisitor$,
        'describeSemantics': _TextSpan_describeSemantics$,
        'debugAssertIsValid': _TextSpan_debugAssertIsValid$,
        'compareTo': _TextSpan_compareTo$,
        '==': _TextSpan_eq$$,
        'toStringShort': _TextSpan_toStringShort$,
        'debugFillProperties': _TextSpan_debugFillProperties$,
        'debugDescribeChildren': _TextSpan_debugDescribeChildren$,
      },
      {},
    )
  },
);
Function TextSpan_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextSpan;
Function TextSpan_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextSpan;
Function _TextSpan_text$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.text;
    };
Function _TextSpan_children$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.children;
    };
Function _TextSpan_recognizer$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.recognizer;
    };
Function _TextSpan_mouseCursor$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.mouseCursor;
    };
Function _TextSpan_onEnter$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.onEnter;
    };
Function _TextSpan_onExit$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.onExit;
    };
Function _TextSpan_semanticsLabel$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.semanticsLabel;
    };
Function _TextSpan_locale$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.locale;
    };
Function _TextSpan_spellOut$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.spellOut;
    };
Function _TextSpan_cursor$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.cursor;
    };
Function _TextSpan_validForMouseTracker$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.validForMouseTracker;
    };
Function _TextSpan_hashCode$(
  m.Scope scope$,
  TextSpan target$,
) =>
    () {
      return target$.hashCode;
    };
Function _TextSpan__$(m.Scope scope$) => ({
      String? text,
      List? children,
      TextStyle? style,
      GestureRecognizer? recognizer,
      MouseCursor? mouseCursor,
      m.FunctionPointer? onEnter,
      m.FunctionPointer? onExit,
      String? semanticsLabel,
      Locale? locale,
      bool? spellOut,
    }) {
      void onEnterProxy(PointerEnterEvent onEnter_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEnter!,
            [onEnter_event$],
            {},
          );
      void onExitProxy(PointerExitEvent onExit_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onExit!,
            [onExit_event$],
            {},
          );
      return TextSpan(
        children: children == null ? null : List.from(children),
        locale: locale,
        mouseCursor: mouseCursor,
        onEnter: onEnter == null ? null : onEnterProxy,
        onExit: onExit == null ? null : onExitProxy,
        recognizer: recognizer,
        semanticsLabel: semanticsLabel,
        spellOut: spellOut,
        style: style,
        text: text,
      );
    };
Function _TextSpan_handleEvent$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.handleEvent;
Function _TextSpan_build$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.build;
Function _TextSpan_visitChildren$(
  m.Scope scope$,
  TextSpan target$,
) =>
    (m.FunctionPointer visitor) {
      bool visitorProxy(InlineSpan visitor_span$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_span$],
            {},
          );
      return target$.visitChildren(visitorProxy);
    };
Function _TextSpan_getSpanForPositionVisitor$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.getSpanForPositionVisitor;
Function _TextSpan_computeToPlainText$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.computeToPlainText;
Function _TextSpan_computeSemanticsInformation$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.computeSemanticsInformation;
Function _TextSpan_codeUnitAtVisitor$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.codeUnitAtVisitor;
Function _TextSpan_describeSemantics$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.describeSemantics;
Function _TextSpan_debugAssertIsValid$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.debugAssertIsValid;
Function _TextSpan_compareTo$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.compareTo;
Function _TextSpan_eq$$(
  m.Scope scope$,
  TextSpan target$,
) =>
    (Object other$) => target$ == other$;
Function _TextSpan_toStringShort$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.toStringShort;
Function _TextSpan_debugFillProperties$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.debugFillProperties;
Function _TextSpan_debugDescribeChildren$(
  m.Scope scope$,
  TextSpan target$,
) =>
    target$.debugDescribeChildren;
