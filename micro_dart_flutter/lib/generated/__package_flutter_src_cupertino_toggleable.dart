// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/cupertino/toggleable.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/cupertino/toggleable.dart',
  {},
  {},
  {
    'ToggleablePainter': m.ClassMirror(
      'ToggleablePainter',
      {
        'activeColor': _ToggleablePainter_activeColor$,
        'inactiveColor': _ToggleablePainter_inactiveColor$,
        'focusColor': _ToggleablePainter_focusColor$,
        'downPosition': _ToggleablePainter_downPosition$,
        'isFocused': _ToggleablePainter_isFocused$,
        'isActive': _ToggleablePainter_isActive$,
        'semanticsBuilder': _ToggleablePainter_semanticsBuilder$,
        'shouldRepaint': _ToggleablePainter_shouldRepaint$,
        'hitTest': _ToggleablePainter_hitTest$,
        'shouldRebuildSemantics': _ToggleablePainter_shouldRebuildSemantics$,
        'toString': _ToggleablePainter_toString$,
      },
      {
        'activeColor': _ToggleablePainter_activeColor_set$,
        'inactiveColor': _ToggleablePainter_inactiveColor_set$,
        'focusColor': _ToggleablePainter_focusColor_set$,
        'downPosition': _ToggleablePainter_downPosition_set$,
        'isFocused': _ToggleablePainter_isFocused_set$,
        'isActive': _ToggleablePainter_isActive_set$,
      },
    )
  },
);
Color _ToggleablePainter_activeColor$(ToggleablePainter target) {
  return target.activeColor;
}

void _ToggleablePainter_activeColor_set$(
  ToggleablePainter target,
  Color other,
) {
  target.activeColor = other;
}

Color _ToggleablePainter_inactiveColor$(ToggleablePainter target) {
  return target.inactiveColor;
}

void _ToggleablePainter_inactiveColor_set$(
  ToggleablePainter target,
  Color other,
) {
  target.inactiveColor = other;
}

Color _ToggleablePainter_focusColor$(ToggleablePainter target) {
  return target.focusColor;
}

void _ToggleablePainter_focusColor_set$(
  ToggleablePainter target,
  Color other,
) {
  target.focusColor = other;
}

Offset? _ToggleablePainter_downPosition$(ToggleablePainter target) {
  return target.downPosition;
}

void _ToggleablePainter_downPosition_set$(
  ToggleablePainter target,
  Offset? other,
) {
  target.downPosition = other;
}

bool _ToggleablePainter_isFocused$(ToggleablePainter target) {
  return target.isFocused;
}

void _ToggleablePainter_isFocused_set$(
  ToggleablePainter target,
  bool? other,
) {
  target.isFocused = other;
}

bool _ToggleablePainter_isActive$(ToggleablePainter target) {
  return target.isActive;
}

void _ToggleablePainter_isActive_set$(
  ToggleablePainter target,
  bool? other,
) {
  target.isActive = other;
}

List<CustomPainterSemantics> Function(Size)?
    _ToggleablePainter_semanticsBuilder$(ToggleablePainter target) {
  return target.semanticsBuilder;
}

Function _ToggleablePainter_shouldRepaint$(
  m.Scope scope,
  ToggleablePainter target,
) =>
    target.shouldRepaint;
Function _ToggleablePainter_hitTest$(
  m.Scope scope,
  ToggleablePainter target,
) =>
    target.hitTest;
Function _ToggleablePainter_shouldRebuildSemantics$(
  m.Scope scope,
  ToggleablePainter target,
) =>
    target.shouldRebuildSemantics;
Function _ToggleablePainter_toString$(
  m.Scope scope,
  ToggleablePainter target,
) =>
    target.toString;
