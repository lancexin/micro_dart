// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/src/services/mouse_cursor.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/services/mouse_tracking.dart',
  {'MouseTrackerAnnotation.': _MouseTrackerAnnotation__$},
  {},
  {
    'MouseTrackerAnnotation': m.ClassMirror(
      'MouseTrackerAnnotation',
      {
        '#as': MouseTrackerAnnotation_as$,
        '#is': MouseTrackerAnnotation_is$,
        'onEnter': _MouseTrackerAnnotation_onEnter$,
        'onExit': _MouseTrackerAnnotation_onExit$,
        'cursor': _MouseTrackerAnnotation_cursor$,
        'validForMouseTracker': _MouseTrackerAnnotation_validForMouseTracker$,
        'debugFillProperties': _MouseTrackerAnnotation_debugFillProperties$,
      },
      {},
    )
  },
);
Function MouseTrackerAnnotation_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MouseTrackerAnnotation;
Function MouseTrackerAnnotation_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MouseTrackerAnnotation;
Function _MouseTrackerAnnotation_onEnter$(
  m.Scope scope$,
  MouseTrackerAnnotation target$,
) =>
    () {
      return target$.onEnter;
    };
Function _MouseTrackerAnnotation_onExit$(
  m.Scope scope$,
  MouseTrackerAnnotation target$,
) =>
    () {
      return target$.onExit;
    };
Function _MouseTrackerAnnotation_cursor$(
  m.Scope scope$,
  MouseTrackerAnnotation target$,
) =>
    () {
      return target$.cursor;
    };
Function _MouseTrackerAnnotation_validForMouseTracker$(
  m.Scope scope$,
  MouseTrackerAnnotation target$,
) =>
    () {
      return target$.validForMouseTracker;
    };
Function _MouseTrackerAnnotation__$(m.Scope scope$) => ({
      m.FunctionPointer? onEnter,
      m.FunctionPointer? onExit,
      MouseCursor? cursor,
      bool? validForMouseTracker,
    }) {
      void onEnterProxy(PointerEnterEvent onEnter_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEnter!,
            [onEnter_event$],
            {},
          );
      void onExitProxy(PointerExitEvent onExit_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onExit!,
            [onExit_event$],
            {},
          );
      return MouseTrackerAnnotation(
        cursor: cursor ?? MouseCursor.defer,
        onEnter: onEnter == null ? null : onEnterProxy,
        onExit: onExit == null ? null : onExitProxy,
        validForMouseTracker: validForMouseTracker ?? true,
      );
    };
Function _MouseTrackerAnnotation_debugFillProperties$(
  m.Scope scope$,
  MouseTrackerAnnotation target$,
) =>
    target$.debugFillProperties;
