// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/foundation/basic_types.dart';
import 'dart:collection';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/foundation/basic_types.dart',
  {'lerpDuration': _lerpDuration$},
  {},
  {
    'CachingIterable': m.ClassMirror(
      'CachingIterable',
      {
        'iterator': _CachingIterable_iterator$,
        'length': _CachingIterable_length$,
        'take': _CachingIterable_take$,
        'skip': _CachingIterable_skip$,
        'toList': _CachingIterable_toList$,
      },
      {},
    ),
    'Factory': m.ClassMirror(
      'Factory',
      {
        'constructor': _Factory_constructor$,
        'type': _Factory_type$,
        'toString': _Factory_toString$,
      },
      {},
    ),
  },
);
Iterator<E> _CachingIterable_iterator$<E>(CachingIterable<E> target) {
  return target.iterator;
}

int _CachingIterable_length$<E>(CachingIterable<E> target) {
  return target.length;
}

Function _CachingIterable_take$<E>(
  m.Scope scope,
  CachingIterable<E> target,
) =>
    target.take;
Function _CachingIterable_skip$<E>(
  m.Scope scope,
  CachingIterable<E> target,
) =>
    target.skip;
Function _CachingIterable_toList$<E>(
  m.Scope scope,
  CachingIterable<E> target,
) =>
    target.toList;
T Function() _Factory_constructor$<T>(Factory<T> target) {
  return target.constructor;
}

Type _Factory_type$<T>(Factory<T> target) {
  return target.type;
}

Function _Factory_toString$<T>(
  m.Scope scope,
  Factory<T> target,
) =>
    target.toString;
Function _lerpDuration$(m.Scope scope) => lerpDuration;
