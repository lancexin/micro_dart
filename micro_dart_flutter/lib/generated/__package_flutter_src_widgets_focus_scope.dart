// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/focus_scope.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/focus_manager.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/inherited_notifier.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/focus_scope.dart',
  {
    'Focus.': _Focus__$,
    'Focus.withExternalFocusNode': _Focus_withExternalFocusNode_$,
    'Focus.of': _Focus_of$,
    'Focus.maybeOf': _Focus_maybeOf$,
    'Focus.isAt': _Focus_isAt$,
    'FocusScope.': _FocusScope__$,
    'FocusScope.withExternalFocusNode': _FocusScope_withExternalFocusNode_$,
    'FocusScope.of': _FocusScope_of$,
    'ExcludeFocus.': _ExcludeFocus__$,
  },
  {},
  {
    'Focus': m.ClassMirror(
      'Focus',
      {
        '#as': Focus_as$,
        '#is': Focus_is$,
        'parentNode': _Focus_parentNode$,
        'child': _Focus_child$,
        'focusNode': _Focus_focusNode$,
        'autofocus': _Focus_autofocus$,
        'onFocusChange': _Focus_onFocusChange$,
        'includeSemantics': _Focus_includeSemantics$,
        'onKeyEvent': _Focus_onKeyEvent$,
        'onKey': _Focus_onKey$,
        'canRequestFocus': _Focus_canRequestFocus$,
        'skipTraversal': _Focus_skipTraversal$,
        'descendantsAreFocusable': _Focus_descendantsAreFocusable$,
        'descendantsAreTraversable': _Focus_descendantsAreTraversable$,
        'debugLabel': _Focus_debugLabel$,
        'debugFillProperties': _Focus_debugFillProperties$,
        'createState': _Focus_createState$,
      },
      {},
    ),
    'FocusScope': m.ClassMirror(
      'FocusScope',
      {
        '#as': FocusScope_as$,
        '#is': FocusScope_is$,
        'createState': _FocusScope_createState$,
      },
      {},
    ),
    'ExcludeFocus': m.ClassMirror(
      'ExcludeFocus',
      {
        '#as': ExcludeFocus_as$,
        '#is': ExcludeFocus_is$,
        'excluding': _ExcludeFocus_excluding$,
        'child': _ExcludeFocus_child$,
        'build': _ExcludeFocus_build$,
      },
      {},
    ),
  },
);
Function Focus_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Focus;
Function Focus_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Focus;
Function _Focus_parentNode$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.parentNode;
    };
Function _Focus_child$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.child;
    };
Function _Focus_focusNode$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.focusNode;
    };
Function _Focus_autofocus$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.autofocus;
    };
Function _Focus_onFocusChange$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.onFocusChange;
    };
Function _Focus_includeSemantics$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.includeSemantics;
    };
Function _Focus_onKeyEvent$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.onKeyEvent;
    };
Function _Focus_onKey$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.onKey;
    };
Function _Focus_canRequestFocus$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.canRequestFocus;
    };
Function _Focus_skipTraversal$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.skipTraversal;
    };
Function _Focus_descendantsAreFocusable$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.descendantsAreFocusable;
    };
Function _Focus_descendantsAreTraversable$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.descendantsAreTraversable;
    };
Function _Focus_debugLabel$(
  m.Scope scope$,
  Focus target$,
) =>
    () {
      return target$.debugLabel;
    };
Function _Focus__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      FocusNode? focusNode,
      FocusNode? parentNode,
      bool? autofocus,
      m.FunctionPointer? onFocusChange,
      m.FunctionPointer? onKeyEvent,
      m.FunctionPointer? onKey,
      bool? canRequestFocus,
      bool? skipTraversal,
      bool? descendantsAreFocusable,
      bool? descendantsAreTraversable,
      bool? includeSemantics,
      String? debugLabel,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      KeyEventResult onKeyProxy(
        FocusNode onKey_node$,
        RawKeyEvent onKey_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKey!,
            [
              onKey_node$,
              onKey_event$,
            ],
            {},
          );
      KeyEventResult onKeyEventProxy(
        FocusNode onKeyEvent_node$,
        KeyEvent onKeyEvent_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKeyEvent!,
            [
              onKeyEvent_node$,
              onKeyEvent_event$,
            ],
            {},
          );
      return Focus(
        autofocus: autofocus ?? false,
        canRequestFocus: canRequestFocus,
        child: child,
        debugLabel: debugLabel,
        descendantsAreFocusable: descendantsAreFocusable,
        descendantsAreTraversable: descendantsAreTraversable,
        focusNode: focusNode,
        includeSemantics: includeSemantics ?? true,
        key: key,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onKey: onKey == null ? null : onKeyProxy,
        onKeyEvent: onKeyEvent == null ? null : onKeyEventProxy,
        parentNode: parentNode,
        skipTraversal: skipTraversal,
      );
    };
Function _Focus_withExternalFocusNode_$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      required FocusNode focusNode,
      FocusNode? parentNode,
      required bool autofocus,
      m.FunctionPointer? onFocusChange,
      required bool includeSemantics,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      return Focus.withExternalFocusNode(
        autofocus: autofocus,
        child: child,
        focusNode: focusNode,
        includeSemantics: includeSemantics,
        key: key,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        parentNode: parentNode,
      );
    };
Function _Focus_of$(m.Scope scope$) => Focus.of;
Function _Focus_maybeOf$(m.Scope scope$) => Focus.maybeOf;
Function _Focus_isAt$(m.Scope scope$) => Focus.isAt;
Function _Focus_debugFillProperties$(
  m.Scope scope$,
  Focus target$,
) =>
    target$.debugFillProperties;
Function _Focus_createState$(
  m.Scope scope$,
  Focus target$,
) =>
    target$.createState;
Function FocusScope_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FocusScope;
Function FocusScope_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FocusScope;
Function _FocusScope__$(m.Scope scope$) => ({
      Key? key,
      FocusScopeNode? node,
      FocusNode? parentNode,
      required Widget child,
      bool? autofocus,
      m.FunctionPointer? onFocusChange,
      bool? canRequestFocus,
      bool? skipTraversal,
      m.FunctionPointer? onKeyEvent,
      m.FunctionPointer? onKey,
      String? debugLabel,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      KeyEventResult onKeyProxy(
        FocusNode onKey_node$,
        RawKeyEvent onKey_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKey!,
            [
              onKey_node$,
              onKey_event$,
            ],
            {},
          );
      KeyEventResult onKeyEventProxy(
        FocusNode onKeyEvent_node$,
        KeyEvent onKeyEvent_event$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onKeyEvent!,
            [
              onKeyEvent_node$,
              onKeyEvent_event$,
            ],
            {},
          );
      return FocusScope(
        autofocus: autofocus ?? false,
        canRequestFocus: canRequestFocus,
        child: child,
        debugLabel: debugLabel,
        key: key,
        node: node,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        onKey: onKey == null ? null : onKeyProxy,
        onKeyEvent: onKeyEvent == null ? null : onKeyEventProxy,
        parentNode: parentNode,
        skipTraversal: skipTraversal,
      );
    };
Function _FocusScope_withExternalFocusNode_$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      required FocusScopeNode focusScopeNode,
      FocusNode? parentNode,
      required bool autofocus,
      m.FunctionPointer? onFocusChange,
    }) {
      void onFocusChangeProxy(bool onFocusChange_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onFocusChange!,
            [onFocusChange_value$],
            {},
          );
      return FocusScope.withExternalFocusNode(
        autofocus: autofocus,
        child: child,
        focusScopeNode: focusScopeNode,
        key: key,
        onFocusChange: onFocusChange == null ? null : onFocusChangeProxy,
        parentNode: parentNode,
      );
    };
Function _FocusScope_of$(m.Scope scope$) => FocusScope.of;
Function _FocusScope_createState$(
  m.Scope scope$,
  FocusScope target$,
) =>
    target$.createState;
Function ExcludeFocus_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ExcludeFocus;
Function ExcludeFocus_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ExcludeFocus;
Function _ExcludeFocus_excluding$(
  m.Scope scope$,
  ExcludeFocus target$,
) =>
    () {
      return target$.excluding;
    };
Function _ExcludeFocus_child$(
  m.Scope scope$,
  ExcludeFocus target$,
) =>
    () {
      return target$.child;
    };
Function _ExcludeFocus__$(m.Scope scope$) => ({
      Key? key,
      bool? excluding,
      required Widget child,
    }) {
      return ExcludeFocus(
        child: child,
        excluding: excluding ?? true,
        key: key,
      );
    };
Function _ExcludeFocus_build$(
  m.Scope scope$,
  ExcludeFocus target$,
) =>
    target$.build;
