// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/focus_scope.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/focus_manager.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/inherited_notifier.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/focus_scope.dart',
  {
    'Focus.of': _Focus_of$,
    'Focus.maybeOf': _Focus_maybeOf$,
    'Focus.isAt': _Focus_isAt$,
    'FocusScope.of': _FocusScope_of$,
  },
  {},
  {
    'Focus': m.ClassMirror(
      'Focus',
      {
        '#as': Focus_as$,
        '#is': Focus_is$,
        'parentNode': _Focus_parentNode$,
        'child': _Focus_child$,
        'focusNode': _Focus_focusNode$,
        'autofocus': _Focus_autofocus$,
        'onFocusChange': _Focus_onFocusChange$,
        'includeSemantics': _Focus_includeSemantics$,
        'onKeyEvent': _Focus_onKeyEvent$,
        'onKey': _Focus_onKey$,
        'canRequestFocus': _Focus_canRequestFocus$,
        'skipTraversal': _Focus_skipTraversal$,
        'descendantsAreFocusable': _Focus_descendantsAreFocusable$,
        'descendantsAreTraversable': _Focus_descendantsAreTraversable$,
        'debugLabel': _Focus_debugLabel$,
        'debugFillProperties': _Focus_debugFillProperties$,
        'createState': _Focus_createState$,
      },
      {},
    ),
    'FocusScope': m.ClassMirror(
      'FocusScope',
      {
        '#as': FocusScope_as$,
        '#is': FocusScope_is$,
        'createState': _FocusScope_createState$,
      },
      {},
    ),
    'ExcludeFocus': m.ClassMirror(
      'ExcludeFocus',
      {
        '#as': ExcludeFocus_as$,
        '#is': ExcludeFocus_is$,
        'excluding': _ExcludeFocus_excluding$,
        'child': _ExcludeFocus_child$,
        'build': _ExcludeFocus_build$,
      },
      {},
    ),
  },
);
Function Focus_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as Focus;
Function Focus_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is Focus;
FocusNode? _Focus_parentNode$(Focus target) {
  return target.parentNode;
}

Widget _Focus_child$(Focus target) {
  return target.child;
}

FocusNode? _Focus_focusNode$(Focus target) {
  return target.focusNode;
}

bool _Focus_autofocus$(Focus target) {
  return target.autofocus;
}

void Function(bool)? _Focus_onFocusChange$(Focus target) {
  return target.onFocusChange;
}

bool _Focus_includeSemantics$(Focus target) {
  return target.includeSemantics;
}

KeyEventResult Function(FocusNode, KeyEvent)? _Focus_onKeyEvent$(Focus target) {
  return target.onKeyEvent;
}

KeyEventResult Function(FocusNode, RawKeyEvent)? _Focus_onKey$(Focus target) {
  return target.onKey;
}

bool _Focus_canRequestFocus$(Focus target) {
  return target.canRequestFocus;
}

bool _Focus_skipTraversal$(Focus target) {
  return target.skipTraversal;
}

bool _Focus_descendantsAreFocusable$(Focus target) {
  return target.descendantsAreFocusable;
}

bool _Focus_descendantsAreTraversable$(Focus target) {
  return target.descendantsAreTraversable;
}

String? _Focus_debugLabel$(Focus target) {
  return target.debugLabel;
}

Function _Focus_of$(m.Scope scope) => Focus.of;
Function _Focus_maybeOf$(m.Scope scope) => Focus.maybeOf;
Function _Focus_isAt$(m.Scope scope) => Focus.isAt;
Function _Focus_debugFillProperties$(
  m.Scope scope,
  Focus target,
) =>
    target.debugFillProperties;
Function _Focus_createState$(
  m.Scope scope,
  Focus target,
) =>
    target.createState;
Function FocusScope_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as FocusScope;
Function FocusScope_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is FocusScope;
Function _FocusScope_of$(m.Scope scope) => FocusScope.of;
Function _FocusScope_createState$(
  m.Scope scope,
  FocusScope target,
) =>
    target.createState;
Function ExcludeFocus_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ExcludeFocus;
Function ExcludeFocus_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ExcludeFocus;
bool _ExcludeFocus_excluding$(ExcludeFocus target) {
  return target.excluding;
}

Widget _ExcludeFocus_child$(ExcludeFocus target) {
  return target.child;
}

Function _ExcludeFocus_build$(
  m.Scope scope,
  ExcludeFocus target,
) =>
    target.build;
