// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/image_provider.dart';
import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'dart:ui';
import 'dart:ui' show Locale, Size, TextDirection;
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/painting/binding.dart';
import 'package:flutter/src/painting/image_cache.dart';
import 'package:flutter/src/painting/image_stream.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/image_provider.dart',
  {
    'ImageConfiguration.empty': _ImageConfiguration_empty$,
    'ImageProvider.obtainCacheStatus': _ImageProvider_obtainCacheStatus$,
    'ImageProvider.resolveStreamForKey': _ImageProvider_resolveStreamForKey$,
    'ImageProvider.loadImage': _ImageProvider_loadImage$,
    'AssetBundleImageProvider.loadImage': _AssetBundleImageProvider_loadImage$,
    'AssetBundleImageProvider.loadBuffer':
        _AssetBundleImageProvider_loadBuffer$,
    'AssetBundleImageProvider.load': _AssetBundleImageProvider_load$,
    'ResizeImage.resizeIfNeeded': _ResizeImage_resizeIfNeeded$,
    'ResizeImage.loadImage': _ResizeImage_loadImage$,
    'NetworkImage.load': _NetworkImage_load$,
    'NetworkImage.loadBuffer': _NetworkImage_loadBuffer$,
    'NetworkImage.loadImage': _NetworkImage_loadImage$,
    'FileImage.load': _FileImage_load$,
    'FileImage.loadBuffer': _FileImage_loadBuffer$,
    'FileImage.loadImage': _FileImage_loadImage$,
    'MemoryImage.load': _MemoryImage_load$,
    'MemoryImage.loadBuffer': _MemoryImage_loadBuffer$,
    'MemoryImage.loadImage': _MemoryImage_loadImage$,
    'ResizeImagePolicy.exact': _ResizeImagePolicy_exact$,
    'ResizeImagePolicy.fit': _ResizeImagePolicy_fit$,
    'ResizeImagePolicy.values': _ResizeImagePolicy_values$,
  },
  {},
  {
    'ImageConfiguration': m.ClassMirror(
      'ImageConfiguration',
      {
        '#as': ImageConfiguration_as$,
        '#is': ImageConfiguration_is$,
        'bundle': _ImageConfiguration_bundle$,
        'devicePixelRatio': _ImageConfiguration_devicePixelRatio$,
        'locale': _ImageConfiguration_locale$,
        'textDirection': _ImageConfiguration_textDirection$,
        'size': _ImageConfiguration_size$,
        'platform': _ImageConfiguration_platform$,
        'hashCode': _ImageConfiguration_hashCode$,
        'copyWith': _ImageConfiguration_copyWith$,
        '==': _ImageConfiguration_eq$$,
        'toString': _ImageConfiguration_toString$,
      },
      {},
    ),
    'ImageProvider': m.ClassMirror(
      'ImageProvider',
      {
        '#as': ImageProvider_as$,
        '#is': ImageProvider_is$,
        'resolve': _ImageProvider_resolve$,
        'createStream': _ImageProvider_createStream$,
        'evict': _ImageProvider_evict$,
        'obtainKey': _ImageProvider_obtainKey$,
        'toString': _ImageProvider_toString$,
      },
      {},
    ),
    'AssetBundleImageKey': m.ClassMirror(
      'AssetBundleImageKey',
      {
        '#as': AssetBundleImageKey_as$,
        '#is': AssetBundleImageKey_is$,
        'bundle': _AssetBundleImageKey_bundle$,
        'name': _AssetBundleImageKey_name$,
        'scale': _AssetBundleImageKey_scale$,
        'hashCode': _AssetBundleImageKey_hashCode$,
        '==': _AssetBundleImageKey_eq$$,
        'toString': _AssetBundleImageKey_toString$,
      },
      {},
    ),
    'AssetBundleImageProvider': m.ClassMirror(
      'AssetBundleImageProvider',
      {
        '#as': AssetBundleImageProvider_as$,
        '#is': AssetBundleImageProvider_is$,
      },
      {},
    ),
    'ResizeImageKey': m.ClassMirror(
      'ResizeImageKey',
      {
        '#as': ResizeImageKey_as$,
        '#is': ResizeImageKey_is$,
        'hashCode': _ResizeImageKey_hashCode$,
        '==': _ResizeImageKey_eq$$,
      },
      {},
    ),
    'ResizeImage': m.ClassMirror(
      'ResizeImage',
      {
        '#as': ResizeImage_as$,
        '#is': ResizeImage_is$,
        'imageProvider': _ResizeImage_imageProvider$,
        'width': _ResizeImage_width$,
        'height': _ResizeImage_height$,
        'policy': _ResizeImage_policy$,
        'allowUpscaling': _ResizeImage_allowUpscaling$,
        'obtainKey': _ResizeImage_obtainKey$,
      },
      {},
    ),
    'NetworkImage': m.ClassMirror(
      'NetworkImage',
      {
        '#as': NetworkImage_as$,
        '#is': NetworkImage_is$,
        'url': _NetworkImage_url$,
        'scale': _NetworkImage_scale$,
        'headers': _NetworkImage_headers$,
      },
      {},
    ),
    'FileImage': m.ClassMirror(
      'FileImage',
      {
        '#as': FileImage_as$,
        '#is': FileImage_is$,
        'file': _FileImage_file$,
        'scale': _FileImage_scale$,
        'hashCode': _FileImage_hashCode$,
        'obtainKey': _FileImage_obtainKey$,
        '==': _FileImage_eq$$,
        'toString': _FileImage_toString$,
      },
      {},
    ),
    'MemoryImage': m.ClassMirror(
      'MemoryImage',
      {
        '#as': MemoryImage_as$,
        '#is': MemoryImage_is$,
        'bytes': _MemoryImage_bytes$,
        'scale': _MemoryImage_scale$,
        'hashCode': _MemoryImage_hashCode$,
        'obtainKey': _MemoryImage_obtainKey$,
        '==': _MemoryImage_eq$$,
        'toString': _MemoryImage_toString$,
      },
      {},
    ),
    'ExactAssetImage': m.ClassMirror(
      'ExactAssetImage',
      {
        '#as': ExactAssetImage_as$,
        '#is': ExactAssetImage_is$,
        'assetName': _ExactAssetImage_assetName$,
        'scale': _ExactAssetImage_scale$,
        'bundle': _ExactAssetImage_bundle$,
        'package': _ExactAssetImage_package$,
        'keyName': _ExactAssetImage_keyName$,
        'hashCode': _ExactAssetImage_hashCode$,
        'obtainKey': _ExactAssetImage_obtainKey$,
        '==': _ExactAssetImage_eq$$,
        'toString': _ExactAssetImage_toString$,
      },
      {},
    ),
    'NetworkImageLoadException': m.ClassMirror(
      'NetworkImageLoadException',
      {
        '#as': NetworkImageLoadException_as$,
        '#is': NetworkImageLoadException_is$,
        'statusCode': _NetworkImageLoadException_statusCode$,
        'uri': _NetworkImageLoadException_uri$,
        'toString': _NetworkImageLoadException_toString$,
      },
      {},
    ),
    'ResizeImagePolicy': m.ClassMirror(
      'ResizeImagePolicy',
      {},
      {},
    ),
  },
);
Function ImageConfiguration_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ImageConfiguration;
Function ImageConfiguration_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ImageConfiguration;
AssetBundle? _ImageConfiguration_bundle$(ImageConfiguration target) {
  return target.bundle;
}

double? _ImageConfiguration_devicePixelRatio$(ImageConfiguration target) {
  return target.devicePixelRatio;
}

Locale? _ImageConfiguration_locale$(ImageConfiguration target) {
  return target.locale;
}

TextDirection? _ImageConfiguration_textDirection$(ImageConfiguration target) {
  return target.textDirection;
}

Size? _ImageConfiguration_size$(ImageConfiguration target) {
  return target.size;
}

TargetPlatform? _ImageConfiguration_platform$(ImageConfiguration target) {
  return target.platform;
}

ImageConfiguration _ImageConfiguration_empty$() {
  return ImageConfiguration.empty;
}

int _ImageConfiguration_hashCode$(ImageConfiguration target) {
  return target.hashCode;
}

Function _ImageConfiguration_copyWith$(
  m.Scope scope,
  ImageConfiguration target,
) =>
    target.copyWith;
Function _ImageConfiguration_eq$$(
  m.Scope scope,
  ImageConfiguration target,
) =>
    (Object other) => target == other;
Function _ImageConfiguration_toString$(
  m.Scope scope,
  ImageConfiguration target,
) =>
    target.toString;
Function ImageProvider_as$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ImageProvider<T>;
Function ImageProvider_is$<T extends Object>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ImageProvider<T>;
Function _ImageProvider_resolve$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    target.resolve;
Function _ImageProvider_createStream$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    target.createStream;
Function _ImageProvider_obtainCacheStatus$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    ({
      required ImageConfiguration configuration,
      m.FunctionPointer? handleError,
    }) {
      void handleErrorProxy(
        Object handleError_exception,
        StackTrace? handleError_stackTrace,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            handleError!,
            [
              handleError_exception,
              handleError_stackTrace,
            ],
            {},
          );
      return target.obtainCacheStatus(
        configuration: configuration,
        handleError: handleError == null ? null : handleErrorProxy,
      );
    };
Function _ImageProvider_resolveStreamForKey$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    (
      ImageConfiguration configuration,
      ImageStream stream,
      T key,
      m.FunctionPointer handleError,
    ) {
      void handleErrorProxy(
        Object handleError_exception,
        StackTrace? handleError_stackTrace,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            handleError,
            [
              handleError_exception,
              handleError_stackTrace,
            ],
            {},
          );
      target.resolveStreamForKey(
        configuration,
        stream,
        key,
        handleErrorProxy,
      );
    };
Function _ImageProvider_evict$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    target.evict;
Function _ImageProvider_obtainKey$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    target.obtainKey;
Function _ImageProvider_loadImage$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    (
      T key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {'getTargetSize': getTargetSize},
          );
      return target.loadImage(
        key,
        decodeProxy,
      );
    };
Function _ImageProvider_toString$<T extends Object>(
  m.Scope scope,
  ImageProvider<T> target,
) =>
    target.toString;
Function AssetBundleImageKey_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as AssetBundleImageKey;
Function AssetBundleImageKey_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is AssetBundleImageKey;
AssetBundle _AssetBundleImageKey_bundle$(AssetBundleImageKey target) {
  return target.bundle;
}

String _AssetBundleImageKey_name$(AssetBundleImageKey target) {
  return target.name;
}

double _AssetBundleImageKey_scale$(AssetBundleImageKey target) {
  return target.scale;
}

int _AssetBundleImageKey_hashCode$(AssetBundleImageKey target) {
  return target.hashCode;
}

Function _AssetBundleImageKey_eq$$(
  m.Scope scope,
  AssetBundleImageKey target,
) =>
    (Object other) => target == other;
Function _AssetBundleImageKey_toString$(
  m.Scope scope,
  AssetBundleImageKey target,
) =>
    target.toString;
Function AssetBundleImageProvider_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as AssetBundleImageProvider;
Function AssetBundleImageProvider_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is AssetBundleImageProvider;
Function _AssetBundleImageProvider_loadImage$(
  m.Scope scope,
  AssetBundleImageProvider target,
) =>
    (
      AssetBundleImageKey key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {'getTargetSize': getTargetSize},
          );
      return target.loadImage(
        key,
        decodeProxy,
      );
    };
Function _AssetBundleImageProvider_loadBuffer$(
  m.Scope scope,
  AssetBundleImageProvider target,
) =>
    (
      AssetBundleImageKey key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.loadBuffer(
        key,
        decodeProxy,
      );
    };
Function _AssetBundleImageProvider_load$(
  m.Scope scope,
  AssetBundleImageProvider target,
) =>
    (
      AssetBundleImageKey key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        Uint8List decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.load(
        key,
        decodeProxy,
      );
    };
Function ResizeImageKey_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ResizeImageKey;
Function ResizeImageKey_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ResizeImageKey;
int _ResizeImageKey_hashCode$(ResizeImageKey target) {
  return target.hashCode;
}

Function _ResizeImageKey_eq$$(
  m.Scope scope,
  ResizeImageKey target,
) =>
    (Object other) => target == other;
Function ResizeImage_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ResizeImage;
Function ResizeImage_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ResizeImage;
ImageProvider<Object> _ResizeImage_imageProvider$(ResizeImage target) {
  return target.imageProvider;
}

int? _ResizeImage_width$(ResizeImage target) {
  return target.width;
}

int? _ResizeImage_height$(ResizeImage target) {
  return target.height;
}

ResizeImagePolicy _ResizeImage_policy$(ResizeImage target) {
  return target.policy;
}

bool _ResizeImage_allowUpscaling$(ResizeImage target) {
  return target.allowUpscaling;
}

Function _ResizeImage_resizeIfNeeded$(m.Scope scope) =>
    ResizeImage.resizeIfNeeded;
Function _ResizeImage_loadImage$(
  m.Scope scope,
  ResizeImage target,
) =>
    (
      ResizeImageKey key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {'getTargetSize': getTargetSize},
          );
      return target.loadImage(
        key,
        decodeProxy,
      );
    };
Function _ResizeImage_obtainKey$(
  m.Scope scope,
  ResizeImage target,
) =>
    target.obtainKey;
Function NetworkImage_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as NetworkImage;
Function NetworkImage_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is NetworkImage;
String _NetworkImage_url$(NetworkImage target) {
  return target.url;
}

double _NetworkImage_scale$(NetworkImage target) {
  return target.scale;
}

Map<String, String>? _NetworkImage_headers$(NetworkImage target) {
  return target.headers;
}

Function _NetworkImage_load$(
  m.Scope scope,
  NetworkImage target,
) =>
    (
      NetworkImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        Uint8List decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.load(
        key,
        decodeProxy,
      );
    };
Function _NetworkImage_loadBuffer$(
  m.Scope scope,
  NetworkImage target,
) =>
    (
      NetworkImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.loadBuffer(
        key,
        decodeProxy,
      );
    };
Function _NetworkImage_loadImage$(
  m.Scope scope,
  NetworkImage target,
) =>
    (
      NetworkImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {'getTargetSize': getTargetSize},
          );
      return target.loadImage(
        key,
        decodeProxy,
      );
    };
Function FileImage_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as FileImage;
Function FileImage_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is FileImage;
File _FileImage_file$(FileImage target) {
  return target.file;
}

double _FileImage_scale$(FileImage target) {
  return target.scale;
}

int _FileImage_hashCode$(FileImage target) {
  return target.hashCode;
}

Function _FileImage_obtainKey$(
  m.Scope scope,
  FileImage target,
) =>
    target.obtainKey;
Function _FileImage_load$(
  m.Scope scope,
  FileImage target,
) =>
    (
      FileImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        Uint8List decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.load(
        key,
        decodeProxy,
      );
    };
Function _FileImage_loadBuffer$(
  m.Scope scope,
  FileImage target,
) =>
    (
      FileImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.loadBuffer(
        key,
        decodeProxy,
      );
    };
Function _FileImage_loadImage$(
  m.Scope scope,
  FileImage target,
) =>
    (
      FileImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {'getTargetSize': getTargetSize},
          );
      return target.loadImage(
        key,
        decodeProxy,
      );
    };
Function _FileImage_eq$$(
  m.Scope scope,
  FileImage target,
) =>
    (Object other) => target == other;
Function _FileImage_toString$(
  m.Scope scope,
  FileImage target,
) =>
    target.toString;
Function MemoryImage_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as MemoryImage;
Function MemoryImage_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is MemoryImage;
Uint8List _MemoryImage_bytes$(MemoryImage target) {
  return target.bytes;
}

double _MemoryImage_scale$(MemoryImage target) {
  return target.scale;
}

int _MemoryImage_hashCode$(MemoryImage target) {
  return target.hashCode;
}

Function _MemoryImage_obtainKey$(
  m.Scope scope,
  MemoryImage target,
) =>
    target.obtainKey;
Function _MemoryImage_load$(
  m.Scope scope,
  MemoryImage target,
) =>
    (
      MemoryImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        Uint8List decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.load(
        key,
        decodeProxy,
      );
    };
Function _MemoryImage_loadBuffer$(
  m.Scope scope,
  MemoryImage target,
) =>
    (
      MemoryImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target.loadBuffer(
        key,
        decodeProxy,
      );
    };
Function _MemoryImage_loadImage$(
  m.Scope scope,
  MemoryImage target,
) =>
    (
      MemoryImage key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            decode,
            [decode_buffer],
            {'getTargetSize': getTargetSize},
          );
      return target.loadImage(
        key,
        decodeProxy,
      );
    };
Function _MemoryImage_eq$$(
  m.Scope scope,
  MemoryImage target,
) =>
    (Object other) => target == other;
Function _MemoryImage_toString$(
  m.Scope scope,
  MemoryImage target,
) =>
    target.toString;
Function ExactAssetImage_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ExactAssetImage;
Function ExactAssetImage_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ExactAssetImage;
String _ExactAssetImage_assetName$(ExactAssetImage target) {
  return target.assetName;
}

double _ExactAssetImage_scale$(ExactAssetImage target) {
  return target.scale;
}

AssetBundle? _ExactAssetImage_bundle$(ExactAssetImage target) {
  return target.bundle;
}

String? _ExactAssetImage_package$(ExactAssetImage target) {
  return target.package;
}

String _ExactAssetImage_keyName$(ExactAssetImage target) {
  return target.keyName;
}

int _ExactAssetImage_hashCode$(ExactAssetImage target) {
  return target.hashCode;
}

Function _ExactAssetImage_obtainKey$(
  m.Scope scope,
  ExactAssetImage target,
) =>
    target.obtainKey;
Function _ExactAssetImage_eq$$(
  m.Scope scope,
  ExactAssetImage target,
) =>
    (Object other) => target == other;
Function _ExactAssetImage_toString$(
  m.Scope scope,
  ExactAssetImage target,
) =>
    target.toString;
Function NetworkImageLoadException_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as NetworkImageLoadException;
Function NetworkImageLoadException_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is NetworkImageLoadException;
int _NetworkImageLoadException_statusCode$(NetworkImageLoadException target) {
  return target.statusCode;
}

Uri _NetworkImageLoadException_uri$(NetworkImageLoadException target) {
  return target.uri;
}

Function _NetworkImageLoadException_toString$(
  m.Scope scope,
  NetworkImageLoadException target,
) =>
    target.toString;
ResizeImagePolicy _ResizeImagePolicy_exact$() {
  return ResizeImagePolicy.exact;
}

ResizeImagePolicy _ResizeImagePolicy_fit$() {
  return ResizeImagePolicy.fit;
}

List<ResizeImagePolicy> _ResizeImagePolicy_values$() {
  return ResizeImagePolicy.values;
}
