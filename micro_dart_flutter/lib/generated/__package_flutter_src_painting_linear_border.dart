// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/linear_border.dart';
import 'dart:ui' show lerpDouble;
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/painting/borders.dart';
import 'package:flutter/src/painting/edge_insets.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/linear_border.dart',
  {
    'LinearBorderEdge.': _LinearBorderEdge__$,
    'LinearBorderEdge.lerp': _LinearBorderEdge_lerp$,
    'LinearBorder.none': _LinearBorder_none$,
    'LinearBorder.': _LinearBorder__$,
    'LinearBorder.start': _LinearBorder_start_$,
    'LinearBorder.end': _LinearBorder_end_$,
    'LinearBorder.top': _LinearBorder_top_$,
    'LinearBorder.bottom': _LinearBorder_bottom_$,
  },
  {},
  {
    'LinearBorderEdge': m.ClassMirror(
      'LinearBorderEdge',
      {
        '#as': LinearBorderEdge_as$,
        '#is': LinearBorderEdge_is$,
        'size': _LinearBorderEdge_size$,
        'alignment': _LinearBorderEdge_alignment$,
        'hashCode': _LinearBorderEdge_hashCode$,
        '==': _LinearBorderEdge_eq$$,
        'toString': _LinearBorderEdge_toString$,
      },
      {},
    ),
    'LinearBorder': m.ClassMirror(
      'LinearBorder',
      {
        '#as': LinearBorder_as$,
        '#is': LinearBorder_is$,
        'start': _LinearBorder_start$,
        'end': _LinearBorder_end$,
        'top': _LinearBorder_top$,
        'bottom': _LinearBorder_bottom$,
        'dimensions': _LinearBorder_dimensions$,
        'hashCode': _LinearBorder_hashCode$,
        'scale': _LinearBorder_scale$,
        'lerpFrom': _LinearBorder_lerpFrom$,
        'lerpTo': _LinearBorder_lerpTo$,
        'copyWith': _LinearBorder_copyWith$,
        'getInnerPath': _LinearBorder_getInnerPath$,
        'getOuterPath': _LinearBorder_getOuterPath$,
        'paint': _LinearBorder_paint$,
        '==': _LinearBorder_eq$$,
        'toString': _LinearBorder_toString$,
      },
      {},
    ),
  },
);
Function LinearBorderEdge_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LinearBorderEdge;
Function LinearBorderEdge_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LinearBorderEdge;
Function _LinearBorderEdge_size$(
  m.Scope scope$,
  LinearBorderEdge target$,
) =>
    () {
      return target$.size;
    };
Function _LinearBorderEdge_alignment$(
  m.Scope scope$,
  LinearBorderEdge target$,
) =>
    () {
      return target$.alignment;
    };
Function _LinearBorderEdge_hashCode$(
  m.Scope scope$,
  LinearBorderEdge target$,
) =>
    () {
      return target$.hashCode;
    };
Function _LinearBorderEdge__$(m.Scope scope$) => ({
      double? size,
      double? alignment,
    }) {
      return LinearBorderEdge(
        alignment: alignment ?? 0.0,
        size: size ?? 1.0,
      );
    };
Function _LinearBorderEdge_lerp$(m.Scope scope$) => LinearBorderEdge.lerp;
Function _LinearBorderEdge_eq$$(
  m.Scope scope$,
  LinearBorderEdge target$,
) =>
    (Object other$) => target$ == other$;
Function _LinearBorderEdge_toString$(
  m.Scope scope$,
  LinearBorderEdge target$,
) =>
    target$.toString;
Function LinearBorder_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as LinearBorder;
Function LinearBorder_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is LinearBorder;
LinearBorder _LinearBorder_none$() {
  return LinearBorder.none;
}

Function _LinearBorder_start$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    () {
      return target$.start;
    };
Function _LinearBorder_end$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    () {
      return target$.end;
    };
Function _LinearBorder_top$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    () {
      return target$.top;
    };
Function _LinearBorder_bottom$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    () {
      return target$.bottom;
    };
Function _LinearBorder_dimensions$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    () {
      return target$.dimensions;
    };
Function _LinearBorder_hashCode$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    () {
      return target$.hashCode;
    };
Function _LinearBorder__$(m.Scope scope$) => ({
      BorderSide? side,
      LinearBorderEdge? start,
      LinearBorderEdge? end,
      LinearBorderEdge? top,
      LinearBorderEdge? bottom,
    }) {
      return LinearBorder(
        bottom: bottom,
        end: end,
        side: side ?? BorderSide.none,
        start: start,
        top: top,
      );
    };
Function _LinearBorder_start_$(m.Scope scope$) => LinearBorder.start;
Function _LinearBorder_end_$(m.Scope scope$) => LinearBorder.end;
Function _LinearBorder_top_$(m.Scope scope$) => LinearBorder.top;
Function _LinearBorder_bottom_$(m.Scope scope$) => LinearBorder.bottom;
Function _LinearBorder_scale$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.scale;
Function _LinearBorder_lerpFrom$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.lerpFrom;
Function _LinearBorder_lerpTo$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.lerpTo;
Function _LinearBorder_copyWith$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.copyWith;
Function _LinearBorder_getInnerPath$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.getInnerPath;
Function _LinearBorder_getOuterPath$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.getOuterPath;
Function _LinearBorder_paint$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.paint;
Function _LinearBorder_eq$$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    (Object other$) => target$ == other$;
Function _LinearBorder_toString$(
  m.Scope scope$,
  LinearBorder target$,
) =>
    target$.toString;
