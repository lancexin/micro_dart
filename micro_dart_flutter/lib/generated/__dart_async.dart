// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:async';
import 'dart:collection' show HashMap;

const libraryMirror = m.LibraryMirror(
  'dart:async',
  {
    'AsyncError.defaultStackTrace': _AsyncError_defaultStackTrace$,
    'Future.any': _Future_any$,
    'unawaited': _unawaited$,
    'scheduleMicrotask': _scheduleMicrotask$,
    'Stream.castFrom': _Stream_castFrom$,
    'StreamTransformer.castFrom': _StreamTransformer_castFrom$,
    'Zone.root': _Zone_root$,
    'Zone.current': _Zone_current$,
    'runZoned': _runZoned$,
    'runZonedGuarded': _runZonedGuarded$,
  },
  {},
  {
    'AsyncError': m.ClassMirror(
      'AsyncError',
      {
        'error': _AsyncError_error$,
        'stackTrace': _AsyncError_stackTrace$,
        'toString': _AsyncError_toString$,
      },
      {},
    ),
    'DeferredLoadException': m.ClassMirror(
      'DeferredLoadException',
      {'toString': _DeferredLoadException_toString$},
      {},
    ),
    'FutureOr': m.ClassMirror(
      'FutureOr',
      {},
      {},
    ),
    'Future': m.ClassMirror(
      'Future',
      {'asStream': _Future_asStream$},
      {},
    ),
    'TimeoutException': m.ClassMirror(
      'TimeoutException',
      {
        'message': _TimeoutException_message$,
        'duration': _TimeoutException_duration$,
        'toString': _TimeoutException_toString$,
      },
      {},
    ),
    'Completer': m.ClassMirror(
      'Completer',
      {
        'future': _Completer_future$,
        'isCompleted': _Completer_isCompleted$,
        'complete': _Completer_complete$,
        'completeError': _Completer_completeError$,
      },
      {},
    ),
    'ParallelWaitError': m.ClassMirror(
      'ParallelWaitError',
      {
        'values': _ParallelWaitError_values$,
        'errors': _ParallelWaitError_errors$,
        'toString': _ParallelWaitError_toString$,
      },
      {},
    ),
    'Stream': m.ClassMirror(
      'Stream',
      {
        'isBroadcast': _Stream_isBroadcast$,
        'length': _Stream_length$,
        'isEmpty': _Stream_isEmpty$,
        'first': _Stream_first$,
        'last': _Stream_last$,
        'single': _Stream_single$,
        'pipe': _Stream_pipe$,
        'transform': _Stream_transform$,
        'join': _Stream_join$,
        'contains': _Stream_contains$,
        'cast': _Stream_cast$,
        'toList': _Stream_toList$,
        'toSet': _Stream_toSet$,
        'drain': _Stream_drain$,
        'take': _Stream_take$,
        'skip': _Stream_skip$,
        'elementAt': _Stream_elementAt$,
      },
      {},
    ),
    'StreamSubscription': m.ClassMirror(
      'StreamSubscription',
      {
        'isPaused': _StreamSubscription_isPaused$,
        'cancel': _StreamSubscription_cancel$,
        'onError': _StreamSubscription_onError$,
        'pause': _StreamSubscription_pause$,
        'resume': _StreamSubscription_resume$,
        'asFuture': _StreamSubscription_asFuture$,
      },
      {},
    ),
    'EventSink': m.ClassMirror(
      'EventSink',
      {
        'add': _EventSink_add$,
        'addError': _EventSink_addError$,
        'close': _EventSink_close$,
      },
      {},
    ),
    'StreamView': m.ClassMirror(
      'StreamView',
      {'isBroadcast': _StreamView_isBroadcast$},
      {},
    ),
    'StreamConsumer': m.ClassMirror(
      'StreamConsumer',
      {
        'addStream': _StreamConsumer_addStream$,
        'close': _StreamConsumer_close$,
      },
      {},
    ),
    'StreamSink': m.ClassMirror(
      'StreamSink',
      {
        'done': _StreamSink_done$,
        'close': _StreamSink_close$,
      },
      {},
    ),
    'StreamTransformer': m.ClassMirror(
      'StreamTransformer',
      {
        'bind': _StreamTransformer_bind$,
        'cast': _StreamTransformer_cast$,
      },
      {},
    ),
    'StreamTransformerBase': m.ClassMirror(
      'StreamTransformerBase',
      {'cast': _StreamTransformerBase_cast$},
      {},
    ),
    'StreamIterator': m.ClassMirror(
      'StreamIterator',
      {
        'current': _StreamIterator_current$,
        'moveNext': _StreamIterator_moveNext$,
        'cancel': _StreamIterator_cancel$,
      },
      {},
    ),
    'MultiStreamController': m.ClassMirror(
      'MultiStreamController',
      {
        'addSync': _MultiStreamController_addSync$,
        'addErrorSync': _MultiStreamController_addErrorSync$,
        'closeSync': _MultiStreamController_closeSync$,
      },
      {},
    ),
    'StreamController': m.ClassMirror(
      'StreamController',
      {
        'onListen': _StreamController_onListen$,
        'onPause': _StreamController_onPause$,
        'onResume': _StreamController_onResume$,
        'onCancel': _StreamController_onCancel$,
        'stream': _StreamController_stream$,
        'sink': _StreamController_sink$,
        'isClosed': _StreamController_isClosed$,
        'isPaused': _StreamController_isPaused$,
        'hasListener': _StreamController_hasListener$,
        'done': _StreamController_done$,
        'add': _StreamController_add$,
        'addError': _StreamController_addError$,
        'close': _StreamController_close$,
        'addStream': _StreamController_addStream$,
      },
      {
        'onListen': _StreamController_onListen_set$,
        'onPause': _StreamController_onPause_set$,
        'onResume': _StreamController_onResume_set$,
        'onCancel': _StreamController_onCancel_set$,
      },
    ),
    'SynchronousStreamController': m.ClassMirror(
      'SynchronousStreamController',
      {
        'add': _SynchronousStreamController_add$,
        'addError': _SynchronousStreamController_addError$,
        'close': _SynchronousStreamController_close$,
      },
      {},
    ),
    'Timer': m.ClassMirror(
      'Timer',
      {
        'tick': _Timer_tick$,
        'isActive': _Timer_isActive$,
        'cancel': _Timer_cancel$,
      },
      {},
    ),
    'ZoneSpecification': m.ClassMirror(
      'ZoneSpecification',
      {
        'handleUncaughtError': _ZoneSpecification_handleUncaughtError$,
        'run': _ZoneSpecification_run$,
        'runUnary': _ZoneSpecification_runUnary$,
        'runBinary': _ZoneSpecification_runBinary$,
        'registerCallback': _ZoneSpecification_registerCallback$,
        'registerUnaryCallback': _ZoneSpecification_registerUnaryCallback$,
        'registerBinaryCallback': _ZoneSpecification_registerBinaryCallback$,
        'errorCallback': _ZoneSpecification_errorCallback$,
        'scheduleMicrotask': _ZoneSpecification_scheduleMicrotask$,
        'createTimer': _ZoneSpecification_createTimer$,
        'createPeriodicTimer': _ZoneSpecification_createPeriodicTimer$,
        'print': _ZoneSpecification_print$,
        'fork': _ZoneSpecification_fork$,
      },
      {},
    ),
    'ZoneDelegate': m.ClassMirror(
      'ZoneDelegate',
      {
        'handleUncaughtError': _ZoneDelegate_handleUncaughtError$,
        'errorCallback': _ZoneDelegate_errorCallback$,
        'print': _ZoneDelegate_print$,
        'fork': _ZoneDelegate_fork$,
      },
      {},
    ),
    'Zone': m.ClassMirror(
      'Zone',
      {
        'parent': _Zone_parent$,
        'errorZone': _Zone_errorZone$,
        'handleUncaughtError': _Zone_handleUncaughtError$,
        'inSameErrorZone': _Zone_inSameErrorZone$,
        'fork': _Zone_fork$,
        'errorCallback': _Zone_errorCallback$,
        'print': _Zone_print$,
      },
      {},
    ),
  },
);
Object _AsyncError_error$(AsyncError target) {
  return target.error;
}

StackTrace _AsyncError_stackTrace$(AsyncError target) {
  return target.stackTrace;
}

Function _AsyncError_defaultStackTrace$(m.Scope scope) =>
    AsyncError.defaultStackTrace;
Function _AsyncError_toString$(
  m.Scope scope,
  AsyncError target,
) =>
    target.toString;
Function _DeferredLoadException_toString$(
  m.Scope scope,
  DeferredLoadException target,
) =>
    target.toString;
Function _Future_any$<T>(m.Scope scope) => Future.any<T>;
Function _Future_asStream$<T>(
  m.Scope scope,
  Future<T> target,
) =>
    target.asStream;
String? _TimeoutException_message$(TimeoutException target) {
  return target.message;
}

Duration? _TimeoutException_duration$(TimeoutException target) {
  return target.duration;
}

Function _TimeoutException_toString$(
  m.Scope scope,
  TimeoutException target,
) =>
    target.toString;
Future<T> _Completer_future$<T>(Completer<T> target) {
  return target.future;
}

bool _Completer_isCompleted$<T>(Completer<T> target) {
  return target.isCompleted;
}

Function _Completer_complete$<T>(
  m.Scope scope,
  Completer<T> target,
) =>
    target.complete;
Function _Completer_completeError$<T>(
  m.Scope scope,
  Completer<T> target,
) =>
    target.completeError;
Function _unawaited$(m.Scope scope) => unawaited;
V _ParallelWaitError_values$<V, E>(ParallelWaitError<V, E> target) {
  return target.values;
}

E _ParallelWaitError_errors$<V, E>(ParallelWaitError<V, E> target) {
  return target.errors;
}

Function _ParallelWaitError_toString$<V, E>(
  m.Scope scope,
  ParallelWaitError<V, E> target,
) =>
    target.toString;
Function _scheduleMicrotask$(m.Scope scope) => (m.FunctionPointer callback) {
      void callbackProxy() => scope.engine.callFunctionPointer(
            scope,
            callback,
            [],
            {},
          );
      scheduleMicrotask(callbackProxy);
    };
bool _Stream_isBroadcast$<T>(Stream<T> target) {
  return target.isBroadcast;
}

Future<int> _Stream_length$<T>(Stream<T> target) {
  return target.length;
}

Future<bool> _Stream_isEmpty$<T>(Stream<T> target) {
  return target.isEmpty;
}

Future<T> _Stream_first$<T>(Stream<T> target) {
  return target.first;
}

Future<T> _Stream_last$<T>(Stream<T> target) {
  return target.last;
}

Future<T> _Stream_single$<T>(Stream<T> target) {
  return target.single;
}

Function _Stream_castFrom$<S, T>(m.Scope scope) => Stream.castFrom<S, T>;
Function _Stream_pipe$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.pipe;
Function _Stream_transform$<T, S>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.transform<S>;
Function _Stream_join$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.join;
Function _Stream_contains$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.contains;
Function _Stream_cast$<T, R>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.cast<R>;
Function _Stream_toList$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.toList;
Function _Stream_toSet$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.toSet;
Function _Stream_drain$<T, E>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.drain<E>;
Function _Stream_take$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.take;
Function _Stream_skip$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.skip;
Function _Stream_elementAt$<T>(
  m.Scope scope,
  Stream<T> target,
) =>
    target.elementAt;
bool _StreamSubscription_isPaused$<T>(StreamSubscription<T> target) {
  return target.isPaused;
}

Function _StreamSubscription_cancel$<T>(
  m.Scope scope,
  StreamSubscription<T> target,
) =>
    target.cancel;
Function _StreamSubscription_onError$<T>(
  m.Scope scope,
  StreamSubscription<T> target,
) =>
    target.onError;
Function _StreamSubscription_pause$<T>(
  m.Scope scope,
  StreamSubscription<T> target,
) =>
    target.pause;
Function _StreamSubscription_resume$<T>(
  m.Scope scope,
  StreamSubscription<T> target,
) =>
    target.resume;
Function _StreamSubscription_asFuture$<T, E>(
  m.Scope scope,
  StreamSubscription<T> target,
) =>
    target.asFuture<E>;
Function _EventSink_add$<T>(
  m.Scope scope,
  EventSink<T> target,
) =>
    target.add;
Function _EventSink_addError$<T>(
  m.Scope scope,
  EventSink<T> target,
) =>
    target.addError;
Function _EventSink_close$<T>(
  m.Scope scope,
  EventSink<T> target,
) =>
    target.close;
bool _StreamView_isBroadcast$<T>(StreamView<T> target) {
  return target.isBroadcast;
}

Function _StreamConsumer_addStream$<S>(
  m.Scope scope,
  StreamConsumer<S> target,
) =>
    target.addStream;
Function _StreamConsumer_close$<S>(
  m.Scope scope,
  StreamConsumer<S> target,
) =>
    target.close;
Future<dynamic> _StreamSink_done$<S>(StreamSink<S> target) {
  return target.done;
}

Function _StreamSink_close$<S>(
  m.Scope scope,
  StreamSink<S> target,
) =>
    target.close;
Function _StreamTransformer_castFrom$<SS, ST, TS, TT>(m.Scope scope) =>
    StreamTransformer.castFrom<SS, ST, TS, TT>;
Function _StreamTransformer_bind$<S, T>(
  m.Scope scope,
  StreamTransformer<S, T> target,
) =>
    target.bind;
Function _StreamTransformer_cast$<S, T, RS, RT>(
  m.Scope scope,
  StreamTransformer<S, T> target,
) =>
    target.cast<RS, RT>;
Function _StreamTransformerBase_cast$<S, T, RS, RT>(
  m.Scope scope,
  StreamTransformerBase<S, T> target,
) =>
    target.cast<RS, RT>;
T _StreamIterator_current$<T>(StreamIterator<T> target) {
  return target.current;
}

Function _StreamIterator_moveNext$<T>(
  m.Scope scope,
  StreamIterator<T> target,
) =>
    target.moveNext;
Function _StreamIterator_cancel$<T>(
  m.Scope scope,
  StreamIterator<T> target,
) =>
    target.cancel;
Function _MultiStreamController_addSync$<T>(
  m.Scope scope,
  MultiStreamController<T> target,
) =>
    target.addSync;
Function _MultiStreamController_addErrorSync$<T>(
  m.Scope scope,
  MultiStreamController<T> target,
) =>
    target.addErrorSync;
Function _MultiStreamController_closeSync$<T>(
  m.Scope scope,
  MultiStreamController<T> target,
) =>
    target.closeSync;
void Function()? _StreamController_onListen$<T>(StreamController<T> target) {
  return target.onListen;
}

Function _StreamController_onListen_set$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    (m.FunctionPointer? _onListen) {
      void _onListenProxy() => scope.engine.callFunctionPointer(
            scope,
            _onListen!,
            [],
            {},
          );
      target.onListen = (_onListen == null ? null : _onListenProxy);
    };
void Function()? _StreamController_onPause$<T>(StreamController<T> target) {
  return target.onPause;
}

Function _StreamController_onPause_set$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    (m.FunctionPointer? _onPause) {
      void _onPauseProxy() => scope.engine.callFunctionPointer(
            scope,
            _onPause!,
            [],
            {},
          );
      target.onPause = (_onPause == null ? null : _onPauseProxy);
    };
void Function()? _StreamController_onResume$<T>(StreamController<T> target) {
  return target.onResume;
}

Function _StreamController_onResume_set$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    (m.FunctionPointer? _onResume) {
      void _onResumeProxy() => scope.engine.callFunctionPointer(
            scope,
            _onResume!,
            [],
            {},
          );
      target.onResume = (_onResume == null ? null : _onResumeProxy);
    };
FutureOr<void> Function()? _StreamController_onCancel$<T>(
    StreamController<T> target) {
  return target.onCancel;
}

Function _StreamController_onCancel_set$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    (m.FunctionPointer? _onCancel) {
      FutureOr<void> _onCancelProxy() async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            _onCancel!,
            [],
            {},
          );
      target.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
Stream<T> _StreamController_stream$<T>(StreamController<T> target) {
  return target.stream;
}

StreamSink<T> _StreamController_sink$<T>(StreamController<T> target) {
  return target.sink;
}

bool _StreamController_isClosed$<T>(StreamController<T> target) {
  return target.isClosed;
}

bool _StreamController_isPaused$<T>(StreamController<T> target) {
  return target.isPaused;
}

bool _StreamController_hasListener$<T>(StreamController<T> target) {
  return target.hasListener;
}

Future<dynamic> _StreamController_done$<T>(StreamController<T> target) {
  return target.done;
}

Function _StreamController_add$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    target.add;
Function _StreamController_addError$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    target.addError;
Function _StreamController_close$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    target.close;
Function _StreamController_addStream$<T>(
  m.Scope scope,
  StreamController<T> target,
) =>
    target.addStream;
Function _SynchronousStreamController_add$<T>(
  m.Scope scope,
  SynchronousStreamController<T> target,
) =>
    target.add;
Function _SynchronousStreamController_addError$<T>(
  m.Scope scope,
  SynchronousStreamController<T> target,
) =>
    target.addError;
Function _SynchronousStreamController_close$<T>(
  m.Scope scope,
  SynchronousStreamController<T> target,
) =>
    target.close;
int _Timer_tick$(Timer target) {
  return target.tick;
}

bool _Timer_isActive$(Timer target) {
  return target.isActive;
}

Function _Timer_cancel$(
  m.Scope scope,
  Timer target,
) =>
    target.cancel;
void Function(Zone, ZoneDelegate, Zone, Object, StackTrace)?
    _ZoneSpecification_handleUncaughtError$(ZoneSpecification target) {
  return target.handleUncaughtError;
}

R Function<R>(Zone, ZoneDelegate, Zone, R Function())? _ZoneSpecification_run$(
    ZoneSpecification target) {
  return target.run;
}

R Function<R, T>(Zone, ZoneDelegate, Zone, R Function(T), T)?
    _ZoneSpecification_runUnary$(ZoneSpecification target) {
  return target.runUnary;
}

R Function<R, T1, T2>(Zone, ZoneDelegate, Zone, R Function(T1, T2), T1, T2)?
    _ZoneSpecification_runBinary$(ZoneSpecification target) {
  return target.runBinary;
}

R Function() Function<R>(Zone, ZoneDelegate, Zone, R Function())?
    _ZoneSpecification_registerCallback$(ZoneSpecification target) {
  return target.registerCallback;
}

R Function(T) Function<R, T>(Zone, ZoneDelegate, Zone, R Function(T))?
    _ZoneSpecification_registerUnaryCallback$(ZoneSpecification target) {
  return target.registerUnaryCallback;
}

R Function(T1, T2) Function<R, T1, T2>(
        Zone, ZoneDelegate, Zone, R Function(T1, T2))?
    _ZoneSpecification_registerBinaryCallback$(ZoneSpecification target) {
  return target.registerBinaryCallback;
}

AsyncError? Function(Zone, ZoneDelegate, Zone, Object, StackTrace?)?
    _ZoneSpecification_errorCallback$(ZoneSpecification target) {
  return target.errorCallback;
}

void Function(Zone, ZoneDelegate, Zone, void Function())?
    _ZoneSpecification_scheduleMicrotask$(ZoneSpecification target) {
  return target.scheduleMicrotask;
}

Timer Function(Zone, ZoneDelegate, Zone, Duration, void Function())?
    _ZoneSpecification_createTimer$(ZoneSpecification target) {
  return target.createTimer;
}

Timer Function(Zone, ZoneDelegate, Zone, Duration, void Function(Timer))?
    _ZoneSpecification_createPeriodicTimer$(ZoneSpecification target) {
  return target.createPeriodicTimer;
}

void Function(Zone, ZoneDelegate, Zone, String)? _ZoneSpecification_print$(
    ZoneSpecification target) {
  return target.print;
}

Zone Function(
        Zone, ZoneDelegate, Zone, ZoneSpecification?, Map<Object?, Object?>?)?
    _ZoneSpecification_fork$(ZoneSpecification target) {
  return target.fork;
}

Function _ZoneDelegate_handleUncaughtError$(
  m.Scope scope,
  ZoneDelegate target,
) =>
    target.handleUncaughtError;
Function _ZoneDelegate_errorCallback$(
  m.Scope scope,
  ZoneDelegate target,
) =>
    target.errorCallback;
Function _ZoneDelegate_print$(
  m.Scope scope,
  ZoneDelegate target,
) =>
    target.print;
Function _ZoneDelegate_fork$(
  m.Scope scope,
  ZoneDelegate target,
) =>
    target.fork;
Zone _Zone_root$() {
  return Zone.root;
}

Zone _Zone_current$() {
  return Zone.current;
}

Zone? _Zone_parent$(Zone target) {
  return target.parent;
}

Zone _Zone_errorZone$(Zone target) {
  return target.errorZone;
}

Function _Zone_handleUncaughtError$(
  m.Scope scope,
  Zone target,
) =>
    target.handleUncaughtError;
Function _Zone_inSameErrorZone$(
  m.Scope scope,
  Zone target,
) =>
    target.inSameErrorZone;
Function _Zone_fork$(
  m.Scope scope,
  Zone target,
) =>
    target.fork;
Function _Zone_errorCallback$(
  m.Scope scope,
  Zone target,
) =>
    target.errorCallback;
Function _Zone_print$(
  m.Scope scope,
  Zone target,
) =>
    target.print;
Function _runZoned$(m.Scope scope) => <R>(
      m.FunctionPointer body, {
      Map<Object?, Object?>? zoneValues,
      ZoneSpecification? zoneSpecification,
      Function? onError,
    }) {
      R bodyProxy() => scope.engine.callFunctionPointer(
            scope,
            body,
            [],
            {},
          );
      return runZoned<R>(
        bodyProxy,
        onError: onError,
        zoneSpecification: zoneSpecification,
        zoneValues: zoneValues,
      );
    };
Function _runZonedGuarded$(m.Scope scope) => <R>(
      m.FunctionPointer body,
      m.FunctionPointer onError, {
      Map<Object?, Object?>? zoneValues,
      ZoneSpecification? zoneSpecification,
    }) {
      R bodyProxy() => scope.engine.callFunctionPointer(
            scope,
            body,
            [],
            {},
          );
      void onErrorProxy(
        Object onError_error,
        StackTrace onError_stack,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            onError,
            [
              onError_error,
              onError_stack,
            ],
            {},
          );
      return runZonedGuarded<R>(
        bodyProxy,
        onErrorProxy,
        zoneSpecification: zoneSpecification,
        zoneValues: zoneValues,
      );
    };
