// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/segmented_button.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/button_style.dart';
import 'package:flutter/src/material/color_scheme.dart';
import 'package:flutter/src/material/colors.dart';
import 'package:flutter/src/material/icons.dart';
import 'package:flutter/src/material/material.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/segmented_button_theme.dart';
import 'package:flutter/src/material/text_button.dart';
import 'package:flutter/src/material/text_button_theme.dart';
import 'package:flutter/src/material/theme.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/segmented_button.dart',
  {
    'ButtonSegment.': _ButtonSegment__$,
    'SegmentedButton.': _SegmentedButton__$,
  },
  {},
  {
    'ButtonSegment': m.ClassMirror(
      'ButtonSegment',
      {
        '#as': ButtonSegment_as$,
        '#is': ButtonSegment_is$,
        'value': _ButtonSegment_value$,
        'icon': _ButtonSegment_icon$,
        'label': _ButtonSegment_label$,
        'enabled': _ButtonSegment_enabled$,
      },
      {},
    ),
    'SegmentedButton': m.ClassMirror(
      'SegmentedButton',
      {
        '#as': SegmentedButton_as$,
        '#is': SegmentedButton_is$,
        'segments': _SegmentedButton_segments$,
        'selected': _SegmentedButton_selected$,
        'onSelectionChanged': _SegmentedButton_onSelectionChanged$,
        'multiSelectionEnabled': _SegmentedButton_multiSelectionEnabled$,
        'emptySelectionAllowed': _SegmentedButton_emptySelectionAllowed$,
        'style': _SegmentedButton_style$,
        'showSelectedIcon': _SegmentedButton_showSelectedIcon$,
        'selectedIcon': _SegmentedButton_selectedIcon$,
        'build': _SegmentedButton_build$,
      },
      {},
    ),
  },
);
Function ButtonSegment_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ButtonSegment<T>;
Function ButtonSegment_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ButtonSegment<T>;
Function _ButtonSegment_value$<T>(
  m.Scope scope$,
  ButtonSegment<T> target$,
) =>
    () {
      return target$.value;
    };
Function _ButtonSegment_icon$<T>(
  m.Scope scope$,
  ButtonSegment<T> target$,
) =>
    () {
      return target$.icon;
    };
Function _ButtonSegment_label$<T>(
  m.Scope scope$,
  ButtonSegment<T> target$,
) =>
    () {
      return target$.label;
    };
Function _ButtonSegment_enabled$<T>(
  m.Scope scope$,
  ButtonSegment<T> target$,
) =>
    () {
      return target$.enabled;
    };
Function _ButtonSegment__$(m.Scope scope$) => ({
      required dynamic value,
      Widget? icon,
      Widget? label,
      bool? enabled,
    }) {
      return ButtonSegment(
        enabled: enabled ?? true,
        icon: icon,
        label: label,
        value: value,
      );
    };
Function SegmentedButton_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SegmentedButton<T>;
Function SegmentedButton_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SegmentedButton<T>;
Function _SegmentedButton_segments$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.segments;
    };
Function _SegmentedButton_selected$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.selected;
    };
Function _SegmentedButton_onSelectionChanged$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.onSelectionChanged;
    };
Function _SegmentedButton_multiSelectionEnabled$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.multiSelectionEnabled;
    };
Function _SegmentedButton_emptySelectionAllowed$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.emptySelectionAllowed;
    };
Function _SegmentedButton_style$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.style;
    };
Function _SegmentedButton_showSelectedIcon$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.showSelectedIcon;
    };
Function _SegmentedButton_selectedIcon$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    () {
      return target$.selectedIcon;
    };
Function _SegmentedButton__$(m.Scope scope$) => ({
      Key? key,
      required List segments,
      required Set selected,
      m.FunctionPointer? onSelectionChanged,
      bool? multiSelectionEnabled,
      bool? emptySelectionAllowed,
      ButtonStyle? style,
      bool? showSelectedIcon,
      Widget? selectedIcon,
    }) {
      void onSelectionChangedProxy(Set onSelectionChanged_$p0$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onSelectionChanged!,
            [onSelectionChanged_$p0$],
            {},
          );
      return SegmentedButton(
        emptySelectionAllowed: emptySelectionAllowed ?? false,
        key: key,
        multiSelectionEnabled: multiSelectionEnabled ?? false,
        onSelectionChanged:
            onSelectionChanged == null ? null : onSelectionChangedProxy,
        segments: List.from(segments),
        selected: Set.from(selected),
        selectedIcon: selectedIcon,
        showSelectedIcon: showSelectedIcon ?? true,
        style: style,
      );
    };
Function _SegmentedButton_build$<T>(
  m.Scope scope$,
  SegmentedButton<T> target$,
) =>
    target$.build;
