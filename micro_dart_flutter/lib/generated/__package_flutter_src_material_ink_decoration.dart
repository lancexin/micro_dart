// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/ink_decoration.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/debug.dart';
import 'package:flutter/src/material/material.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/ink_decoration.dart',
  {
    'Ink.': _Ink__$,
    'Ink.image': _Ink_image_$,
    'InkDecoration.': _InkDecoration__$,
  },
  {},
  {
    'Ink': m.ClassMirror(
      'Ink',
      {
        '#as': Ink_as$,
        '#is': Ink_is$,
        'child': _Ink_child$,
        'padding': _Ink_padding$,
        'decoration': _Ink_decoration$,
        'width': _Ink_width$,
        'height': _Ink_height$,
        'debugFillProperties': _Ink_debugFillProperties$,
        'createState': _Ink_createState$,
      },
      {},
    ),
    'InkDecoration': m.ClassMirror(
      'InkDecoration',
      {
        '#as': InkDecoration_as$,
        '#is': InkDecoration_is$,
        'decoration': _InkDecoration_decoration$,
        'isVisible': _InkDecoration_isVisible$,
        'configuration': _InkDecoration_configuration$,
        'dispose': _InkDecoration_dispose$,
        'paintFeature': _InkDecoration_paintFeature$,
      },
      {
        'decoration': _InkDecoration_decoration_set$,
        'isVisible': _InkDecoration_isVisible_set$,
        'configuration': _InkDecoration_configuration_set$,
      },
    ),
  },
);
Function Ink_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Ink;
Function Ink_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Ink;
Function _Ink_child$(
  m.Scope scope$,
  Ink target$,
) =>
    () {
      return target$.child;
    };
Function _Ink_padding$(
  m.Scope scope$,
  Ink target$,
) =>
    () {
      return target$.padding;
    };
Function _Ink_decoration$(
  m.Scope scope$,
  Ink target$,
) =>
    () {
      return target$.decoration;
    };
Function _Ink_width$(
  m.Scope scope$,
  Ink target$,
) =>
    () {
      return target$.width;
    };
Function _Ink_height$(
  m.Scope scope$,
  Ink target$,
) =>
    () {
      return target$.height;
    };
Function _Ink__$(m.Scope scope$) => ({
      Key? key,
      EdgeInsetsGeometry? padding,
      Color? color,
      Decoration? decoration,
      double? width,
      double? height,
      Widget? child,
    }) {
      return Ink(
        child: child,
        color: color,
        decoration: decoration,
        height: height,
        key: key,
        padding: padding,
        width: width,
      );
    };
Function _Ink_image_$(m.Scope scope$) => ({
      Key? key,
      EdgeInsetsGeometry? padding,
      required ImageProvider<Object> image,
      m.FunctionPointer? onImageError,
      ColorFilter? colorFilter,
      BoxFit? fit,
      AlignmentGeometry? alignment,
      Rect? centerSlice,
      ImageRepeat? repeat,
      bool? matchTextDirection,
      double? width,
      double? height,
      Widget? child,
    }) {
      void onImageErrorProxy(
        Object onImageError_exception$,
        StackTrace? onImageError_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onImageError!,
            [
              onImageError_exception$,
              onImageError_stackTrace$,
            ],
            {},
          );
      return Ink.image(
        alignment: alignment ?? Alignment.center,
        centerSlice: centerSlice,
        child: child,
        colorFilter: colorFilter,
        fit: fit,
        height: height,
        image: image,
        key: key,
        matchTextDirection: matchTextDirection ?? false,
        onImageError: onImageError == null ? null : onImageErrorProxy,
        padding: padding,
        repeat: repeat ?? ImageRepeat.noRepeat,
        width: width,
      );
    };
Function _Ink_debugFillProperties$(
  m.Scope scope$,
  Ink target$,
) =>
    target$.debugFillProperties;
Function _Ink_createState$(
  m.Scope scope$,
  Ink target$,
) =>
    target$.createState;
Function InkDecoration_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as InkDecoration;
Function InkDecoration_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is InkDecoration;
Function _InkDecoration_decoration$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    () {
      return target$.decoration;
    };
void _InkDecoration_decoration_set$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    (dynamic other$) {
      target$.decoration = other$;
    };
Function _InkDecoration_isVisible$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    () {
      return target$.isVisible;
    };
void _InkDecoration_isVisible_set$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    (dynamic other$) {
      target$.isVisible = other$;
    };
Function _InkDecoration_configuration$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    () {
      return target$.configuration;
    };
void _InkDecoration_configuration_set$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    (dynamic other$) {
      target$.configuration = other$;
    };
Function _InkDecoration__$(m.Scope scope$) => ({
      required Decoration? decoration,
      bool? isVisible,
      required ImageConfiguration configuration,
      required MaterialInkController controller,
      required RenderBox referenceBox,
      m.FunctionPointer? onRemoved,
    }) {
      void onRemovedProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onRemoved!,
            [],
            {},
          );
      return InkDecoration(
        configuration: configuration,
        controller: controller,
        decoration: decoration,
        isVisible: isVisible ?? true,
        onRemoved: onRemoved == null ? null : onRemovedProxy,
        referenceBox: referenceBox,
      );
    };
Function _InkDecoration_dispose$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    target$.dispose;
Function _InkDecoration_paintFeature$(
  m.Scope scope$,
  InkDecoration target$,
) =>
    target$.paintFeature;
