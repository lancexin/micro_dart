// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/basic_types.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/border_radius.dart',
  {
    'BorderRadiusGeometry.lerp': _BorderRadiusGeometry_lerp$,
    'BorderRadius.zero': _BorderRadius_zero$,
    'BorderRadius.lerp': _BorderRadius_lerp$,
    'BorderRadiusDirectional.zero': _BorderRadiusDirectional_zero$,
    'BorderRadiusDirectional.lerp': _BorderRadiusDirectional_lerp$,
  },
  {},
  {
    'BorderRadiusGeometry': m.ClassMirror(
      'BorderRadiusGeometry',
      {
        '#as': BorderRadiusGeometry_as$,
        '#is': BorderRadiusGeometry_is$,
        'hashCode': _BorderRadiusGeometry_hashCode$,
        'subtract': _BorderRadiusGeometry_subtract$,
        'add': _BorderRadiusGeometry_add$,
        'unary-': _BorderRadiusGeometry_unary_minus$$,
        '*': _BorderRadiusGeometry_times$$,
        '/': _BorderRadiusGeometry_over$$,
        '~/': _BorderRadiusGeometry_division$$,
        '%': _BorderRadiusGeometry_surplus$$,
        'resolve': _BorderRadiusGeometry_resolve$,
        'toString': _BorderRadiusGeometry_toString$,
        '==': _BorderRadiusGeometry_eq$$,
      },
      {},
    ),
    'BorderRadius': m.ClassMirror(
      'BorderRadius',
      {
        '#as': BorderRadius_as$,
        '#is': BorderRadius_is$,
        'topLeft': _BorderRadius_topLeft$,
        'topRight': _BorderRadius_topRight$,
        'bottomLeft': _BorderRadius_bottomLeft$,
        'bottomRight': _BorderRadius_bottomRight$,
        'copyWith': _BorderRadius_copyWith$,
        'toRRect': _BorderRadius_toRRect$,
        'subtract': _BorderRadius_subtract$,
        'add': _BorderRadius_add$,
        '-': _BorderRadius_minus$$,
        '+': _BorderRadius_plus$$,
        'unary-': _BorderRadius_unary_minus$$,
        '*': _BorderRadius_times$$,
        '/': _BorderRadius_over$$,
        '~/': _BorderRadius_division$$,
        '%': _BorderRadius_surplus$$,
        'resolve': _BorderRadius_resolve$,
      },
      {},
    ),
    'BorderRadiusDirectional': m.ClassMirror(
      'BorderRadiusDirectional',
      {
        '#as': BorderRadiusDirectional_as$,
        '#is': BorderRadiusDirectional_is$,
        'topStart': _BorderRadiusDirectional_topStart$,
        'topEnd': _BorderRadiusDirectional_topEnd$,
        'bottomStart': _BorderRadiusDirectional_bottomStart$,
        'bottomEnd': _BorderRadiusDirectional_bottomEnd$,
        'subtract': _BorderRadiusDirectional_subtract$,
        'add': _BorderRadiusDirectional_add$,
        '-': _BorderRadiusDirectional_minus$$,
        '+': _BorderRadiusDirectional_plus$$,
        'unary-': _BorderRadiusDirectional_unary_minus$$,
        '*': _BorderRadiusDirectional_times$$,
        '/': _BorderRadiusDirectional_over$$,
        '~/': _BorderRadiusDirectional_division$$,
        '%': _BorderRadiusDirectional_surplus$$,
        'resolve': _BorderRadiusDirectional_resolve$,
      },
      {},
    ),
  },
);
Function BorderRadiusGeometry_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BorderRadiusGeometry;
Function BorderRadiusGeometry_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BorderRadiusGeometry;
int _BorderRadiusGeometry_hashCode$(BorderRadiusGeometry target) {
  return target.hashCode;
}

Function _BorderRadiusGeometry_subtract$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    target.subtract;
Function _BorderRadiusGeometry_add$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    target.add;
Function _BorderRadiusGeometry_unary_minus$$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    () => -target;
Function _BorderRadiusGeometry_times$$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    (double other) => target * other;
Function _BorderRadiusGeometry_over$$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    (double other) => target / other;
Function _BorderRadiusGeometry_division$$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    (double other) => target ~/ other;
Function _BorderRadiusGeometry_surplus$$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    (double other) => target % other;
Function _BorderRadiusGeometry_lerp$(m.Scope scope) =>
    BorderRadiusGeometry.lerp;
Function _BorderRadiusGeometry_resolve$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    target.resolve;
Function _BorderRadiusGeometry_toString$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    target.toString;
Function _BorderRadiusGeometry_eq$$(
  m.Scope scope,
  BorderRadiusGeometry target,
) =>
    (Object other) => target == other;
Function BorderRadius_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BorderRadius;
Function BorderRadius_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BorderRadius;
BorderRadius _BorderRadius_zero$() {
  return BorderRadius.zero;
}

Radius _BorderRadius_topLeft$(BorderRadius target) {
  return target.topLeft;
}

Radius _BorderRadius_topRight$(BorderRadius target) {
  return target.topRight;
}

Radius _BorderRadius_bottomLeft$(BorderRadius target) {
  return target.bottomLeft;
}

Radius _BorderRadius_bottomRight$(BorderRadius target) {
  return target.bottomRight;
}

Function _BorderRadius_copyWith$(
  m.Scope scope,
  BorderRadius target,
) =>
    target.copyWith;
Function _BorderRadius_toRRect$(
  m.Scope scope,
  BorderRadius target,
) =>
    target.toRRect;
Function _BorderRadius_subtract$(
  m.Scope scope,
  BorderRadius target,
) =>
    target.subtract;
Function _BorderRadius_add$(
  m.Scope scope,
  BorderRadius target,
) =>
    target.add;
Function _BorderRadius_minus$$(
  m.Scope scope,
  BorderRadius target,
) =>
    (BorderRadius other) => target - other;
Function _BorderRadius_plus$$(
  m.Scope scope,
  BorderRadius target,
) =>
    (BorderRadius other) => target + other;
Function _BorderRadius_unary_minus$$(
  m.Scope scope,
  BorderRadius target,
) =>
    () => -target;
Function _BorderRadius_times$$(
  m.Scope scope,
  BorderRadius target,
) =>
    (double other) => target * other;
Function _BorderRadius_over$$(
  m.Scope scope,
  BorderRadius target,
) =>
    (double other) => target / other;
Function _BorderRadius_division$$(
  m.Scope scope,
  BorderRadius target,
) =>
    (double other) => target ~/ other;
Function _BorderRadius_surplus$$(
  m.Scope scope,
  BorderRadius target,
) =>
    (double other) => target % other;
Function _BorderRadius_lerp$(m.Scope scope) => BorderRadius.lerp;
Function _BorderRadius_resolve$(
  m.Scope scope,
  BorderRadius target,
) =>
    target.resolve;
Function BorderRadiusDirectional_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as BorderRadiusDirectional;
Function BorderRadiusDirectional_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is BorderRadiusDirectional;
BorderRadiusDirectional _BorderRadiusDirectional_zero$() {
  return BorderRadiusDirectional.zero;
}

Radius _BorderRadiusDirectional_topStart$(BorderRadiusDirectional target) {
  return target.topStart;
}

Radius _BorderRadiusDirectional_topEnd$(BorderRadiusDirectional target) {
  return target.topEnd;
}

Radius _BorderRadiusDirectional_bottomStart$(BorderRadiusDirectional target) {
  return target.bottomStart;
}

Radius _BorderRadiusDirectional_bottomEnd$(BorderRadiusDirectional target) {
  return target.bottomEnd;
}

Function _BorderRadiusDirectional_subtract$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    target.subtract;
Function _BorderRadiusDirectional_add$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    target.add;
Function _BorderRadiusDirectional_minus$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    (BorderRadiusDirectional other) => target - other;
Function _BorderRadiusDirectional_plus$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    (BorderRadiusDirectional other) => target + other;
Function _BorderRadiusDirectional_unary_minus$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    () => -target;
Function _BorderRadiusDirectional_times$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    (double other) => target * other;
Function _BorderRadiusDirectional_over$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    (double other) => target / other;
Function _BorderRadiusDirectional_division$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    (double other) => target ~/ other;
Function _BorderRadiusDirectional_surplus$$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    (double other) => target % other;
Function _BorderRadiusDirectional_lerp$(m.Scope scope) =>
    BorderRadiusDirectional.lerp;
Function _BorderRadiusDirectional_resolve$(
  m.Scope scope,
  BorderRadiusDirectional target,
) =>
    target.resolve;
