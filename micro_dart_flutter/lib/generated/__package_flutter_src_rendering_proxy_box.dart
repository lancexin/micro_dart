// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/rendering/proxy_box.dart';
import 'dart:ui' show Color, Gradient, Image, ImageFilter;
import 'package:flutter/animation.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/rendering/layout_helper.dart';
import 'package:flutter/src/rendering/object.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/rendering/proxy_box.dart',
  {
    'RenderProxyBox.': _RenderProxyBox__$,
    'RenderConstrainedBox.': _RenderConstrainedBox__$,
    'RenderLimitedBox.': _RenderLimitedBox__$,
    'RenderAspectRatio.': _RenderAspectRatio__$,
    'RenderIntrinsicWidth.': _RenderIntrinsicWidth__$,
    'RenderIntrinsicHeight.': _RenderIntrinsicHeight__$,
    'RenderOpacity.': _RenderOpacity__$,
    'RenderOpacity.visitChildrenForSemantics':
        _RenderOpacity_visitChildrenForSemantics$,
    'RenderAnimatedOpacity.': _RenderAnimatedOpacity__$,
    'RenderShaderMask.': _RenderShaderMask__$,
    'RenderBackdropFilter.': _RenderBackdropFilter__$,
    'CustomClipper.addListener': _CustomClipper_addListener$,
    'CustomClipper.removeListener': _CustomClipper_removeListener$,
    'ShapeBorderClipper.': _ShapeBorderClipper__$,
    'RenderClipRect.': _RenderClipRect__$,
    'RenderClipRRect.': _RenderClipRRect__$,
    'RenderClipOval.': _RenderClipOval__$,
    'RenderClipPath.': _RenderClipPath__$,
    'RenderPhysicalModel.': _RenderPhysicalModel__$,
    'RenderPhysicalShape.': _RenderPhysicalShape__$,
    'RenderDecoratedBox.': _RenderDecoratedBox__$,
    'RenderTransform.': _RenderTransform__$,
    'RenderFittedBox.': _RenderFittedBox__$,
    'RenderFractionalTranslation.': _RenderFractionalTranslation__$,
    'RenderPointerListener.': _RenderPointerListener__$,
    'RenderMouseRegion.': _RenderMouseRegion__$,
    'RenderRepaintBoundary.': _RenderRepaintBoundary__$,
    'RenderIgnorePointer.': _RenderIgnorePointer__$,
    'RenderIgnorePointer.visitChildrenForSemantics':
        _RenderIgnorePointer_visitChildrenForSemantics$,
    'RenderOffstage.': _RenderOffstage__$,
    'RenderOffstage.visitChildrenForSemantics':
        _RenderOffstage_visitChildrenForSemantics$,
    'RenderAbsorbPointer.': _RenderAbsorbPointer__$,
    'RenderAbsorbPointer.visitChildrenForSemantics':
        _RenderAbsorbPointer_visitChildrenForSemantics$,
    'RenderMetaData.': _RenderMetaData__$,
    'RenderSemanticsGestureHandler.': _RenderSemanticsGestureHandler__$,
    'RenderSemanticsAnnotations.': _RenderSemanticsAnnotations__$,
    'RenderSemanticsAnnotations.visitChildrenForSemantics':
        _RenderSemanticsAnnotations_visitChildrenForSemantics$,
    'RenderBlockSemantics.': _RenderBlockSemantics__$,
    'RenderMergeSemantics.': _RenderMergeSemantics__$,
    'RenderExcludeSemantics.': _RenderExcludeSemantics__$,
    'RenderExcludeSemantics.visitChildrenForSemantics':
        _RenderExcludeSemantics_visitChildrenForSemantics$,
    'RenderIndexedSemantics.': _RenderIndexedSemantics__$,
    'RenderLeaderLayer.': _RenderLeaderLayer__$,
    'RenderFollowerLayer.': _RenderFollowerLayer__$,
    'RenderAnnotatedRegion.': _RenderAnnotatedRegion__$,
    'HitTestBehavior.deferToChild': _HitTestBehavior_deferToChild$,
    'HitTestBehavior.opaque': _HitTestBehavior_opaque$,
    'HitTestBehavior.translucent': _HitTestBehavior_translucent$,
    'HitTestBehavior.values': _HitTestBehavior_values$,
    'DecorationPosition.background': _DecorationPosition_background$,
    'DecorationPosition.foreground': _DecorationPosition_foreground$,
    'DecorationPosition.values': _DecorationPosition_values$,
  },
  {},
  {
    'RenderProxyBox': m.ClassMirror(
      'RenderProxyBox',
      {
        '#as': RenderProxyBox_as$,
        '#is': RenderProxyBox_is$,
      },
      {},
    ),
    'RenderProxyBoxWithHitTestBehavior': m.ClassMirror(
      'RenderProxyBoxWithHitTestBehavior',
      {
        '#as': RenderProxyBoxWithHitTestBehavior_as$,
        '#is': RenderProxyBoxWithHitTestBehavior_is$,
        'behavior': _RenderProxyBoxWithHitTestBehavior_behavior$,
        'hitTest': _RenderProxyBoxWithHitTestBehavior_hitTest$,
        'hitTestSelf': _RenderProxyBoxWithHitTestBehavior_hitTestSelf$,
        'debugFillProperties':
            _RenderProxyBoxWithHitTestBehavior_debugFillProperties$,
      },
      {'behavior': _RenderProxyBoxWithHitTestBehavior_behavior_set$},
    ),
    'RenderConstrainedBox': m.ClassMirror(
      'RenderConstrainedBox',
      {
        '#as': RenderConstrainedBox_as$,
        '#is': RenderConstrainedBox_is$,
        'additionalConstraints': _RenderConstrainedBox_additionalConstraints$,
        'computeMinIntrinsicWidth':
            _RenderConstrainedBox_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth':
            _RenderConstrainedBox_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight':
            _RenderConstrainedBox_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight':
            _RenderConstrainedBox_computeMaxIntrinsicHeight$,
        'performLayout': _RenderConstrainedBox_performLayout$,
        'computeDryLayout': _RenderConstrainedBox_computeDryLayout$,
        'debugPaintSize': _RenderConstrainedBox_debugPaintSize$,
        'debugFillProperties': _RenderConstrainedBox_debugFillProperties$,
      },
      {
        'additionalConstraints':
            _RenderConstrainedBox_additionalConstraints_set$
      },
    ),
    'RenderLimitedBox': m.ClassMirror(
      'RenderLimitedBox',
      {
        '#as': RenderLimitedBox_as$,
        '#is': RenderLimitedBox_is$,
        'maxWidth': _RenderLimitedBox_maxWidth$,
        'maxHeight': _RenderLimitedBox_maxHeight$,
        'computeDryLayout': _RenderLimitedBox_computeDryLayout$,
        'performLayout': _RenderLimitedBox_performLayout$,
        'debugFillProperties': _RenderLimitedBox_debugFillProperties$,
      },
      {
        'maxWidth': _RenderLimitedBox_maxWidth_set$,
        'maxHeight': _RenderLimitedBox_maxHeight_set$,
      },
    ),
    'RenderAspectRatio': m.ClassMirror(
      'RenderAspectRatio',
      {
        '#as': RenderAspectRatio_as$,
        '#is': RenderAspectRatio_is$,
        'aspectRatio': _RenderAspectRatio_aspectRatio$,
        'computeMinIntrinsicWidth':
            _RenderAspectRatio_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth':
            _RenderAspectRatio_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight':
            _RenderAspectRatio_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight':
            _RenderAspectRatio_computeMaxIntrinsicHeight$,
        'computeDryLayout': _RenderAspectRatio_computeDryLayout$,
        'performLayout': _RenderAspectRatio_performLayout$,
        'debugFillProperties': _RenderAspectRatio_debugFillProperties$,
      },
      {'aspectRatio': _RenderAspectRatio_aspectRatio_set$},
    ),
    'RenderIntrinsicWidth': m.ClassMirror(
      'RenderIntrinsicWidth',
      {
        '#as': RenderIntrinsicWidth_as$,
        '#is': RenderIntrinsicWidth_is$,
        'stepWidth': _RenderIntrinsicWidth_stepWidth$,
        'stepHeight': _RenderIntrinsicWidth_stepHeight$,
        'computeMinIntrinsicWidth':
            _RenderIntrinsicWidth_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth':
            _RenderIntrinsicWidth_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight':
            _RenderIntrinsicWidth_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight':
            _RenderIntrinsicWidth_computeMaxIntrinsicHeight$,
        'computeDryLayout': _RenderIntrinsicWidth_computeDryLayout$,
        'performLayout': _RenderIntrinsicWidth_performLayout$,
        'debugFillProperties': _RenderIntrinsicWidth_debugFillProperties$,
      },
      {
        'stepWidth': _RenderIntrinsicWidth_stepWidth_set$,
        'stepHeight': _RenderIntrinsicWidth_stepHeight_set$,
      },
    ),
    'RenderIntrinsicHeight': m.ClassMirror(
      'RenderIntrinsicHeight',
      {
        '#as': RenderIntrinsicHeight_as$,
        '#is': RenderIntrinsicHeight_is$,
        'computeMinIntrinsicWidth':
            _RenderIntrinsicHeight_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth':
            _RenderIntrinsicHeight_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight':
            _RenderIntrinsicHeight_computeMinIntrinsicHeight$,
        'computeDryLayout': _RenderIntrinsicHeight_computeDryLayout$,
        'performLayout': _RenderIntrinsicHeight_performLayout$,
      },
      {},
    ),
    'RenderOpacity': m.ClassMirror(
      'RenderOpacity',
      {
        '#as': RenderOpacity_as$,
        '#is': RenderOpacity_is$,
        'alwaysNeedsCompositing': _RenderOpacity_alwaysNeedsCompositing$,
        'isRepaintBoundary': _RenderOpacity_isRepaintBoundary$,
        'opacity': _RenderOpacity_opacity$,
        'alwaysIncludeSemantics': _RenderOpacity_alwaysIncludeSemantics$,
        'paintsChild': _RenderOpacity_paintsChild$,
        'updateCompositedLayer': _RenderOpacity_updateCompositedLayer$,
        'paint': _RenderOpacity_paint$,
        'debugFillProperties': _RenderOpacity_debugFillProperties$,
      },
      {
        'opacity': _RenderOpacity_opacity_set$,
        'alwaysIncludeSemantics': _RenderOpacity_alwaysIncludeSemantics_set$,
      },
    ),
    'RenderAnimatedOpacity': m.ClassMirror(
      'RenderAnimatedOpacity',
      {
        '#as': RenderAnimatedOpacity_as$,
        '#is': RenderAnimatedOpacity_is$,
      },
      {},
    ),
    'RenderShaderMask': m.ClassMirror(
      'RenderShaderMask',
      {
        '#as': RenderShaderMask_as$,
        '#is': RenderShaderMask_is$,
        'layer': _RenderShaderMask_layer$,
        'shaderCallback': _RenderShaderMask_shaderCallback$,
        'blendMode': _RenderShaderMask_blendMode$,
        'alwaysNeedsCompositing': _RenderShaderMask_alwaysNeedsCompositing$,
        'paint': _RenderShaderMask_paint$,
      },
      {
        'shaderCallback': _RenderShaderMask_shaderCallback_set$,
        'blendMode': _RenderShaderMask_blendMode_set$,
      },
    ),
    'RenderBackdropFilter': m.ClassMirror(
      'RenderBackdropFilter',
      {
        '#as': RenderBackdropFilter_as$,
        '#is': RenderBackdropFilter_is$,
        'layer': _RenderBackdropFilter_layer$,
        'filter': _RenderBackdropFilter_filter$,
        'blendMode': _RenderBackdropFilter_blendMode$,
        'alwaysNeedsCompositing': _RenderBackdropFilter_alwaysNeedsCompositing$,
        'paint': _RenderBackdropFilter_paint$,
      },
      {
        'filter': _RenderBackdropFilter_filter_set$,
        'blendMode': _RenderBackdropFilter_blendMode_set$,
      },
    ),
    'CustomClipper': m.ClassMirror(
      'CustomClipper',
      {
        '#as': CustomClipper_as$,
        '#is': CustomClipper_is$,
        'getClip': _CustomClipper_getClip$,
        'getApproximateClipRect': _CustomClipper_getApproximateClipRect$,
        'shouldReclip': _CustomClipper_shouldReclip$,
        'toString': _CustomClipper_toString$,
      },
      {},
    ),
    'ShapeBorderClipper': m.ClassMirror(
      'ShapeBorderClipper',
      {
        '#as': ShapeBorderClipper_as$,
        '#is': ShapeBorderClipper_is$,
        'shape': _ShapeBorderClipper_shape$,
        'textDirection': _ShapeBorderClipper_textDirection$,
        'getClip': _ShapeBorderClipper_getClip$,
        'shouldReclip': _ShapeBorderClipper_shouldReclip$,
      },
      {},
    ),
    'RenderClipRect': m.ClassMirror(
      'RenderClipRect',
      {
        '#as': RenderClipRect_as$,
        '#is': RenderClipRect_is$,
        'hitTest': _RenderClipRect_hitTest$,
        'paint': _RenderClipRect_paint$,
        'debugPaintSize': _RenderClipRect_debugPaintSize$,
      },
      {},
    ),
    'RenderClipRRect': m.ClassMirror(
      'RenderClipRRect',
      {
        '#as': RenderClipRRect_as$,
        '#is': RenderClipRRect_is$,
        'borderRadius': _RenderClipRRect_borderRadius$,
        'textDirection': _RenderClipRRect_textDirection$,
        'hitTest': _RenderClipRRect_hitTest$,
        'paint': _RenderClipRRect_paint$,
        'debugPaintSize': _RenderClipRRect_debugPaintSize$,
      },
      {
        'borderRadius': _RenderClipRRect_borderRadius_set$,
        'textDirection': _RenderClipRRect_textDirection_set$,
      },
    ),
    'RenderClipOval': m.ClassMirror(
      'RenderClipOval',
      {
        '#as': RenderClipOval_as$,
        '#is': RenderClipOval_is$,
        'hitTest': _RenderClipOval_hitTest$,
        'paint': _RenderClipOval_paint$,
        'debugPaintSize': _RenderClipOval_debugPaintSize$,
      },
      {},
    ),
    'RenderClipPath': m.ClassMirror(
      'RenderClipPath',
      {
        '#as': RenderClipPath_as$,
        '#is': RenderClipPath_is$,
        'hitTest': _RenderClipPath_hitTest$,
        'paint': _RenderClipPath_paint$,
        'debugPaintSize': _RenderClipPath_debugPaintSize$,
      },
      {},
    ),
    'RenderPhysicalModel': m.ClassMirror(
      'RenderPhysicalModel',
      {
        '#as': RenderPhysicalModel_as$,
        '#is': RenderPhysicalModel_is$,
        'shape': _RenderPhysicalModel_shape$,
        'borderRadius': _RenderPhysicalModel_borderRadius$,
        'hitTest': _RenderPhysicalModel_hitTest$,
        'paint': _RenderPhysicalModel_paint$,
        'debugFillProperties': _RenderPhysicalModel_debugFillProperties$,
      },
      {
        'shape': _RenderPhysicalModel_shape_set$,
        'borderRadius': _RenderPhysicalModel_borderRadius_set$,
      },
    ),
    'RenderPhysicalShape': m.ClassMirror(
      'RenderPhysicalShape',
      {
        '#as': RenderPhysicalShape_as$,
        '#is': RenderPhysicalShape_is$,
        'hitTest': _RenderPhysicalShape_hitTest$,
        'paint': _RenderPhysicalShape_paint$,
        'debugFillProperties': _RenderPhysicalShape_debugFillProperties$,
      },
      {},
    ),
    'RenderDecoratedBox': m.ClassMirror(
      'RenderDecoratedBox',
      {
        '#as': RenderDecoratedBox_as$,
        '#is': RenderDecoratedBox_is$,
        'decoration': _RenderDecoratedBox_decoration$,
        'position': _RenderDecoratedBox_position$,
        'configuration': _RenderDecoratedBox_configuration$,
        'detach': _RenderDecoratedBox_detach$,
        'hitTestSelf': _RenderDecoratedBox_hitTestSelf$,
        'paint': _RenderDecoratedBox_paint$,
        'debugFillProperties': _RenderDecoratedBox_debugFillProperties$,
      },
      {
        'decoration': _RenderDecoratedBox_decoration_set$,
        'position': _RenderDecoratedBox_position_set$,
        'configuration': _RenderDecoratedBox_configuration_set$,
      },
    ),
    'RenderTransform': m.ClassMirror(
      'RenderTransform',
      {
        '#as': RenderTransform_as$,
        '#is': RenderTransform_is$,
        'transformHitTests': _RenderTransform_transformHitTests$,
        'origin': _RenderTransform_origin$,
        'alignment': _RenderTransform_alignment$,
        'textDirection': _RenderTransform_textDirection$,
        'alwaysNeedsCompositing': _RenderTransform_alwaysNeedsCompositing$,
        'filterQuality': _RenderTransform_filterQuality$,
        'setIdentity': _RenderTransform_setIdentity$,
        'rotateX': _RenderTransform_rotateX$,
        'rotateY': _RenderTransform_rotateY$,
        'rotateZ': _RenderTransform_rotateZ$,
        'translate': _RenderTransform_translate$,
        'scale': _RenderTransform_scale$,
        'hitTest': _RenderTransform_hitTest$,
        'hitTestChildren': _RenderTransform_hitTestChildren$,
        'paint': _RenderTransform_paint$,
        'applyPaintTransform': _RenderTransform_applyPaintTransform$,
        'debugFillProperties': _RenderTransform_debugFillProperties$,
      },
      {
        'transformHitTests': _RenderTransform_transformHitTests_set$,
        'origin': _RenderTransform_origin_set$,
        'alignment': _RenderTransform_alignment_set$,
        'textDirection': _RenderTransform_textDirection_set$,
        'transform': _RenderTransform_transform_set$,
        'filterQuality': _RenderTransform_filterQuality_set$,
      },
    ),
    'RenderFittedBox': m.ClassMirror(
      'RenderFittedBox',
      {
        '#as': RenderFittedBox_as$,
        '#is': RenderFittedBox_is$,
        'fit': _RenderFittedBox_fit$,
        'alignment': _RenderFittedBox_alignment$,
        'textDirection': _RenderFittedBox_textDirection$,
        'clipBehavior': _RenderFittedBox_clipBehavior$,
        'computeDryLayout': _RenderFittedBox_computeDryLayout$,
        'performLayout': _RenderFittedBox_performLayout$,
        'paint': _RenderFittedBox_paint$,
        'hitTestChildren': _RenderFittedBox_hitTestChildren$,
        'paintsChild': _RenderFittedBox_paintsChild$,
        'applyPaintTransform': _RenderFittedBox_applyPaintTransform$,
        'debugFillProperties': _RenderFittedBox_debugFillProperties$,
      },
      {
        'fit': _RenderFittedBox_fit_set$,
        'alignment': _RenderFittedBox_alignment_set$,
        'textDirection': _RenderFittedBox_textDirection_set$,
        'clipBehavior': _RenderFittedBox_clipBehavior_set$,
      },
    ),
    'RenderFractionalTranslation': m.ClassMirror(
      'RenderFractionalTranslation',
      {
        '#as': RenderFractionalTranslation_as$,
        '#is': RenderFractionalTranslation_is$,
        'transformHitTests': _RenderFractionalTranslation_transformHitTests$,
        'translation': _RenderFractionalTranslation_translation$,
        'hitTest': _RenderFractionalTranslation_hitTest$,
        'hitTestChildren': _RenderFractionalTranslation_hitTestChildren$,
        'paint': _RenderFractionalTranslation_paint$,
        'applyPaintTransform':
            _RenderFractionalTranslation_applyPaintTransform$,
        'debugFillProperties':
            _RenderFractionalTranslation_debugFillProperties$,
      },
      {
        'transformHitTests':
            _RenderFractionalTranslation_transformHitTests_set$,
        'translation': _RenderFractionalTranslation_translation_set$,
      },
    ),
    'RenderPointerListener': m.ClassMirror(
      'RenderPointerListener',
      {
        '#as': RenderPointerListener_as$,
        '#is': RenderPointerListener_is$,
        'onPointerDown': _RenderPointerListener_onPointerDown$,
        'onPointerMove': _RenderPointerListener_onPointerMove$,
        'onPointerUp': _RenderPointerListener_onPointerUp$,
        'onPointerHover': _RenderPointerListener_onPointerHover$,
        'onPointerCancel': _RenderPointerListener_onPointerCancel$,
        'onPointerPanZoomStart': _RenderPointerListener_onPointerPanZoomStart$,
        'onPointerPanZoomUpdate':
            _RenderPointerListener_onPointerPanZoomUpdate$,
        'onPointerPanZoomEnd': _RenderPointerListener_onPointerPanZoomEnd$,
        'onPointerSignal': _RenderPointerListener_onPointerSignal$,
        'computeSizeForNoChild': _RenderPointerListener_computeSizeForNoChild$,
        'handleEvent': _RenderPointerListener_handleEvent$,
        'debugFillProperties': _RenderPointerListener_debugFillProperties$,
      },
      {
        'onPointerDown': _RenderPointerListener_onPointerDown_set$,
        'onPointerMove': _RenderPointerListener_onPointerMove_set$,
        'onPointerUp': _RenderPointerListener_onPointerUp_set$,
        'onPointerHover': _RenderPointerListener_onPointerHover_set$,
        'onPointerCancel': _RenderPointerListener_onPointerCancel_set$,
        'onPointerPanZoomStart':
            _RenderPointerListener_onPointerPanZoomStart_set$,
        'onPointerPanZoomUpdate':
            _RenderPointerListener_onPointerPanZoomUpdate_set$,
        'onPointerPanZoomEnd': _RenderPointerListener_onPointerPanZoomEnd_set$,
        'onPointerSignal': _RenderPointerListener_onPointerSignal_set$,
      },
    ),
    'RenderMouseRegion': m.ClassMirror(
      'RenderMouseRegion',
      {
        '#as': RenderMouseRegion_as$,
        '#is': RenderMouseRegion_is$,
        'onEnter': _RenderMouseRegion_onEnter$,
        'onHover': _RenderMouseRegion_onHover$,
        'onExit': _RenderMouseRegion_onExit$,
        'opaque': _RenderMouseRegion_opaque$,
        'hitTestBehavior': _RenderMouseRegion_hitTestBehavior$,
        'cursor': _RenderMouseRegion_cursor$,
        'validForMouseTracker': _RenderMouseRegion_validForMouseTracker$,
        'hitTest': _RenderMouseRegion_hitTest$,
        'handleEvent': _RenderMouseRegion_handleEvent$,
        'attach': _RenderMouseRegion_attach$,
        'detach': _RenderMouseRegion_detach$,
        'computeSizeForNoChild': _RenderMouseRegion_computeSizeForNoChild$,
        'debugFillProperties': _RenderMouseRegion_debugFillProperties$,
      },
      {
        'onEnter': _RenderMouseRegion_onEnter_set$,
        'onHover': _RenderMouseRegion_onHover_set$,
        'onExit': _RenderMouseRegion_onExit_set$,
        'opaque': _RenderMouseRegion_opaque_set$,
        'hitTestBehavior': _RenderMouseRegion_hitTestBehavior_set$,
        'cursor': _RenderMouseRegion_cursor_set$,
      },
    ),
    'RenderRepaintBoundary': m.ClassMirror(
      'RenderRepaintBoundary',
      {
        '#as': RenderRepaintBoundary_as$,
        '#is': RenderRepaintBoundary_is$,
        'isRepaintBoundary': _RenderRepaintBoundary_isRepaintBoundary$,
        'debugSymmetricPaintCount':
            _RenderRepaintBoundary_debugSymmetricPaintCount$,
        'debugAsymmetricPaintCount':
            _RenderRepaintBoundary_debugAsymmetricPaintCount$,
        'toImage': _RenderRepaintBoundary_toImage$,
        'toImageSync': _RenderRepaintBoundary_toImageSync$,
        'debugResetMetrics': _RenderRepaintBoundary_debugResetMetrics$,
        'debugRegisterRepaintBoundaryPaint':
            _RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint$,
        'debugFillProperties': _RenderRepaintBoundary_debugFillProperties$,
      },
      {},
    ),
    'RenderIgnorePointer': m.ClassMirror(
      'RenderIgnorePointer',
      {
        '#as': RenderIgnorePointer_as$,
        '#is': RenderIgnorePointer_is$,
        'ignoring': _RenderIgnorePointer_ignoring$,
        'ignoringSemantics': _RenderIgnorePointer_ignoringSemantics$,
        'hitTest': _RenderIgnorePointer_hitTest$,
        'debugFillProperties': _RenderIgnorePointer_debugFillProperties$,
      },
      {
        'ignoring': _RenderIgnorePointer_ignoring_set$,
        'ignoringSemantics': _RenderIgnorePointer_ignoringSemantics_set$,
      },
    ),
    'RenderOffstage': m.ClassMirror(
      'RenderOffstage',
      {
        '#as': RenderOffstage_as$,
        '#is': RenderOffstage_is$,
        'offstage': _RenderOffstage_offstage$,
        'sizedByParent': _RenderOffstage_sizedByParent$,
        'computeMinIntrinsicWidth': _RenderOffstage_computeMinIntrinsicWidth$,
        'computeMaxIntrinsicWidth': _RenderOffstage_computeMaxIntrinsicWidth$,
        'computeMinIntrinsicHeight': _RenderOffstage_computeMinIntrinsicHeight$,
        'computeMaxIntrinsicHeight': _RenderOffstage_computeMaxIntrinsicHeight$,
        'computeDistanceToActualBaseline':
            _RenderOffstage_computeDistanceToActualBaseline$,
        'computeDryLayout': _RenderOffstage_computeDryLayout$,
        'performResize': _RenderOffstage_performResize$,
        'performLayout': _RenderOffstage_performLayout$,
        'hitTest': _RenderOffstage_hitTest$,
        'paintsChild': _RenderOffstage_paintsChild$,
        'paint': _RenderOffstage_paint$,
        'debugFillProperties': _RenderOffstage_debugFillProperties$,
        'debugDescribeChildren': _RenderOffstage_debugDescribeChildren$,
      },
      {'offstage': _RenderOffstage_offstage_set$},
    ),
    'RenderAbsorbPointer': m.ClassMirror(
      'RenderAbsorbPointer',
      {
        '#as': RenderAbsorbPointer_as$,
        '#is': RenderAbsorbPointer_is$,
        'absorbing': _RenderAbsorbPointer_absorbing$,
        'ignoringSemantics': _RenderAbsorbPointer_ignoringSemantics$,
        'hitTest': _RenderAbsorbPointer_hitTest$,
        'debugFillProperties': _RenderAbsorbPointer_debugFillProperties$,
      },
      {
        'absorbing': _RenderAbsorbPointer_absorbing_set$,
        'ignoringSemantics': _RenderAbsorbPointer_ignoringSemantics_set$,
      },
    ),
    'RenderMetaData': m.ClassMirror(
      'RenderMetaData',
      {
        '#as': RenderMetaData_as$,
        '#is': RenderMetaData_is$,
        'metaData': _RenderMetaData_metaData$,
        'debugFillProperties': _RenderMetaData_debugFillProperties$,
      },
      {'metaData': _RenderMetaData_metaData_set$},
    ),
    'RenderSemanticsGestureHandler': m.ClassMirror(
      'RenderSemanticsGestureHandler',
      {
        '#as': RenderSemanticsGestureHandler_as$,
        '#is': RenderSemanticsGestureHandler_is$,
        'scrollFactor': _RenderSemanticsGestureHandler_scrollFactor$,
        'validActions': _RenderSemanticsGestureHandler_validActions$,
        'onTap': _RenderSemanticsGestureHandler_onTap$,
        'onLongPress': _RenderSemanticsGestureHandler_onLongPress$,
        'onHorizontalDragUpdate':
            _RenderSemanticsGestureHandler_onHorizontalDragUpdate$,
        'onVerticalDragUpdate':
            _RenderSemanticsGestureHandler_onVerticalDragUpdate$,
        'describeSemanticsConfiguration':
            _RenderSemanticsGestureHandler_describeSemanticsConfiguration$,
        'debugFillProperties':
            _RenderSemanticsGestureHandler_debugFillProperties$,
      },
      {
        'scrollFactor': _RenderSemanticsGestureHandler_scrollFactor_set$,
        'validActions': _RenderSemanticsGestureHandler_validActions_set$,
        'onTap': _RenderSemanticsGestureHandler_onTap_set$,
        'onLongPress': _RenderSemanticsGestureHandler_onLongPress_set$,
        'onHorizontalDragUpdate':
            _RenderSemanticsGestureHandler_onHorizontalDragUpdate_set$,
        'onVerticalDragUpdate':
            _RenderSemanticsGestureHandler_onVerticalDragUpdate_set$,
      },
    ),
    'RenderSemanticsAnnotations': m.ClassMirror(
      'RenderSemanticsAnnotations',
      {
        '#as': RenderSemanticsAnnotations_as$,
        '#is': RenderSemanticsAnnotations_is$,
        'properties': _RenderSemanticsAnnotations_properties$,
        'container': _RenderSemanticsAnnotations_container$,
        'explicitChildNodes': _RenderSemanticsAnnotations_explicitChildNodes$,
        'excludeSemantics': _RenderSemanticsAnnotations_excludeSemantics$,
        'textDirection': _RenderSemanticsAnnotations_textDirection$,
        'describeSemanticsConfiguration':
            _RenderSemanticsAnnotations_describeSemanticsConfiguration$,
      },
      {
        'properties': _RenderSemanticsAnnotations_properties_set$,
        'container': _RenderSemanticsAnnotations_container_set$,
        'explicitChildNodes':
            _RenderSemanticsAnnotations_explicitChildNodes_set$,
        'excludeSemantics': _RenderSemanticsAnnotations_excludeSemantics_set$,
        'textDirection': _RenderSemanticsAnnotations_textDirection_set$,
      },
    ),
    'RenderBlockSemantics': m.ClassMirror(
      'RenderBlockSemantics',
      {
        '#as': RenderBlockSemantics_as$,
        '#is': RenderBlockSemantics_is$,
        'blocking': _RenderBlockSemantics_blocking$,
        'describeSemanticsConfiguration':
            _RenderBlockSemantics_describeSemanticsConfiguration$,
        'debugFillProperties': _RenderBlockSemantics_debugFillProperties$,
      },
      {'blocking': _RenderBlockSemantics_blocking_set$},
    ),
    'RenderMergeSemantics': m.ClassMirror(
      'RenderMergeSemantics',
      {
        '#as': RenderMergeSemantics_as$,
        '#is': RenderMergeSemantics_is$,
        'describeSemanticsConfiguration':
            _RenderMergeSemantics_describeSemanticsConfiguration$,
      },
      {},
    ),
    'RenderExcludeSemantics': m.ClassMirror(
      'RenderExcludeSemantics',
      {
        '#as': RenderExcludeSemantics_as$,
        '#is': RenderExcludeSemantics_is$,
        'excluding': _RenderExcludeSemantics_excluding$,
        'debugFillProperties': _RenderExcludeSemantics_debugFillProperties$,
      },
      {'excluding': _RenderExcludeSemantics_excluding_set$},
    ),
    'RenderIndexedSemantics': m.ClassMirror(
      'RenderIndexedSemantics',
      {
        '#as': RenderIndexedSemantics_as$,
        '#is': RenderIndexedSemantics_is$,
        'index': _RenderIndexedSemantics_index$,
        'describeSemanticsConfiguration':
            _RenderIndexedSemantics_describeSemanticsConfiguration$,
        'debugFillProperties': _RenderIndexedSemantics_debugFillProperties$,
      },
      {'index': _RenderIndexedSemantics_index_set$},
    ),
    'RenderLeaderLayer': m.ClassMirror(
      'RenderLeaderLayer',
      {
        '#as': RenderLeaderLayer_as$,
        '#is': RenderLeaderLayer_is$,
        'link': _RenderLeaderLayer_link$,
        'alwaysNeedsCompositing': _RenderLeaderLayer_alwaysNeedsCompositing$,
        'performLayout': _RenderLeaderLayer_performLayout$,
        'paint': _RenderLeaderLayer_paint$,
        'debugFillProperties': _RenderLeaderLayer_debugFillProperties$,
      },
      {'link': _RenderLeaderLayer_link_set$},
    ),
    'RenderFollowerLayer': m.ClassMirror(
      'RenderFollowerLayer',
      {
        '#as': RenderFollowerLayer_as$,
        '#is': RenderFollowerLayer_is$,
        'link': _RenderFollowerLayer_link$,
        'showWhenUnlinked': _RenderFollowerLayer_showWhenUnlinked$,
        'offset': _RenderFollowerLayer_offset$,
        'leaderAnchor': _RenderFollowerLayer_leaderAnchor$,
        'followerAnchor': _RenderFollowerLayer_followerAnchor$,
        'alwaysNeedsCompositing': _RenderFollowerLayer_alwaysNeedsCompositing$,
        'layer': _RenderFollowerLayer_layer$,
        'detach': _RenderFollowerLayer_detach$,
        'getCurrentTransform': _RenderFollowerLayer_getCurrentTransform$,
        'hitTest': _RenderFollowerLayer_hitTest$,
        'hitTestChildren': _RenderFollowerLayer_hitTestChildren$,
        'paint': _RenderFollowerLayer_paint$,
        'applyPaintTransform': _RenderFollowerLayer_applyPaintTransform$,
        'debugFillProperties': _RenderFollowerLayer_debugFillProperties$,
      },
      {
        'link': _RenderFollowerLayer_link_set$,
        'showWhenUnlinked': _RenderFollowerLayer_showWhenUnlinked_set$,
        'offset': _RenderFollowerLayer_offset_set$,
        'leaderAnchor': _RenderFollowerLayer_leaderAnchor_set$,
        'followerAnchor': _RenderFollowerLayer_followerAnchor_set$,
      },
    ),
    'RenderAnnotatedRegion': m.ClassMirror(
      'RenderAnnotatedRegion',
      {
        '#as': RenderAnnotatedRegion_as$,
        '#is': RenderAnnotatedRegion_is$,
        'alwaysNeedsCompositing':
            _RenderAnnotatedRegion_alwaysNeedsCompositing$,
        'value': _RenderAnnotatedRegion_value$,
        'sized': _RenderAnnotatedRegion_sized$,
        'paint': _RenderAnnotatedRegion_paint$,
      },
      {
        'value': _RenderAnnotatedRegion_value_set$,
        'sized': _RenderAnnotatedRegion_sized_set$,
      },
    ),
    'HitTestBehavior': m.ClassMirror(
      'HitTestBehavior',
      {},
      {},
    ),
    'DecorationPosition': m.ClassMirror(
      'DecorationPosition',
      {},
      {},
    ),
  },
);
Function RenderProxyBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderProxyBox;
Function RenderProxyBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderProxyBox;
Function _RenderProxyBox__$(m.Scope scope$) => ([RenderBox? child]) {
      if (child == null) {
        return RenderProxyBox();
      }
      return RenderProxyBox(child!);
    };
Function RenderProxyBoxWithHitTestBehavior_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderProxyBoxWithHitTestBehavior;
Function RenderProxyBoxWithHitTestBehavior_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderProxyBoxWithHitTestBehavior;
Function _RenderProxyBoxWithHitTestBehavior_behavior$(
  m.Scope scope$,
  RenderProxyBoxWithHitTestBehavior target$,
) =>
    () {
      return target$.behavior;
    };
void _RenderProxyBoxWithHitTestBehavior_behavior_set$(
  m.Scope scope$,
  RenderProxyBoxWithHitTestBehavior target$,
) =>
    (dynamic other$) {
      target$.behavior = other$;
    };
Function _RenderProxyBoxWithHitTestBehavior_hitTest$(
  m.Scope scope$,
  RenderProxyBoxWithHitTestBehavior target$,
) =>
    target$.hitTest;
Function _RenderProxyBoxWithHitTestBehavior_hitTestSelf$(
  m.Scope scope$,
  RenderProxyBoxWithHitTestBehavior target$,
) =>
    target$.hitTestSelf;
Function _RenderProxyBoxWithHitTestBehavior_debugFillProperties$(
  m.Scope scope$,
  RenderProxyBoxWithHitTestBehavior target$,
) =>
    target$.debugFillProperties;
Function RenderConstrainedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderConstrainedBox;
Function RenderConstrainedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderConstrainedBox;
Function _RenderConstrainedBox_additionalConstraints$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    () {
      return target$.additionalConstraints;
    };
void _RenderConstrainedBox_additionalConstraints_set$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    (dynamic other$) {
      target$.additionalConstraints = other$;
    };
Function _RenderConstrainedBox__$(m.Scope scope$) => ({
      RenderBox? child,
      required BoxConstraints additionalConstraints,
    }) {
      return RenderConstrainedBox(
        additionalConstraints: additionalConstraints,
        child: child,
      );
    };
Function _RenderConstrainedBox_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderConstrainedBox_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderConstrainedBox_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderConstrainedBox_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderConstrainedBox_performLayout$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.performLayout;
Function _RenderConstrainedBox_computeDryLayout$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.computeDryLayout;
Function _RenderConstrainedBox_debugPaintSize$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.debugPaintSize;
Function _RenderConstrainedBox_debugFillProperties$(
  m.Scope scope$,
  RenderConstrainedBox target$,
) =>
    target$.debugFillProperties;
Function RenderLimitedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderLimitedBox;
Function RenderLimitedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderLimitedBox;
Function _RenderLimitedBox_maxWidth$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    () {
      return target$.maxWidth;
    };
void _RenderLimitedBox_maxWidth_set$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    (dynamic other$) {
      target$.maxWidth = other$;
    };
Function _RenderLimitedBox_maxHeight$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    () {
      return target$.maxHeight;
    };
void _RenderLimitedBox_maxHeight_set$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    (dynamic other$) {
      target$.maxHeight = other$;
    };
Function _RenderLimitedBox__$(m.Scope scope$) => ({
      RenderBox? child,
      double? maxWidth,
      double? maxHeight,
    }) {
      return RenderLimitedBox(
        child: child,
        maxHeight: maxHeight ?? double.infinity,
        maxWidth: maxWidth ?? double.infinity,
      );
    };
Function _RenderLimitedBox_computeDryLayout$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    target$.computeDryLayout;
Function _RenderLimitedBox_performLayout$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    target$.performLayout;
Function _RenderLimitedBox_debugFillProperties$(
  m.Scope scope$,
  RenderLimitedBox target$,
) =>
    target$.debugFillProperties;
Function RenderAspectRatio_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderAspectRatio;
Function RenderAspectRatio_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderAspectRatio;
Function _RenderAspectRatio_aspectRatio$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    () {
      return target$.aspectRatio;
    };
void _RenderAspectRatio_aspectRatio_set$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    (dynamic other$) {
      target$.aspectRatio = other$;
    };
Function _RenderAspectRatio__$(m.Scope scope$) => ({
      RenderBox? child,
      required double aspectRatio,
    }) {
      return RenderAspectRatio(
        aspectRatio: aspectRatio,
        child: child,
      );
    };
Function _RenderAspectRatio_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderAspectRatio_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderAspectRatio_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderAspectRatio_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderAspectRatio_computeDryLayout$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.computeDryLayout;
Function _RenderAspectRatio_performLayout$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.performLayout;
Function _RenderAspectRatio_debugFillProperties$(
  m.Scope scope$,
  RenderAspectRatio target$,
) =>
    target$.debugFillProperties;
Function RenderIntrinsicWidth_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderIntrinsicWidth;
Function RenderIntrinsicWidth_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderIntrinsicWidth;
Function _RenderIntrinsicWidth_stepWidth$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    () {
      return target$.stepWidth;
    };
void _RenderIntrinsicWidth_stepWidth_set$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    (dynamic other$) {
      target$.stepWidth = other$;
    };
Function _RenderIntrinsicWidth_stepHeight$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    () {
      return target$.stepHeight;
    };
void _RenderIntrinsicWidth_stepHeight_set$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    (dynamic other$) {
      target$.stepHeight = other$;
    };
Function _RenderIntrinsicWidth__$(m.Scope scope$) => ({
      double? stepWidth,
      double? stepHeight,
      RenderBox? child,
    }) {
      return RenderIntrinsicWidth(
        child: child,
        stepHeight: stepHeight,
        stepWidth: stepWidth,
      );
    };
Function _RenderIntrinsicWidth_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderIntrinsicWidth_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderIntrinsicWidth_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderIntrinsicWidth_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderIntrinsicWidth_computeDryLayout$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.computeDryLayout;
Function _RenderIntrinsicWidth_performLayout$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.performLayout;
Function _RenderIntrinsicWidth_debugFillProperties$(
  m.Scope scope$,
  RenderIntrinsicWidth target$,
) =>
    target$.debugFillProperties;
Function RenderIntrinsicHeight_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderIntrinsicHeight;
Function RenderIntrinsicHeight_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderIntrinsicHeight;
Function _RenderIntrinsicHeight__$(m.Scope scope$) => ({RenderBox? child}) {
      return RenderIntrinsicHeight(child: child);
    };
Function _RenderIntrinsicHeight_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderIntrinsicHeight target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderIntrinsicHeight_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderIntrinsicHeight target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderIntrinsicHeight_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderIntrinsicHeight target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderIntrinsicHeight_computeDryLayout$(
  m.Scope scope$,
  RenderIntrinsicHeight target$,
) =>
    target$.computeDryLayout;
Function _RenderIntrinsicHeight_performLayout$(
  m.Scope scope$,
  RenderIntrinsicHeight target$,
) =>
    target$.performLayout;
Function RenderOpacity_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderOpacity;
Function RenderOpacity_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderOpacity;
Function _RenderOpacity_alwaysNeedsCompositing$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _RenderOpacity_isRepaintBoundary$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    () {
      return target$.isRepaintBoundary;
    };
Function _RenderOpacity_opacity$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    () {
      return target$.opacity;
    };
void _RenderOpacity_opacity_set$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    (dynamic other$) {
      target$.opacity = other$;
    };
Function _RenderOpacity_alwaysIncludeSemantics$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    () {
      return target$.alwaysIncludeSemantics;
    };
void _RenderOpacity_alwaysIncludeSemantics_set$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    (dynamic other$) {
      target$.alwaysIncludeSemantics = other$;
    };
Function _RenderOpacity__$(m.Scope scope$) => ({
      double? opacity,
      bool? alwaysIncludeSemantics,
      RenderBox? child,
    }) {
      return RenderOpacity(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        child: child,
        opacity: opacity ?? 1.0,
      );
    };
Function _RenderOpacity_paintsChild$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    target$.paintsChild;
Function _RenderOpacity_updateCompositedLayer$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    target$.updateCompositedLayer;
Function _RenderOpacity_paint$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    target$.paint;
Function _RenderOpacity_visitChildrenForSemantics$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildrenForSemantics(visitorProxy);
    };
Function _RenderOpacity_debugFillProperties$(
  m.Scope scope$,
  RenderOpacity target$,
) =>
    target$.debugFillProperties;
Function RenderAnimatedOpacity_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderAnimatedOpacity;
Function RenderAnimatedOpacity_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderAnimatedOpacity;
Function _RenderAnimatedOpacity__$(m.Scope scope$) => ({
      required Animation<double> opacity,
      bool? alwaysIncludeSemantics,
      RenderBox? child,
    }) {
      return RenderAnimatedOpacity(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        child: child,
        opacity: opacity,
      );
    };
Function RenderShaderMask_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderShaderMask;
Function RenderShaderMask_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderShaderMask;
Function _RenderShaderMask_layer$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    () {
      return target$.layer;
    };
Function _RenderShaderMask_shaderCallback$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    () {
      return target$.shaderCallback;
    };
Function _RenderShaderMask_shaderCallback_set$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    (m.FunctionPointer value) {
      Shader valueProxy(Rect value_bounds$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value,
            [value_bounds$],
            {},
          );
      target$.shaderCallback = (valueProxy);
    };
Function _RenderShaderMask_blendMode$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    () {
      return target$.blendMode;
    };
void _RenderShaderMask_blendMode_set$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    (dynamic other$) {
      target$.blendMode = other$;
    };
Function _RenderShaderMask_alwaysNeedsCompositing$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _RenderShaderMask__$(m.Scope scope$) => ({
      RenderBox? child,
      required m.FunctionPointer shaderCallback,
      BlendMode? blendMode,
    }) {
      Shader shaderCallbackProxy(Rect shaderCallback_bounds$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            shaderCallback,
            [shaderCallback_bounds$],
            {},
          );
      return RenderShaderMask(
        blendMode: blendMode ?? BlendMode.modulate,
        child: child,
        shaderCallback: shaderCallbackProxy,
      );
    };
Function _RenderShaderMask_paint$(
  m.Scope scope$,
  RenderShaderMask target$,
) =>
    target$.paint;
Function RenderBackdropFilter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderBackdropFilter;
Function RenderBackdropFilter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderBackdropFilter;
Function _RenderBackdropFilter_layer$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    () {
      return target$.layer;
    };
Function _RenderBackdropFilter_filter$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    () {
      return target$.filter;
    };
void _RenderBackdropFilter_filter_set$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    (dynamic other$) {
      target$.filter = other$;
    };
Function _RenderBackdropFilter_blendMode$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    () {
      return target$.blendMode;
    };
void _RenderBackdropFilter_blendMode_set$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    (dynamic other$) {
      target$.blendMode = other$;
    };
Function _RenderBackdropFilter_alwaysNeedsCompositing$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _RenderBackdropFilter__$(m.Scope scope$) => ({
      RenderBox? child,
      required ImageFilter filter,
      BlendMode? blendMode,
    }) {
      return RenderBackdropFilter(
        blendMode: blendMode ?? BlendMode.srcOver,
        child: child,
        filter: filter,
      );
    };
Function _RenderBackdropFilter_paint$(
  m.Scope scope$,
  RenderBackdropFilter target$,
) =>
    target$.paint;
Function CustomClipper_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as CustomClipper<T>;
Function CustomClipper_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is CustomClipper<T>;
Function _CustomClipper_addListener$(
  m.Scope scope$,
  CustomClipper target$,
) =>
    (m.FunctionPointer listener) {
      void listenerProxy() => scope$.engine.callFunctionPointer(
            scope$,
            listener,
            [],
            {},
          );
      target$.addListener(listenerProxy);
    };
Function _CustomClipper_removeListener$(
  m.Scope scope$,
  CustomClipper target$,
) =>
    (m.FunctionPointer listener) {
      void listenerProxy() => scope$.engine.callFunctionPointer(
            scope$,
            listener,
            [],
            {},
          );
      target$.removeListener(listenerProxy);
    };
Function _CustomClipper_getClip$<T>(
  m.Scope scope$,
  CustomClipper<T> target$,
) =>
    target$.getClip;
Function _CustomClipper_getApproximateClipRect$<T>(
  m.Scope scope$,
  CustomClipper<T> target$,
) =>
    target$.getApproximateClipRect;
Function _CustomClipper_shouldReclip$<T>(
  m.Scope scope$,
  CustomClipper<T> target$,
) =>
    target$.shouldReclip;
Function _CustomClipper_toString$<T>(
  m.Scope scope$,
  CustomClipper<T> target$,
) =>
    target$.toString;
Function ShapeBorderClipper_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ShapeBorderClipper;
Function ShapeBorderClipper_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ShapeBorderClipper;
Function _ShapeBorderClipper_shape$(
  m.Scope scope$,
  ShapeBorderClipper target$,
) =>
    () {
      return target$.shape;
    };
Function _ShapeBorderClipper_textDirection$(
  m.Scope scope$,
  ShapeBorderClipper target$,
) =>
    () {
      return target$.textDirection;
    };
Function _ShapeBorderClipper__$(m.Scope scope$) => ({
      required ShapeBorder shape,
      TextDirection? textDirection,
    }) {
      return ShapeBorderClipper(
        shape: shape,
        textDirection: textDirection,
      );
    };
Function _ShapeBorderClipper_getClip$(
  m.Scope scope$,
  ShapeBorderClipper target$,
) =>
    target$.getClip;
Function _ShapeBorderClipper_shouldReclip$(
  m.Scope scope$,
  ShapeBorderClipper target$,
) =>
    target$.shouldReclip;
Function RenderClipRect_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderClipRect;
Function RenderClipRect_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderClipRect;
Function _RenderClipRect__$(m.Scope scope$) => ({
      RenderBox? child,
      CustomClipper<Rect>? clipper,
      Clip? clipBehavior,
    }) {
      return RenderClipRect(
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
      );
    };
Function _RenderClipRect_hitTest$(
  m.Scope scope$,
  RenderClipRect target$,
) =>
    target$.hitTest;
Function _RenderClipRect_paint$(
  m.Scope scope$,
  RenderClipRect target$,
) =>
    target$.paint;
Function _RenderClipRect_debugPaintSize$(
  m.Scope scope$,
  RenderClipRect target$,
) =>
    target$.debugPaintSize;
Function RenderClipRRect_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderClipRRect;
Function RenderClipRRect_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderClipRRect;
Function _RenderClipRRect_borderRadius$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    () {
      return target$.borderRadius;
    };
void _RenderClipRRect_borderRadius_set$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    (dynamic other$) {
      target$.borderRadius = other$;
    };
Function _RenderClipRRect_textDirection$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    () {
      return target$.textDirection;
    };
void _RenderClipRRect_textDirection_set$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _RenderClipRRect__$(m.Scope scope$) => ({
      RenderBox? child,
      BorderRadiusGeometry? borderRadius,
      CustomClipper<RRect>? clipper,
      Clip? clipBehavior,
      TextDirection? textDirection,
    }) {
      return RenderClipRRect(
        borderRadius: borderRadius ?? BorderRadius.zero,
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
        textDirection: textDirection,
      );
    };
Function _RenderClipRRect_hitTest$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    target$.hitTest;
Function _RenderClipRRect_paint$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    target$.paint;
Function _RenderClipRRect_debugPaintSize$(
  m.Scope scope$,
  RenderClipRRect target$,
) =>
    target$.debugPaintSize;
Function RenderClipOval_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderClipOval;
Function RenderClipOval_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderClipOval;
Function _RenderClipOval__$(m.Scope scope$) => ({
      RenderBox? child,
      CustomClipper<Rect>? clipper,
      Clip? clipBehavior,
    }) {
      return RenderClipOval(
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
      );
    };
Function _RenderClipOval_hitTest$(
  m.Scope scope$,
  RenderClipOval target$,
) =>
    target$.hitTest;
Function _RenderClipOval_paint$(
  m.Scope scope$,
  RenderClipOval target$,
) =>
    target$.paint;
Function _RenderClipOval_debugPaintSize$(
  m.Scope scope$,
  RenderClipOval target$,
) =>
    target$.debugPaintSize;
Function RenderClipPath_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderClipPath;
Function RenderClipPath_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderClipPath;
Function _RenderClipPath__$(m.Scope scope$) => ({
      RenderBox? child,
      CustomClipper<Path>? clipper,
      Clip? clipBehavior,
    }) {
      return RenderClipPath(
        child: child,
        clipBehavior: clipBehavior ?? Clip.antiAlias,
        clipper: clipper,
      );
    };
Function _RenderClipPath_hitTest$(
  m.Scope scope$,
  RenderClipPath target$,
) =>
    target$.hitTest;
Function _RenderClipPath_paint$(
  m.Scope scope$,
  RenderClipPath target$,
) =>
    target$.paint;
Function _RenderClipPath_debugPaintSize$(
  m.Scope scope$,
  RenderClipPath target$,
) =>
    target$.debugPaintSize;
Function RenderPhysicalModel_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderPhysicalModel;
Function RenderPhysicalModel_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderPhysicalModel;
Function _RenderPhysicalModel_shape$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    () {
      return target$.shape;
    };
void _RenderPhysicalModel_shape_set$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    (dynamic other$) {
      target$.shape = other$;
    };
Function _RenderPhysicalModel_borderRadius$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    () {
      return target$.borderRadius;
    };
void _RenderPhysicalModel_borderRadius_set$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    (dynamic other$) {
      target$.borderRadius = other$;
    };
Function _RenderPhysicalModel__$(m.Scope scope$) => ({
      RenderBox? child,
      BoxShape? shape,
      Clip? clipBehavior,
      BorderRadius? borderRadius,
      double? elevation,
      required Color color,
      Color? shadowColor,
    }) {
      return RenderPhysicalModel(
        borderRadius: borderRadius,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        color: color,
        elevation: elevation ?? 0.0,
        shadowColor: shadowColor ?? const Color(0xFF000000),
        shape: shape ?? BoxShape.rectangle,
      );
    };
Function _RenderPhysicalModel_hitTest$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    target$.hitTest;
Function _RenderPhysicalModel_paint$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    target$.paint;
Function _RenderPhysicalModel_debugFillProperties$(
  m.Scope scope$,
  RenderPhysicalModel target$,
) =>
    target$.debugFillProperties;
Function RenderPhysicalShape_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderPhysicalShape;
Function RenderPhysicalShape_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderPhysicalShape;
Function _RenderPhysicalShape__$(m.Scope scope$) => ({
      RenderBox? child,
      required CustomClipper<Path> clipper,
      Clip? clipBehavior,
      double? elevation,
      required Color color,
      Color? shadowColor,
    }) {
      return RenderPhysicalShape(
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        clipper: clipper,
        color: color,
        elevation: elevation ?? 0.0,
        shadowColor: shadowColor ?? const Color(0xFF000000),
      );
    };
Function _RenderPhysicalShape_hitTest$(
  m.Scope scope$,
  RenderPhysicalShape target$,
) =>
    target$.hitTest;
Function _RenderPhysicalShape_paint$(
  m.Scope scope$,
  RenderPhysicalShape target$,
) =>
    target$.paint;
Function _RenderPhysicalShape_debugFillProperties$(
  m.Scope scope$,
  RenderPhysicalShape target$,
) =>
    target$.debugFillProperties;
Function RenderDecoratedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderDecoratedBox;
Function RenderDecoratedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderDecoratedBox;
Function _RenderDecoratedBox_decoration$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    () {
      return target$.decoration;
    };
void _RenderDecoratedBox_decoration_set$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    (dynamic other$) {
      target$.decoration = other$;
    };
Function _RenderDecoratedBox_position$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    () {
      return target$.position;
    };
void _RenderDecoratedBox_position_set$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    (dynamic other$) {
      target$.position = other$;
    };
Function _RenderDecoratedBox_configuration$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    () {
      return target$.configuration;
    };
void _RenderDecoratedBox_configuration_set$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    (dynamic other$) {
      target$.configuration = other$;
    };
Function _RenderDecoratedBox__$(m.Scope scope$) => ({
      required Decoration decoration,
      DecorationPosition? position,
      ImageConfiguration? configuration,
      RenderBox? child,
    }) {
      return RenderDecoratedBox(
        child: child,
        configuration: configuration ?? ImageConfiguration.empty,
        decoration: decoration,
        position: position ?? DecorationPosition.background,
      );
    };
Function _RenderDecoratedBox_detach$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    target$.detach;
Function _RenderDecoratedBox_hitTestSelf$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    target$.hitTestSelf;
Function _RenderDecoratedBox_paint$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    target$.paint;
Function _RenderDecoratedBox_debugFillProperties$(
  m.Scope scope$,
  RenderDecoratedBox target$,
) =>
    target$.debugFillProperties;
Function RenderTransform_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderTransform;
Function RenderTransform_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderTransform;
Function _RenderTransform_transformHitTests$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    () {
      return target$.transformHitTests;
    };
void _RenderTransform_transformHitTests_set$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    (dynamic other$) {
      target$.transformHitTests = other$;
    };
Function _RenderTransform_origin$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    () {
      return target$.origin;
    };
void _RenderTransform_origin_set$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    (dynamic other$) {
      target$.origin = other$;
    };
Function _RenderTransform_alignment$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    () {
      return target$.alignment;
    };
void _RenderTransform_alignment_set$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    (dynamic other$) {
      target$.alignment = other$;
    };
Function _RenderTransform_textDirection$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    () {
      return target$.textDirection;
    };
void _RenderTransform_textDirection_set$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _RenderTransform_alwaysNeedsCompositing$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
void _RenderTransform_transform_set$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    (dynamic other$) {
      target$.transform = other$;
    };
Function _RenderTransform_filterQuality$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    () {
      return target$.filterQuality;
    };
void _RenderTransform_filterQuality_set$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    (dynamic other$) {
      target$.filterQuality = other$;
    };
Function _RenderTransform__$(m.Scope scope$) => ({
      required Matrix4 transform,
      Offset? origin,
      AlignmentGeometry? alignment,
      TextDirection? textDirection,
      bool? transformHitTests,
      FilterQuality? filterQuality,
      RenderBox? child,
    }) {
      return RenderTransform(
        alignment: alignment,
        child: child,
        filterQuality: filterQuality,
        origin: origin,
        textDirection: textDirection,
        transform: transform,
        transformHitTests: transformHitTests ?? true,
      );
    };
Function _RenderTransform_setIdentity$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.setIdentity;
Function _RenderTransform_rotateX$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.rotateX;
Function _RenderTransform_rotateY$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.rotateY;
Function _RenderTransform_rotateZ$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.rotateZ;
Function _RenderTransform_translate$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.translate;
Function _RenderTransform_scale$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.scale;
Function _RenderTransform_hitTest$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.hitTest;
Function _RenderTransform_hitTestChildren$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.hitTestChildren;
Function _RenderTransform_paint$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.paint;
Function _RenderTransform_applyPaintTransform$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.applyPaintTransform;
Function _RenderTransform_debugFillProperties$(
  m.Scope scope$,
  RenderTransform target$,
) =>
    target$.debugFillProperties;
Function RenderFittedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderFittedBox;
Function RenderFittedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderFittedBox;
Function _RenderFittedBox_fit$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    () {
      return target$.fit;
    };
void _RenderFittedBox_fit_set$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    (dynamic other$) {
      target$.fit = other$;
    };
Function _RenderFittedBox_alignment$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    () {
      return target$.alignment;
    };
void _RenderFittedBox_alignment_set$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    (dynamic other$) {
      target$.alignment = other$;
    };
Function _RenderFittedBox_textDirection$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    () {
      return target$.textDirection;
    };
void _RenderFittedBox_textDirection_set$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _RenderFittedBox_clipBehavior$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    () {
      return target$.clipBehavior;
    };
void _RenderFittedBox_clipBehavior_set$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    (dynamic other$) {
      target$.clipBehavior = other$;
    };
Function _RenderFittedBox__$(m.Scope scope$) => ({
      BoxFit? fit,
      AlignmentGeometry? alignment,
      TextDirection? textDirection,
      RenderBox? child,
      Clip? clipBehavior,
    }) {
      return RenderFittedBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        fit: fit ?? BoxFit.contain,
        textDirection: textDirection,
      );
    };
Function _RenderFittedBox_computeDryLayout$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.computeDryLayout;
Function _RenderFittedBox_performLayout$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.performLayout;
Function _RenderFittedBox_paint$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.paint;
Function _RenderFittedBox_hitTestChildren$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.hitTestChildren;
Function _RenderFittedBox_paintsChild$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.paintsChild;
Function _RenderFittedBox_applyPaintTransform$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.applyPaintTransform;
Function _RenderFittedBox_debugFillProperties$(
  m.Scope scope$,
  RenderFittedBox target$,
) =>
    target$.debugFillProperties;
Function RenderFractionalTranslation_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderFractionalTranslation;
Function RenderFractionalTranslation_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderFractionalTranslation;
Function _RenderFractionalTranslation_transformHitTests$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    () {
      return target$.transformHitTests;
    };
void _RenderFractionalTranslation_transformHitTests_set$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    (dynamic other$) {
      target$.transformHitTests = other$;
    };
Function _RenderFractionalTranslation_translation$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    () {
      return target$.translation;
    };
void _RenderFractionalTranslation_translation_set$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    (dynamic other$) {
      target$.translation = other$;
    };
Function _RenderFractionalTranslation__$(m.Scope scope$) => ({
      required Offset translation,
      bool? transformHitTests,
      RenderBox? child,
    }) {
      return RenderFractionalTranslation(
        child: child,
        transformHitTests: transformHitTests ?? true,
        translation: translation,
      );
    };
Function _RenderFractionalTranslation_hitTest$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    target$.hitTest;
Function _RenderFractionalTranslation_hitTestChildren$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    target$.hitTestChildren;
Function _RenderFractionalTranslation_paint$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    target$.paint;
Function _RenderFractionalTranslation_applyPaintTransform$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    target$.applyPaintTransform;
Function _RenderFractionalTranslation_debugFillProperties$(
  m.Scope scope$,
  RenderFractionalTranslation target$,
) =>
    target$.debugFillProperties;
Function RenderPointerListener_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderPointerListener;
Function RenderPointerListener_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderPointerListener;
Function _RenderPointerListener_onPointerDown$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerDown;
    };
Function _RenderPointerListener_onPointerDown_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerDown) {
      void _onPointerDownProxy(PointerDownEvent _onPointerDown_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerDown!,
            [_onPointerDown_event$],
            {},
          );
      target$.onPointerDown =
          (_onPointerDown == null ? null : _onPointerDownProxy);
    };
Function _RenderPointerListener_onPointerMove$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerMove;
    };
Function _RenderPointerListener_onPointerMove_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerMove) {
      void _onPointerMoveProxy(PointerMoveEvent _onPointerMove_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerMove!,
            [_onPointerMove_event$],
            {},
          );
      target$.onPointerMove =
          (_onPointerMove == null ? null : _onPointerMoveProxy);
    };
Function _RenderPointerListener_onPointerUp$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerUp;
    };
Function _RenderPointerListener_onPointerUp_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerUp) {
      void _onPointerUpProxy(PointerUpEvent _onPointerUp_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerUp!,
            [_onPointerUp_event$],
            {},
          );
      target$.onPointerUp = (_onPointerUp == null ? null : _onPointerUpProxy);
    };
Function _RenderPointerListener_onPointerHover$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerHover;
    };
Function _RenderPointerListener_onPointerHover_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerHover) {
      void _onPointerHoverProxy(PointerHoverEvent _onPointerHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerHover!,
            [_onPointerHover_event$],
            {},
          );
      target$.onPointerHover =
          (_onPointerHover == null ? null : _onPointerHoverProxy);
    };
Function _RenderPointerListener_onPointerCancel$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerCancel;
    };
Function _RenderPointerListener_onPointerCancel_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerCancel) {
      void _onPointerCancelProxy(PointerCancelEvent _onPointerCancel_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerCancel!,
            [_onPointerCancel_event$],
            {},
          );
      target$.onPointerCancel =
          (_onPointerCancel == null ? null : _onPointerCancelProxy);
    };
Function _RenderPointerListener_onPointerPanZoomStart$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerPanZoomStart;
    };
Function _RenderPointerListener_onPointerPanZoomStart_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerPanZoomStart) {
      void _onPointerPanZoomStartProxy(
              PointerPanZoomStartEvent _onPointerPanZoomStart_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerPanZoomStart!,
            [_onPointerPanZoomStart_event$],
            {},
          );
      target$.onPointerPanZoomStart =
          (_onPointerPanZoomStart == null ? null : _onPointerPanZoomStartProxy);
    };
Function _RenderPointerListener_onPointerPanZoomUpdate$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerPanZoomUpdate;
    };
Function _RenderPointerListener_onPointerPanZoomUpdate_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerPanZoomUpdate) {
      void _onPointerPanZoomUpdateProxy(
              PointerPanZoomUpdateEvent _onPointerPanZoomUpdate_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerPanZoomUpdate!,
            [_onPointerPanZoomUpdate_event$],
            {},
          );
      target$.onPointerPanZoomUpdate = (_onPointerPanZoomUpdate == null
          ? null
          : _onPointerPanZoomUpdateProxy);
    };
Function _RenderPointerListener_onPointerPanZoomEnd$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerPanZoomEnd;
    };
Function _RenderPointerListener_onPointerPanZoomEnd_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerPanZoomEnd) {
      void _onPointerPanZoomEndProxy(
              PointerPanZoomEndEvent _onPointerPanZoomEnd_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerPanZoomEnd!,
            [_onPointerPanZoomEnd_event$],
            {},
          );
      target$.onPointerPanZoomEnd =
          (_onPointerPanZoomEnd == null ? null : _onPointerPanZoomEndProxy);
    };
Function _RenderPointerListener_onPointerSignal$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    () {
      return target$.onPointerSignal;
    };
Function _RenderPointerListener_onPointerSignal_set$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    (m.FunctionPointer? _onPointerSignal) {
      void _onPointerSignalProxy(PointerSignalEvent _onPointerSignal_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onPointerSignal!,
            [_onPointerSignal_event$],
            {},
          );
      target$.onPointerSignal =
          (_onPointerSignal == null ? null : _onPointerSignalProxy);
    };
Function _RenderPointerListener__$(m.Scope scope$) => ({
      m.FunctionPointer? onPointerDown,
      m.FunctionPointer? onPointerMove,
      m.FunctionPointer? onPointerUp,
      m.FunctionPointer? onPointerHover,
      m.FunctionPointer? onPointerCancel,
      m.FunctionPointer? onPointerPanZoomStart,
      m.FunctionPointer? onPointerPanZoomUpdate,
      m.FunctionPointer? onPointerPanZoomEnd,
      m.FunctionPointer? onPointerSignal,
      HitTestBehavior? behavior,
      RenderBox? child,
    }) {
      void onPointerCancelProxy(PointerCancelEvent onPointerCancel_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerCancel!,
            [onPointerCancel_event$],
            {},
          );
      void onPointerDownProxy(PointerDownEvent onPointerDown_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerDown!,
            [onPointerDown_event$],
            {},
          );
      void onPointerHoverProxy(PointerHoverEvent onPointerHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerHover!,
            [onPointerHover_event$],
            {},
          );
      void onPointerMoveProxy(PointerMoveEvent onPointerMove_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerMove!,
            [onPointerMove_event$],
            {},
          );
      void onPointerPanZoomEndProxy(
              PointerPanZoomEndEvent onPointerPanZoomEnd_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomEnd!,
            [onPointerPanZoomEnd_event$],
            {},
          );
      void onPointerPanZoomStartProxy(
              PointerPanZoomStartEvent onPointerPanZoomStart_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomStart!,
            [onPointerPanZoomStart_event$],
            {},
          );
      void onPointerPanZoomUpdateProxy(
              PointerPanZoomUpdateEvent onPointerPanZoomUpdate_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerPanZoomUpdate!,
            [onPointerPanZoomUpdate_event$],
            {},
          );
      void onPointerSignalProxy(PointerSignalEvent onPointerSignal_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerSignal!,
            [onPointerSignal_event$],
            {},
          );
      void onPointerUpProxy(PointerUpEvent onPointerUp_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onPointerUp!,
            [onPointerUp_event$],
            {},
          );
      return RenderPointerListener(
        behavior: behavior ?? HitTestBehavior.deferToChild,
        child: child,
        onPointerCancel: onPointerCancel == null ? null : onPointerCancelProxy,
        onPointerDown: onPointerDown == null ? null : onPointerDownProxy,
        onPointerHover: onPointerHover == null ? null : onPointerHoverProxy,
        onPointerMove: onPointerMove == null ? null : onPointerMoveProxy,
        onPointerPanZoomEnd:
            onPointerPanZoomEnd == null ? null : onPointerPanZoomEndProxy,
        onPointerPanZoomStart:
            onPointerPanZoomStart == null ? null : onPointerPanZoomStartProxy,
        onPointerPanZoomUpdate:
            onPointerPanZoomUpdate == null ? null : onPointerPanZoomUpdateProxy,
        onPointerSignal: onPointerSignal == null ? null : onPointerSignalProxy,
        onPointerUp: onPointerUp == null ? null : onPointerUpProxy,
      );
    };
Function _RenderPointerListener_computeSizeForNoChild$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    target$.computeSizeForNoChild;
Function _RenderPointerListener_handleEvent$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    target$.handleEvent;
Function _RenderPointerListener_debugFillProperties$(
  m.Scope scope$,
  RenderPointerListener target$,
) =>
    target$.debugFillProperties;
Function RenderMouseRegion_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderMouseRegion;
Function RenderMouseRegion_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderMouseRegion;
Function _RenderMouseRegion_onEnter$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.onEnter;
    };
Function _RenderMouseRegion_onEnter_set$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    (m.FunctionPointer? _onEnter) {
      void _onEnterProxy(PointerEnterEvent _onEnter_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onEnter!,
            [_onEnter_event$],
            {},
          );
      target$.onEnter = (_onEnter == null ? null : _onEnterProxy);
    };
Function _RenderMouseRegion_onHover$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.onHover;
    };
Function _RenderMouseRegion_onHover_set$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    (m.FunctionPointer? _onHover) {
      void _onHoverProxy(PointerHoverEvent _onHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onHover!,
            [_onHover_event$],
            {},
          );
      target$.onHover = (_onHover == null ? null : _onHoverProxy);
    };
Function _RenderMouseRegion_onExit$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.onExit;
    };
Function _RenderMouseRegion_onExit_set$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    (m.FunctionPointer? _onExit) {
      void _onExitProxy(PointerExitEvent _onExit_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            _onExit!,
            [_onExit_event$],
            {},
          );
      target$.onExit = (_onExit == null ? null : _onExitProxy);
    };
Function _RenderMouseRegion_opaque$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.opaque;
    };
void _RenderMouseRegion_opaque_set$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    (dynamic other$) {
      target$.opaque = other$;
    };
Function _RenderMouseRegion_hitTestBehavior$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.hitTestBehavior;
    };
void _RenderMouseRegion_hitTestBehavior_set$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    (dynamic other$) {
      target$.hitTestBehavior = other$;
    };
Function _RenderMouseRegion_cursor$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.cursor;
    };
void _RenderMouseRegion_cursor_set$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    (dynamic other$) {
      target$.cursor = other$;
    };
Function _RenderMouseRegion_validForMouseTracker$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    () {
      return target$.validForMouseTracker;
    };
Function _RenderMouseRegion__$(m.Scope scope$) => ({
      m.FunctionPointer? onEnter,
      m.FunctionPointer? onHover,
      m.FunctionPointer? onExit,
      MouseCursor? cursor,
      bool? validForMouseTracker,
      bool? opaque,
      RenderBox? child,
      HitTestBehavior? hitTestBehavior,
    }) {
      void onEnterProxy(PointerEnterEvent onEnter_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onEnter!,
            [onEnter_event$],
            {},
          );
      void onExitProxy(PointerExitEvent onExit_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onExit!,
            [onExit_event$],
            {},
          );
      void onHoverProxy(PointerHoverEvent onHover_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHover!,
            [onHover_event$],
            {},
          );
      return RenderMouseRegion(
        child: child,
        cursor: cursor ?? MouseCursor.defer,
        hitTestBehavior: hitTestBehavior ?? HitTestBehavior.opaque,
        onEnter: onEnter == null ? null : onEnterProxy,
        onExit: onExit == null ? null : onExitProxy,
        onHover: onHover == null ? null : onHoverProxy,
        opaque: opaque ?? true,
        validForMouseTracker: validForMouseTracker ?? true,
      );
    };
Function _RenderMouseRegion_hitTest$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    target$.hitTest;
Function _RenderMouseRegion_handleEvent$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    target$.handleEvent;
Function _RenderMouseRegion_attach$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    target$.attach;
Function _RenderMouseRegion_detach$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    target$.detach;
Function _RenderMouseRegion_computeSizeForNoChild$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    target$.computeSizeForNoChild;
Function _RenderMouseRegion_debugFillProperties$(
  m.Scope scope$,
  RenderMouseRegion target$,
) =>
    target$.debugFillProperties;
Function RenderRepaintBoundary_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderRepaintBoundary;
Function RenderRepaintBoundary_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderRepaintBoundary;
Function _RenderRepaintBoundary_isRepaintBoundary$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    () {
      return target$.isRepaintBoundary;
    };
Function _RenderRepaintBoundary_debugSymmetricPaintCount$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    () {
      return target$.debugSymmetricPaintCount;
    };
Function _RenderRepaintBoundary_debugAsymmetricPaintCount$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    () {
      return target$.debugAsymmetricPaintCount;
    };
Function _RenderRepaintBoundary__$(m.Scope scope$) => ({RenderBox? child}) {
      return RenderRepaintBoundary(child: child);
    };
Function _RenderRepaintBoundary_toImage$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    target$.toImage;
Function _RenderRepaintBoundary_toImageSync$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    target$.toImageSync;
Function _RenderRepaintBoundary_debugResetMetrics$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    target$.debugResetMetrics;
Function _RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    target$.debugRegisterRepaintBoundaryPaint;
Function _RenderRepaintBoundary_debugFillProperties$(
  m.Scope scope$,
  RenderRepaintBoundary target$,
) =>
    target$.debugFillProperties;
Function RenderIgnorePointer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderIgnorePointer;
Function RenderIgnorePointer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderIgnorePointer;
Function _RenderIgnorePointer_ignoring$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    () {
      return target$.ignoring;
    };
void _RenderIgnorePointer_ignoring_set$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    (dynamic other$) {
      target$.ignoring = other$;
    };
Function _RenderIgnorePointer_ignoringSemantics$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    () {
      return target$.ignoringSemantics;
    };
void _RenderIgnorePointer_ignoringSemantics_set$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    (dynamic other$) {
      target$.ignoringSemantics = other$;
    };
Function _RenderIgnorePointer__$(m.Scope scope$) => ({
      RenderBox? child,
      bool? ignoring,
      bool? ignoringSemantics,
    }) {
      return RenderIgnorePointer(
        child: child,
        ignoring: ignoring ?? true,
        ignoringSemantics: ignoringSemantics,
      );
    };
Function _RenderIgnorePointer_hitTest$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    target$.hitTest;
Function _RenderIgnorePointer_visitChildrenForSemantics$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildrenForSemantics(visitorProxy);
    };
Function _RenderIgnorePointer_debugFillProperties$(
  m.Scope scope$,
  RenderIgnorePointer target$,
) =>
    target$.debugFillProperties;
Function RenderOffstage_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderOffstage;
Function RenderOffstage_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderOffstage;
Function _RenderOffstage_offstage$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    () {
      return target$.offstage;
    };
void _RenderOffstage_offstage_set$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    (dynamic other$) {
      target$.offstage = other$;
    };
Function _RenderOffstage_sizedByParent$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    () {
      return target$.sizedByParent;
    };
Function _RenderOffstage__$(m.Scope scope$) => ({
      bool? offstage,
      RenderBox? child,
    }) {
      return RenderOffstage(
        child: child,
        offstage: offstage ?? true,
      );
    };
Function _RenderOffstage_computeMinIntrinsicWidth$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.computeMinIntrinsicWidth;
Function _RenderOffstage_computeMaxIntrinsicWidth$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.computeMaxIntrinsicWidth;
Function _RenderOffstage_computeMinIntrinsicHeight$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.computeMinIntrinsicHeight;
Function _RenderOffstage_computeMaxIntrinsicHeight$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.computeMaxIntrinsicHeight;
Function _RenderOffstage_computeDistanceToActualBaseline$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.computeDistanceToActualBaseline;
Function _RenderOffstage_computeDryLayout$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.computeDryLayout;
Function _RenderOffstage_performResize$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.performResize;
Function _RenderOffstage_performLayout$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.performLayout;
Function _RenderOffstage_hitTest$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.hitTest;
Function _RenderOffstage_paintsChild$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.paintsChild;
Function _RenderOffstage_paint$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.paint;
Function _RenderOffstage_visitChildrenForSemantics$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildrenForSemantics(visitorProxy);
    };
Function _RenderOffstage_debugFillProperties$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.debugFillProperties;
Function _RenderOffstage_debugDescribeChildren$(
  m.Scope scope$,
  RenderOffstage target$,
) =>
    target$.debugDescribeChildren;
Function RenderAbsorbPointer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderAbsorbPointer;
Function RenderAbsorbPointer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderAbsorbPointer;
Function _RenderAbsorbPointer_absorbing$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    () {
      return target$.absorbing;
    };
void _RenderAbsorbPointer_absorbing_set$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    (dynamic other$) {
      target$.absorbing = other$;
    };
Function _RenderAbsorbPointer_ignoringSemantics$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    () {
      return target$.ignoringSemantics;
    };
void _RenderAbsorbPointer_ignoringSemantics_set$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    (dynamic other$) {
      target$.ignoringSemantics = other$;
    };
Function _RenderAbsorbPointer__$(m.Scope scope$) => ({
      RenderBox? child,
      bool? absorbing,
      bool? ignoringSemantics,
    }) {
      return RenderAbsorbPointer(
        absorbing: absorbing ?? true,
        child: child,
        ignoringSemantics: ignoringSemantics,
      );
    };
Function _RenderAbsorbPointer_hitTest$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    target$.hitTest;
Function _RenderAbsorbPointer_visitChildrenForSemantics$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildrenForSemantics(visitorProxy);
    };
Function _RenderAbsorbPointer_debugFillProperties$(
  m.Scope scope$,
  RenderAbsorbPointer target$,
) =>
    target$.debugFillProperties;
Function RenderMetaData_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderMetaData;
Function RenderMetaData_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderMetaData;
Function _RenderMetaData_metaData$(
  m.Scope scope$,
  RenderMetaData target$,
) =>
    () {
      return target$.metaData;
    };
void _RenderMetaData_metaData_set$(
  m.Scope scope$,
  RenderMetaData target$,
) =>
    (dynamic other$) {
      target$.metaData = other$;
    };
Function _RenderMetaData__$(m.Scope scope$) => ({
      dynamic? metaData,
      HitTestBehavior? behavior,
      RenderBox? child,
    }) {
      return RenderMetaData(
        behavior: behavior ?? HitTestBehavior.deferToChild,
        child: child,
        metaData: metaData,
      );
    };
Function _RenderMetaData_debugFillProperties$(
  m.Scope scope$,
  RenderMetaData target$,
) =>
    target$.debugFillProperties;
Function RenderSemanticsGestureHandler_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderSemanticsGestureHandler;
Function RenderSemanticsGestureHandler_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderSemanticsGestureHandler;
Function _RenderSemanticsGestureHandler_scrollFactor$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    () {
      return target$.scrollFactor;
    };
void _RenderSemanticsGestureHandler_scrollFactor_set$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    (dynamic other$) {
      target$.scrollFactor = other$;
    };
Function _RenderSemanticsGestureHandler_validActions$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    () {
      return target$.validActions;
    };
void _RenderSemanticsGestureHandler_validActions_set$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    (dynamic other$) {
      target$.validActions = other$;
    };
Function _RenderSemanticsGestureHandler_onTap$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    () {
      return target$.onTap;
    };
Function _RenderSemanticsGestureHandler_onTap_set$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    (m.FunctionPointer? value) {
      void valueProxy() => scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [],
            {},
          );
      target$.onTap = (value == null ? null : valueProxy);
    };
Function _RenderSemanticsGestureHandler_onLongPress$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    () {
      return target$.onLongPress;
    };
Function _RenderSemanticsGestureHandler_onLongPress_set$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    (m.FunctionPointer? value) {
      void valueProxy() => scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [],
            {},
          );
      target$.onLongPress = (value == null ? null : valueProxy);
    };
Function _RenderSemanticsGestureHandler_onHorizontalDragUpdate$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    () {
      return target$.onHorizontalDragUpdate;
    };
Function _RenderSemanticsGestureHandler_onHorizontalDragUpdate_set$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    (m.FunctionPointer? value) {
      void valueProxy(DragUpdateDetails value_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [value_details$],
            {},
          );
      target$.onHorizontalDragUpdate = (value == null ? null : valueProxy);
    };
Function _RenderSemanticsGestureHandler_onVerticalDragUpdate$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    () {
      return target$.onVerticalDragUpdate;
    };
Function _RenderSemanticsGestureHandler_onVerticalDragUpdate_set$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    (m.FunctionPointer? value) {
      void valueProxy(DragUpdateDetails value_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            value!,
            [value_details$],
            {},
          );
      target$.onVerticalDragUpdate = (value == null ? null : valueProxy);
    };
Function _RenderSemanticsGestureHandler__$(m.Scope scope$) => ({
      RenderBox? child,
      m.FunctionPointer? onTap,
      m.FunctionPointer? onLongPress,
      m.FunctionPointer? onHorizontalDragUpdate,
      m.FunctionPointer? onVerticalDragUpdate,
      double? scrollFactor,
      HitTestBehavior? behavior,
    }) {
      void onHorizontalDragUpdateProxy(
              DragUpdateDetails onHorizontalDragUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onHorizontalDragUpdate!,
            [onHorizontalDragUpdate_details$],
            {},
          );
      void onLongPressProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onLongPress!,
            [],
            {},
          );
      void onTapProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onTap!,
            [],
            {},
          );
      void onVerticalDragUpdateProxy(
              DragUpdateDetails onVerticalDragUpdate_details$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onVerticalDragUpdate!,
            [onVerticalDragUpdate_details$],
            {},
          );
      return RenderSemanticsGestureHandler(
        behavior: behavior ?? HitTestBehavior.deferToChild,
        child: child,
        onHorizontalDragUpdate:
            onHorizontalDragUpdate == null ? null : onHorizontalDragUpdateProxy,
        onLongPress: onLongPress == null ? null : onLongPressProxy,
        onTap: onTap == null ? null : onTapProxy,
        onVerticalDragUpdate:
            onVerticalDragUpdate == null ? null : onVerticalDragUpdateProxy,
        scrollFactor: scrollFactor ?? 0.8,
      );
    };
Function _RenderSemanticsGestureHandler_describeSemanticsConfiguration$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    target$.describeSemanticsConfiguration;
Function _RenderSemanticsGestureHandler_debugFillProperties$(
  m.Scope scope$,
  RenderSemanticsGestureHandler target$,
) =>
    target$.debugFillProperties;
Function RenderSemanticsAnnotations_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderSemanticsAnnotations;
Function RenderSemanticsAnnotations_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderSemanticsAnnotations;
Function _RenderSemanticsAnnotations_properties$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    () {
      return target$.properties;
    };
void _RenderSemanticsAnnotations_properties_set$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    (dynamic other$) {
      target$.properties = other$;
    };
Function _RenderSemanticsAnnotations_container$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    () {
      return target$.container;
    };
void _RenderSemanticsAnnotations_container_set$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    (dynamic other$) {
      target$.container = other$;
    };
Function _RenderSemanticsAnnotations_explicitChildNodes$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    () {
      return target$.explicitChildNodes;
    };
void _RenderSemanticsAnnotations_explicitChildNodes_set$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    (dynamic other$) {
      target$.explicitChildNodes = other$;
    };
Function _RenderSemanticsAnnotations_excludeSemantics$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    () {
      return target$.excludeSemantics;
    };
void _RenderSemanticsAnnotations_excludeSemantics_set$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    (dynamic other$) {
      target$.excludeSemantics = other$;
    };
Function _RenderSemanticsAnnotations_textDirection$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    () {
      return target$.textDirection;
    };
void _RenderSemanticsAnnotations_textDirection_set$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    (dynamic other$) {
      target$.textDirection = other$;
    };
Function _RenderSemanticsAnnotations__$(m.Scope scope$) => ({
      RenderBox? child,
      required SemanticsProperties properties,
      bool? container,
      bool? explicitChildNodes,
      bool? excludeSemantics,
      TextDirection? textDirection,
    }) {
      return RenderSemanticsAnnotations(
        child: child,
        container: container ?? false,
        excludeSemantics: excludeSemantics ?? false,
        explicitChildNodes: explicitChildNodes ?? false,
        properties: properties,
        textDirection: textDirection,
      );
    };
Function _RenderSemanticsAnnotations_visitChildrenForSemantics$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildrenForSemantics(visitorProxy);
    };
Function _RenderSemanticsAnnotations_describeSemanticsConfiguration$(
  m.Scope scope$,
  RenderSemanticsAnnotations target$,
) =>
    target$.describeSemanticsConfiguration;
Function RenderBlockSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderBlockSemantics;
Function RenderBlockSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderBlockSemantics;
Function _RenderBlockSemantics_blocking$(
  m.Scope scope$,
  RenderBlockSemantics target$,
) =>
    () {
      return target$.blocking;
    };
void _RenderBlockSemantics_blocking_set$(
  m.Scope scope$,
  RenderBlockSemantics target$,
) =>
    (dynamic other$) {
      target$.blocking = other$;
    };
Function _RenderBlockSemantics__$(m.Scope scope$) => ({
      RenderBox? child,
      bool? blocking,
    }) {
      return RenderBlockSemantics(
        blocking: blocking ?? true,
        child: child,
      );
    };
Function _RenderBlockSemantics_describeSemanticsConfiguration$(
  m.Scope scope$,
  RenderBlockSemantics target$,
) =>
    target$.describeSemanticsConfiguration;
Function _RenderBlockSemantics_debugFillProperties$(
  m.Scope scope$,
  RenderBlockSemantics target$,
) =>
    target$.debugFillProperties;
Function RenderMergeSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderMergeSemantics;
Function RenderMergeSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderMergeSemantics;
Function _RenderMergeSemantics__$(m.Scope scope$) => ({RenderBox? child}) {
      return RenderMergeSemantics(child: child);
    };
Function _RenderMergeSemantics_describeSemanticsConfiguration$(
  m.Scope scope$,
  RenderMergeSemantics target$,
) =>
    target$.describeSemanticsConfiguration;
Function RenderExcludeSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderExcludeSemantics;
Function RenderExcludeSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderExcludeSemantics;
Function _RenderExcludeSemantics_excluding$(
  m.Scope scope$,
  RenderExcludeSemantics target$,
) =>
    () {
      return target$.excluding;
    };
void _RenderExcludeSemantics_excluding_set$(
  m.Scope scope$,
  RenderExcludeSemantics target$,
) =>
    (dynamic other$) {
      target$.excluding = other$;
    };
Function _RenderExcludeSemantics__$(m.Scope scope$) => ({
      RenderBox? child,
      bool? excluding,
    }) {
      return RenderExcludeSemantics(
        child: child,
        excluding: excluding ?? true,
      );
    };
Function _RenderExcludeSemantics_visitChildrenForSemantics$(
  m.Scope scope$,
  RenderExcludeSemantics target$,
) =>
    (m.FunctionPointer visitor) {
      void visitorProxy(RenderObject visitor_child$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [visitor_child$],
            {},
          );
      target$.visitChildrenForSemantics(visitorProxy);
    };
Function _RenderExcludeSemantics_debugFillProperties$(
  m.Scope scope$,
  RenderExcludeSemantics target$,
) =>
    target$.debugFillProperties;
Function RenderIndexedSemantics_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderIndexedSemantics;
Function RenderIndexedSemantics_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderIndexedSemantics;
Function _RenderIndexedSemantics_index$(
  m.Scope scope$,
  RenderIndexedSemantics target$,
) =>
    () {
      return target$.index;
    };
void _RenderIndexedSemantics_index_set$(
  m.Scope scope$,
  RenderIndexedSemantics target$,
) =>
    (dynamic other$) {
      target$.index = other$;
    };
Function _RenderIndexedSemantics__$(m.Scope scope$) => ({
      RenderBox? child,
      required int index,
    }) {
      return RenderIndexedSemantics(
        child: child,
        index: index,
      );
    };
Function _RenderIndexedSemantics_describeSemanticsConfiguration$(
  m.Scope scope$,
  RenderIndexedSemantics target$,
) =>
    target$.describeSemanticsConfiguration;
Function _RenderIndexedSemantics_debugFillProperties$(
  m.Scope scope$,
  RenderIndexedSemantics target$,
) =>
    target$.debugFillProperties;
Function RenderLeaderLayer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderLeaderLayer;
Function RenderLeaderLayer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderLeaderLayer;
Function _RenderLeaderLayer_link$(
  m.Scope scope$,
  RenderLeaderLayer target$,
) =>
    () {
      return target$.link;
    };
void _RenderLeaderLayer_link_set$(
  m.Scope scope$,
  RenderLeaderLayer target$,
) =>
    (dynamic other$) {
      target$.link = other$;
    };
Function _RenderLeaderLayer_alwaysNeedsCompositing$(
  m.Scope scope$,
  RenderLeaderLayer target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _RenderLeaderLayer__$(m.Scope scope$) => ({
      required LayerLink link,
      RenderBox? child,
    }) {
      return RenderLeaderLayer(
        child: child,
        link: link,
      );
    };
Function _RenderLeaderLayer_performLayout$(
  m.Scope scope$,
  RenderLeaderLayer target$,
) =>
    target$.performLayout;
Function _RenderLeaderLayer_paint$(
  m.Scope scope$,
  RenderLeaderLayer target$,
) =>
    target$.paint;
Function _RenderLeaderLayer_debugFillProperties$(
  m.Scope scope$,
  RenderLeaderLayer target$,
) =>
    target$.debugFillProperties;
Function RenderFollowerLayer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderFollowerLayer;
Function RenderFollowerLayer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderFollowerLayer;
Function _RenderFollowerLayer_link$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.link;
    };
void _RenderFollowerLayer_link_set$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    (dynamic other$) {
      target$.link = other$;
    };
Function _RenderFollowerLayer_showWhenUnlinked$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.showWhenUnlinked;
    };
void _RenderFollowerLayer_showWhenUnlinked_set$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    (dynamic other$) {
      target$.showWhenUnlinked = other$;
    };
Function _RenderFollowerLayer_offset$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.offset;
    };
void _RenderFollowerLayer_offset_set$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    (dynamic other$) {
      target$.offset = other$;
    };
Function _RenderFollowerLayer_leaderAnchor$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.leaderAnchor;
    };
void _RenderFollowerLayer_leaderAnchor_set$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    (dynamic other$) {
      target$.leaderAnchor = other$;
    };
Function _RenderFollowerLayer_followerAnchor$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.followerAnchor;
    };
void _RenderFollowerLayer_followerAnchor_set$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    (dynamic other$) {
      target$.followerAnchor = other$;
    };
Function _RenderFollowerLayer_alwaysNeedsCompositing$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _RenderFollowerLayer_layer$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    () {
      return target$.layer;
    };
Function _RenderFollowerLayer__$(m.Scope scope$) => ({
      required LayerLink link,
      bool? showWhenUnlinked,
      Offset? offset,
      Alignment? leaderAnchor,
      Alignment? followerAnchor,
      RenderBox? child,
    }) {
      return RenderFollowerLayer(
        child: child,
        followerAnchor: followerAnchor ?? Alignment.topLeft,
        leaderAnchor: leaderAnchor ?? Alignment.topLeft,
        link: link,
        offset: offset ?? Offset.zero,
        showWhenUnlinked: showWhenUnlinked ?? true,
      );
    };
Function _RenderFollowerLayer_detach$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.detach;
Function _RenderFollowerLayer_getCurrentTransform$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.getCurrentTransform;
Function _RenderFollowerLayer_hitTest$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.hitTest;
Function _RenderFollowerLayer_hitTestChildren$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.hitTestChildren;
Function _RenderFollowerLayer_paint$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.paint;
Function _RenderFollowerLayer_applyPaintTransform$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.applyPaintTransform;
Function _RenderFollowerLayer_debugFillProperties$(
  m.Scope scope$,
  RenderFollowerLayer target$,
) =>
    target$.debugFillProperties;
Function RenderAnnotatedRegion_as$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RenderAnnotatedRegion<T>;
Function RenderAnnotatedRegion_is$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RenderAnnotatedRegion<T>;
Function _RenderAnnotatedRegion_alwaysNeedsCompositing$<T extends Object>(
  m.Scope scope$,
  RenderAnnotatedRegion<T> target$,
) =>
    () {
      return target$.alwaysNeedsCompositing;
    };
Function _RenderAnnotatedRegion_value$<T extends Object>(
  m.Scope scope$,
  RenderAnnotatedRegion<T> target$,
) =>
    () {
      return target$.value;
    };
void _RenderAnnotatedRegion_value_set$<T extends Object>(
  m.Scope scope$,
  RenderAnnotatedRegion target$,
) =>
    (dynamic other$) {
      target$.value = other$;
    };
Function _RenderAnnotatedRegion_sized$<T extends Object>(
  m.Scope scope$,
  RenderAnnotatedRegion<T> target$,
) =>
    () {
      return target$.sized;
    };
void _RenderAnnotatedRegion_sized_set$<T extends Object>(
  m.Scope scope$,
  RenderAnnotatedRegion target$,
) =>
    (dynamic other$) {
      target$.sized = other$;
    };
Function _RenderAnnotatedRegion__$(m.Scope scope$) => <T extends Object>({
      required dynamic value,
      required bool sized,
      RenderBox? child,
    }) {
      return RenderAnnotatedRegion<T>(
        child: child,
        sized: sized,
        value: value,
      );
    };
Function _RenderAnnotatedRegion_paint$<T extends Object>(
  m.Scope scope$,
  RenderAnnotatedRegion<T> target$,
) =>
    target$.paint;
HitTestBehavior _HitTestBehavior_deferToChild$() {
  return HitTestBehavior.deferToChild;
}

HitTestBehavior _HitTestBehavior_opaque$() {
  return HitTestBehavior.opaque;
}

HitTestBehavior _HitTestBehavior_translucent$() {
  return HitTestBehavior.translucent;
}

List<HitTestBehavior> _HitTestBehavior_values$() {
  return HitTestBehavior.values;
}

DecorationPosition _DecorationPosition_background$() {
  return DecorationPosition.background;
}

DecorationPosition _DecorationPosition_foreground$() {
  return DecorationPosition.foreground;
}

List<DecorationPosition> _DecorationPosition_values$() {
  return DecorationPosition.values;
}
