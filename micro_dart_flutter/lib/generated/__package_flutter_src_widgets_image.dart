// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/image.dart';
import 'dart:async';
import 'dart:io' show File;
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/semantics.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/binding.dart';
import 'package:flutter/src/widgets/disposable_build_context.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/localizations.dart';
import 'package:flutter/src/widgets/media_query.dart';
import 'package:flutter/src/widgets/placeholder.dart';
import 'package:flutter/src/widgets/scroll_aware_image_provider.dart';
import 'package:flutter/src/widgets/text.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/image.dart',
  {
    'createLocalImageConfiguration': _createLocalImageConfiguration$,
    'precacheImage': _precacheImage$,
  },
  {},
  {
    'Image': m.ClassMirror(
      'Image',
      {
        '#as': Image_as$,
        '#is': Image_is$,
        'image': _Image_image$,
        'frameBuilder': _Image_frameBuilder$,
        'loadingBuilder': _Image_loadingBuilder$,
        'errorBuilder': _Image_errorBuilder$,
        'width': _Image_width$,
        'height': _Image_height$,
        'color': _Image_color$,
        'opacity': _Image_opacity$,
        'filterQuality': _Image_filterQuality$,
        'colorBlendMode': _Image_colorBlendMode$,
        'fit': _Image_fit$,
        'alignment': _Image_alignment$,
        'repeat': _Image_repeat$,
        'centerSlice': _Image_centerSlice$,
        'matchTextDirection': _Image_matchTextDirection$,
        'gaplessPlayback': _Image_gaplessPlayback$,
        'semanticLabel': _Image_semanticLabel$,
        'excludeFromSemantics': _Image_excludeFromSemantics$,
        'isAntiAlias': _Image_isAntiAlias$,
        'createState': _Image_createState$,
        'debugFillProperties': _Image_debugFillProperties$,
      },
      {},
    )
  },
);
Function Image_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as Image;
Function Image_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is Image;
ImageProvider<Object> _Image_image$(Image target) {
  return target.image;
}

Widget Function(BuildContext, Widget, int?, bool)? _Image_frameBuilder$(
    Image target) {
  return target.frameBuilder;
}

Widget Function(BuildContext, Widget, ImageChunkEvent?)? _Image_loadingBuilder$(
    Image target) {
  return target.loadingBuilder;
}

Widget Function(BuildContext, Object, StackTrace?)? _Image_errorBuilder$(
    Image target) {
  return target.errorBuilder;
}

double? _Image_width$(Image target) {
  return target.width;
}

double? _Image_height$(Image target) {
  return target.height;
}

Color? _Image_color$(Image target) {
  return target.color;
}

Animation<double>? _Image_opacity$(Image target) {
  return target.opacity;
}

FilterQuality _Image_filterQuality$(Image target) {
  return target.filterQuality;
}

BlendMode? _Image_colorBlendMode$(Image target) {
  return target.colorBlendMode;
}

BoxFit? _Image_fit$(Image target) {
  return target.fit;
}

AlignmentGeometry _Image_alignment$(Image target) {
  return target.alignment;
}

ImageRepeat _Image_repeat$(Image target) {
  return target.repeat;
}

Rect? _Image_centerSlice$(Image target) {
  return target.centerSlice;
}

bool _Image_matchTextDirection$(Image target) {
  return target.matchTextDirection;
}

bool _Image_gaplessPlayback$(Image target) {
  return target.gaplessPlayback;
}

String? _Image_semanticLabel$(Image target) {
  return target.semanticLabel;
}

bool _Image_excludeFromSemantics$(Image target) {
  return target.excludeFromSemantics;
}

bool _Image_isAntiAlias$(Image target) {
  return target.isAntiAlias;
}

Function _Image_createState$(
  m.Scope scope,
  Image target,
) =>
    target.createState;
Function _Image_debugFillProperties$(
  m.Scope scope,
  Image target,
) =>
    target.debugFillProperties;
Function _createLocalImageConfiguration$(m.Scope scope) =>
    createLocalImageConfiguration;
Function _precacheImage$(m.Scope scope) => (
      ImageProvider<Object> provider,
      BuildContext context, {
      m.FunctionPointer? onError,
      Size? size,
    }) {
      void onErrorProxy(
        Object onError_exception,
        StackTrace? onError_stackTrace,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            onError!,
            [
              onError_exception,
              onError_stackTrace,
            ],
            {},
          );
      return precacheImage(
        provider,
        context,
        onError: onError == null ? null : onErrorProxy,
        size: size,
      );
    };
