// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/box_border.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/borders.dart';
import 'package:flutter/src/painting/edge_insets.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/box_border.dart',
  {
    'BoxBorder.lerp': _BoxBorder_lerp$,
    'Border.merge': _Border_merge$,
    'Border.lerp': _Border_lerp$,
    'BorderDirectional.merge': _BorderDirectional_merge$,
    'BorderDirectional.lerp': _BorderDirectional_lerp$,
    'BoxShape.rectangle': _BoxShape_rectangle$,
    'BoxShape.circle': _BoxShape_circle$,
    'BoxShape.values': _BoxShape_values$,
  },
  {},
  {
    'BoxBorder': m.ClassMirror(
      'BoxBorder',
      {
        'top': _BoxBorder_top$,
        'bottom': _BoxBorder_bottom$,
        'isUniform': _BoxBorder_isUniform$,
        'preferPaintInterior': _BoxBorder_preferPaintInterior$,
        'add': _BoxBorder_add$,
        'getInnerPath': _BoxBorder_getInnerPath$,
        'getOuterPath': _BoxBorder_getOuterPath$,
        'paintInterior': _BoxBorder_paintInterior$,
        'paint': _BoxBorder_paint$,
      },
      {},
    ),
    'Border': m.ClassMirror(
      'Border',
      {
        'top': _Border_top$,
        'right': _Border_right$,
        'bottom': _Border_bottom$,
        'left': _Border_left$,
        'dimensions': _Border_dimensions$,
        'isUniform': _Border_isUniform$,
        'hashCode': _Border_hashCode$,
        'add': _Border_add$,
        'scale': _Border_scale$,
        'lerpFrom': _Border_lerpFrom$,
        'lerpTo': _Border_lerpTo$,
        'paint': _Border_paint$,
        'toString': _Border_toString$,
      },
      {},
    ),
    'BorderDirectional': m.ClassMirror(
      'BorderDirectional',
      {
        'top': _BorderDirectional_top$,
        'start': _BorderDirectional_start$,
        'end': _BorderDirectional_end$,
        'bottom': _BorderDirectional_bottom$,
        'dimensions': _BorderDirectional_dimensions$,
        'isUniform': _BorderDirectional_isUniform$,
        'hashCode': _BorderDirectional_hashCode$,
        'add': _BorderDirectional_add$,
        'scale': _BorderDirectional_scale$,
        'lerpFrom': _BorderDirectional_lerpFrom$,
        'lerpTo': _BorderDirectional_lerpTo$,
        'paint': _BorderDirectional_paint$,
        'toString': _BorderDirectional_toString$,
      },
      {},
    ),
    'BoxShape': m.ClassMirror(
      'BoxShape',
      {},
      {},
    ),
  },
);
BorderSide _BoxBorder_top$(BoxBorder target) {
  return target.top;
}

BorderSide _BoxBorder_bottom$(BoxBorder target) {
  return target.bottom;
}

bool _BoxBorder_isUniform$(BoxBorder target) {
  return target.isUniform;
}

bool _BoxBorder_preferPaintInterior$(BoxBorder target) {
  return target.preferPaintInterior;
}

Function _BoxBorder_add$(
  m.Scope scope,
  BoxBorder target,
) =>
    target.add;
Function _BoxBorder_lerp$(m.Scope scope) => BoxBorder.lerp;
Function _BoxBorder_getInnerPath$(
  m.Scope scope,
  BoxBorder target,
) =>
    target.getInnerPath;
Function _BoxBorder_getOuterPath$(
  m.Scope scope,
  BoxBorder target,
) =>
    target.getOuterPath;
Function _BoxBorder_paintInterior$(
  m.Scope scope,
  BoxBorder target,
) =>
    target.paintInterior;
Function _BoxBorder_paint$(
  m.Scope scope,
  BoxBorder target,
) =>
    target.paint;
BorderSide _Border_top$(Border target) {
  return target.top;
}

BorderSide _Border_right$(Border target) {
  return target.right;
}

BorderSide _Border_bottom$(Border target) {
  return target.bottom;
}

BorderSide _Border_left$(Border target) {
  return target.left;
}

EdgeInsetsGeometry _Border_dimensions$(Border target) {
  return target.dimensions;
}

bool _Border_isUniform$(Border target) {
  return target.isUniform;
}

int _Border_hashCode$(Border target) {
  return target.hashCode;
}

Function _Border_merge$(m.Scope scope) => Border.merge;
Function _Border_add$(
  m.Scope scope,
  Border target,
) =>
    target.add;
Function _Border_scale$(
  m.Scope scope,
  Border target,
) =>
    target.scale;
Function _Border_lerpFrom$(
  m.Scope scope,
  Border target,
) =>
    target.lerpFrom;
Function _Border_lerpTo$(
  m.Scope scope,
  Border target,
) =>
    target.lerpTo;
Function _Border_lerp$(m.Scope scope) => Border.lerp;
Function _Border_paint$(
  m.Scope scope,
  Border target,
) =>
    target.paint;
Function _Border_toString$(
  m.Scope scope,
  Border target,
) =>
    target.toString;
BorderSide _BorderDirectional_top$(BorderDirectional target) {
  return target.top;
}

BorderSide _BorderDirectional_start$(BorderDirectional target) {
  return target.start;
}

BorderSide _BorderDirectional_end$(BorderDirectional target) {
  return target.end;
}

BorderSide _BorderDirectional_bottom$(BorderDirectional target) {
  return target.bottom;
}

EdgeInsetsGeometry _BorderDirectional_dimensions$(BorderDirectional target) {
  return target.dimensions;
}

bool _BorderDirectional_isUniform$(BorderDirectional target) {
  return target.isUniform;
}

int _BorderDirectional_hashCode$(BorderDirectional target) {
  return target.hashCode;
}

Function _BorderDirectional_merge$(m.Scope scope) => BorderDirectional.merge;
Function _BorderDirectional_add$(
  m.Scope scope,
  BorderDirectional target,
) =>
    target.add;
Function _BorderDirectional_scale$(
  m.Scope scope,
  BorderDirectional target,
) =>
    target.scale;
Function _BorderDirectional_lerpFrom$(
  m.Scope scope,
  BorderDirectional target,
) =>
    target.lerpFrom;
Function _BorderDirectional_lerpTo$(
  m.Scope scope,
  BorderDirectional target,
) =>
    target.lerpTo;
Function _BorderDirectional_lerp$(m.Scope scope) => BorderDirectional.lerp;
Function _BorderDirectional_paint$(
  m.Scope scope,
  BorderDirectional target,
) =>
    target.paint;
Function _BorderDirectional_toString$(
  m.Scope scope,
  BorderDirectional target,
) =>
    target.toString;
BoxShape _BoxShape_rectangle$() {
  return BoxShape.rectangle;
}

BoxShape _BoxShape_circle$() {
  return BoxShape.circle;
}

List<BoxShape> _BoxShape_values$() {
  return BoxShape.values;
}
