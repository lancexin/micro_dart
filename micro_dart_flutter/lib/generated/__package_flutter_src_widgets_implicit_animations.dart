// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/implicit_animations.dart';
import 'dart:ui' show TextHeightBehavior;
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/container.dart';
import 'package:flutter/src/widgets/debug.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/text.dart';
import 'package:flutter/src/widgets/ticker_provider.dart';
import 'package:flutter/src/widgets/transitions.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/implicit_animations.dart',
  {
    'BoxConstraintsTween.': _BoxConstraintsTween__$,
    'DecorationTween.': _DecorationTween__$,
    'EdgeInsetsTween.': _EdgeInsetsTween__$,
    'EdgeInsetsGeometryTween.': _EdgeInsetsGeometryTween__$,
    'BorderRadiusTween.': _BorderRadiusTween__$,
    'BorderTween.': _BorderTween__$,
    'Matrix4Tween.': _Matrix4Tween__$,
    'TextStyleTween.': _TextStyleTween__$,
    'ImplicitlyAnimatedWidgetState.forEachTween':
        _ImplicitlyAnimatedWidgetState_forEachTween$,
    'AnimatedContainer.': _AnimatedContainer__$,
    'AnimatedPadding.': _AnimatedPadding__$,
    'AnimatedAlign.': _AnimatedAlign__$,
    'AnimatedPositioned.': _AnimatedPositioned__$,
    'AnimatedPositioned.fromRect': _AnimatedPositioned_fromRect_$,
    'AnimatedPositionedDirectional.': _AnimatedPositionedDirectional__$,
    'AnimatedScale.': _AnimatedScale__$,
    'AnimatedRotation.': _AnimatedRotation__$,
    'AnimatedSlide.': _AnimatedSlide__$,
    'AnimatedOpacity.': _AnimatedOpacity__$,
    'SliverAnimatedOpacity.': _SliverAnimatedOpacity__$,
    'AnimatedDefaultTextStyle.': _AnimatedDefaultTextStyle__$,
    'AnimatedPhysicalModel.': _AnimatedPhysicalModel__$,
    'AnimatedFractionallySizedBox.': _AnimatedFractionallySizedBox__$,
  },
  {},
  {
    'BoxConstraintsTween': m.ClassMirror(
      'BoxConstraintsTween',
      {
        '#as': BoxConstraintsTween_as$,
        '#is': BoxConstraintsTween_is$,
        'lerp': _BoxConstraintsTween_lerp$,
      },
      {},
    ),
    'DecorationTween': m.ClassMirror(
      'DecorationTween',
      {
        '#as': DecorationTween_as$,
        '#is': DecorationTween_is$,
        'lerp': _DecorationTween_lerp$,
      },
      {},
    ),
    'EdgeInsetsTween': m.ClassMirror(
      'EdgeInsetsTween',
      {
        '#as': EdgeInsetsTween_as$,
        '#is': EdgeInsetsTween_is$,
        'lerp': _EdgeInsetsTween_lerp$,
      },
      {},
    ),
    'EdgeInsetsGeometryTween': m.ClassMirror(
      'EdgeInsetsGeometryTween',
      {
        '#as': EdgeInsetsGeometryTween_as$,
        '#is': EdgeInsetsGeometryTween_is$,
        'lerp': _EdgeInsetsGeometryTween_lerp$,
      },
      {},
    ),
    'BorderRadiusTween': m.ClassMirror(
      'BorderRadiusTween',
      {
        '#as': BorderRadiusTween_as$,
        '#is': BorderRadiusTween_is$,
        'lerp': _BorderRadiusTween_lerp$,
      },
      {},
    ),
    'BorderTween': m.ClassMirror(
      'BorderTween',
      {
        '#as': BorderTween_as$,
        '#is': BorderTween_is$,
        'lerp': _BorderTween_lerp$,
      },
      {},
    ),
    'Matrix4Tween': m.ClassMirror(
      'Matrix4Tween',
      {
        '#as': Matrix4Tween_as$,
        '#is': Matrix4Tween_is$,
        'lerp': _Matrix4Tween_lerp$,
      },
      {},
    ),
    'TextStyleTween': m.ClassMirror(
      'TextStyleTween',
      {
        '#as': TextStyleTween_as$,
        '#is': TextStyleTween_is$,
        'lerp': _TextStyleTween_lerp$,
      },
      {},
    ),
    'ImplicitlyAnimatedWidget': m.ClassMirror(
      'ImplicitlyAnimatedWidget',
      {
        '#as': ImplicitlyAnimatedWidget_as$,
        '#is': ImplicitlyAnimatedWidget_is$,
        'curve': _ImplicitlyAnimatedWidget_curve$,
        'duration': _ImplicitlyAnimatedWidget_duration$,
        'onEnd': _ImplicitlyAnimatedWidget_onEnd$,
        'createState': _ImplicitlyAnimatedWidget_createState$,
        'debugFillProperties': _ImplicitlyAnimatedWidget_debugFillProperties$,
      },
      {},
    ),
    'ImplicitlyAnimatedWidgetState': m.ClassMirror(
      'ImplicitlyAnimatedWidgetState',
      {
        '#as': ImplicitlyAnimatedWidgetState_as$,
        '#is': ImplicitlyAnimatedWidgetState_is$,
        'controller': _ImplicitlyAnimatedWidgetState_controller$,
        'animation': _ImplicitlyAnimatedWidgetState_animation$,
        'initState': _ImplicitlyAnimatedWidgetState_initState$,
        'didUpdateWidget': _ImplicitlyAnimatedWidgetState_didUpdateWidget$,
        'dispose': _ImplicitlyAnimatedWidgetState_dispose$,
        'didUpdateTweens': _ImplicitlyAnimatedWidgetState_didUpdateTweens$,
      },
      {},
    ),
    'AnimatedWidgetBaseState': m.ClassMirror(
      'AnimatedWidgetBaseState',
      {
        '#as': AnimatedWidgetBaseState_as$,
        '#is': AnimatedWidgetBaseState_is$,
        'initState': _AnimatedWidgetBaseState_initState$,
      },
      {},
    ),
    'AnimatedContainer': m.ClassMirror(
      'AnimatedContainer',
      {
        '#as': AnimatedContainer_as$,
        '#is': AnimatedContainer_is$,
        'child': _AnimatedContainer_child$,
        'alignment': _AnimatedContainer_alignment$,
        'padding': _AnimatedContainer_padding$,
        'decoration': _AnimatedContainer_decoration$,
        'foregroundDecoration': _AnimatedContainer_foregroundDecoration$,
        'constraints': _AnimatedContainer_constraints$,
        'margin': _AnimatedContainer_margin$,
        'transform': _AnimatedContainer_transform$,
        'transformAlignment': _AnimatedContainer_transformAlignment$,
        'clipBehavior': _AnimatedContainer_clipBehavior$,
        'createState': _AnimatedContainer_createState$,
        'debugFillProperties': _AnimatedContainer_debugFillProperties$,
      },
      {},
    ),
    'AnimatedPadding': m.ClassMirror(
      'AnimatedPadding',
      {
        '#as': AnimatedPadding_as$,
        '#is': AnimatedPadding_is$,
        'padding': _AnimatedPadding_padding$,
        'child': _AnimatedPadding_child$,
        'createState': _AnimatedPadding_createState$,
        'debugFillProperties': _AnimatedPadding_debugFillProperties$,
      },
      {},
    ),
    'AnimatedAlign': m.ClassMirror(
      'AnimatedAlign',
      {
        '#as': AnimatedAlign_as$,
        '#is': AnimatedAlign_is$,
        'alignment': _AnimatedAlign_alignment$,
        'child': _AnimatedAlign_child$,
        'heightFactor': _AnimatedAlign_heightFactor$,
        'widthFactor': _AnimatedAlign_widthFactor$,
        'createState': _AnimatedAlign_createState$,
        'debugFillProperties': _AnimatedAlign_debugFillProperties$,
      },
      {},
    ),
    'AnimatedPositioned': m.ClassMirror(
      'AnimatedPositioned',
      {
        '#as': AnimatedPositioned_as$,
        '#is': AnimatedPositioned_is$,
        'child': _AnimatedPositioned_child$,
        'left': _AnimatedPositioned_left$,
        'top': _AnimatedPositioned_top$,
        'right': _AnimatedPositioned_right$,
        'bottom': _AnimatedPositioned_bottom$,
        'width': _AnimatedPositioned_width$,
        'height': _AnimatedPositioned_height$,
        'createState': _AnimatedPositioned_createState$,
        'debugFillProperties': _AnimatedPositioned_debugFillProperties$,
      },
      {},
    ),
    'AnimatedPositionedDirectional': m.ClassMirror(
      'AnimatedPositionedDirectional',
      {
        '#as': AnimatedPositionedDirectional_as$,
        '#is': AnimatedPositionedDirectional_is$,
        'child': _AnimatedPositionedDirectional_child$,
        'start': _AnimatedPositionedDirectional_start$,
        'top': _AnimatedPositionedDirectional_top$,
        'end': _AnimatedPositionedDirectional_end$,
        'bottom': _AnimatedPositionedDirectional_bottom$,
        'width': _AnimatedPositionedDirectional_width$,
        'height': _AnimatedPositionedDirectional_height$,
        'createState': _AnimatedPositionedDirectional_createState$,
        'debugFillProperties':
            _AnimatedPositionedDirectional_debugFillProperties$,
      },
      {},
    ),
    'AnimatedScale': m.ClassMirror(
      'AnimatedScale',
      {
        '#as': AnimatedScale_as$,
        '#is': AnimatedScale_is$,
        'child': _AnimatedScale_child$,
        'scale': _AnimatedScale_scale$,
        'alignment': _AnimatedScale_alignment$,
        'filterQuality': _AnimatedScale_filterQuality$,
        'createState': _AnimatedScale_createState$,
        'debugFillProperties': _AnimatedScale_debugFillProperties$,
      },
      {},
    ),
    'AnimatedRotation': m.ClassMirror(
      'AnimatedRotation',
      {
        '#as': AnimatedRotation_as$,
        '#is': AnimatedRotation_is$,
        'child': _AnimatedRotation_child$,
        'turns': _AnimatedRotation_turns$,
        'alignment': _AnimatedRotation_alignment$,
        'filterQuality': _AnimatedRotation_filterQuality$,
        'createState': _AnimatedRotation_createState$,
        'debugFillProperties': _AnimatedRotation_debugFillProperties$,
      },
      {},
    ),
    'AnimatedSlide': m.ClassMirror(
      'AnimatedSlide',
      {
        '#as': AnimatedSlide_as$,
        '#is': AnimatedSlide_is$,
        'child': _AnimatedSlide_child$,
        'offset': _AnimatedSlide_offset$,
        'createState': _AnimatedSlide_createState$,
        'debugFillProperties': _AnimatedSlide_debugFillProperties$,
      },
      {},
    ),
    'AnimatedOpacity': m.ClassMirror(
      'AnimatedOpacity',
      {
        '#as': AnimatedOpacity_as$,
        '#is': AnimatedOpacity_is$,
        'child': _AnimatedOpacity_child$,
        'opacity': _AnimatedOpacity_opacity$,
        'alwaysIncludeSemantics': _AnimatedOpacity_alwaysIncludeSemantics$,
        'createState': _AnimatedOpacity_createState$,
        'debugFillProperties': _AnimatedOpacity_debugFillProperties$,
      },
      {},
    ),
    'SliverAnimatedOpacity': m.ClassMirror(
      'SliverAnimatedOpacity',
      {
        '#as': SliverAnimatedOpacity_as$,
        '#is': SliverAnimatedOpacity_is$,
        'sliver': _SliverAnimatedOpacity_sliver$,
        'opacity': _SliverAnimatedOpacity_opacity$,
        'alwaysIncludeSemantics':
            _SliverAnimatedOpacity_alwaysIncludeSemantics$,
        'createState': _SliverAnimatedOpacity_createState$,
        'debugFillProperties': _SliverAnimatedOpacity_debugFillProperties$,
      },
      {},
    ),
    'AnimatedDefaultTextStyle': m.ClassMirror(
      'AnimatedDefaultTextStyle',
      {
        '#as': AnimatedDefaultTextStyle_as$,
        '#is': AnimatedDefaultTextStyle_is$,
        'child': _AnimatedDefaultTextStyle_child$,
        'style': _AnimatedDefaultTextStyle_style$,
        'textAlign': _AnimatedDefaultTextStyle_textAlign$,
        'softWrap': _AnimatedDefaultTextStyle_softWrap$,
        'overflow': _AnimatedDefaultTextStyle_overflow$,
        'maxLines': _AnimatedDefaultTextStyle_maxLines$,
        'textWidthBasis': _AnimatedDefaultTextStyle_textWidthBasis$,
        'textHeightBehavior': _AnimatedDefaultTextStyle_textHeightBehavior$,
        'createState': _AnimatedDefaultTextStyle_createState$,
        'debugFillProperties': _AnimatedDefaultTextStyle_debugFillProperties$,
      },
      {},
    ),
    'AnimatedPhysicalModel': m.ClassMirror(
      'AnimatedPhysicalModel',
      {
        '#as': AnimatedPhysicalModel_as$,
        '#is': AnimatedPhysicalModel_is$,
        'child': _AnimatedPhysicalModel_child$,
        'shape': _AnimatedPhysicalModel_shape$,
        'clipBehavior': _AnimatedPhysicalModel_clipBehavior$,
        'borderRadius': _AnimatedPhysicalModel_borderRadius$,
        'elevation': _AnimatedPhysicalModel_elevation$,
        'color': _AnimatedPhysicalModel_color$,
        'animateColor': _AnimatedPhysicalModel_animateColor$,
        'shadowColor': _AnimatedPhysicalModel_shadowColor$,
        'animateShadowColor': _AnimatedPhysicalModel_animateShadowColor$,
        'createState': _AnimatedPhysicalModel_createState$,
        'debugFillProperties': _AnimatedPhysicalModel_debugFillProperties$,
      },
      {},
    ),
    'AnimatedFractionallySizedBox': m.ClassMirror(
      'AnimatedFractionallySizedBox',
      {
        '#as': AnimatedFractionallySizedBox_as$,
        '#is': AnimatedFractionallySizedBox_is$,
        'child': _AnimatedFractionallySizedBox_child$,
        'heightFactor': _AnimatedFractionallySizedBox_heightFactor$,
        'widthFactor': _AnimatedFractionallySizedBox_widthFactor$,
        'alignment': _AnimatedFractionallySizedBox_alignment$,
        'createState': _AnimatedFractionallySizedBox_createState$,
        'debugFillProperties':
            _AnimatedFractionallySizedBox_debugFillProperties$,
      },
      {},
    ),
  },
);
Function BoxConstraintsTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BoxConstraintsTween;
Function BoxConstraintsTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BoxConstraintsTween;
Function _BoxConstraintsTween__$(m.Scope scope$) => ({
      BoxConstraints? begin,
      BoxConstraints? end,
    }) {
      return BoxConstraintsTween(
        begin: begin,
        end: end,
      );
    };
Function _BoxConstraintsTween_lerp$(
  m.Scope scope$,
  BoxConstraintsTween target$,
) =>
    target$.lerp;
Function DecorationTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DecorationTween;
Function DecorationTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DecorationTween;
Function _DecorationTween__$(m.Scope scope$) => ({
      Decoration? begin,
      Decoration? end,
    }) {
      return DecorationTween(
        begin: begin,
        end: end,
      );
    };
Function _DecorationTween_lerp$(
  m.Scope scope$,
  DecorationTween target$,
) =>
    target$.lerp;
Function EdgeInsetsTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as EdgeInsetsTween;
Function EdgeInsetsTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is EdgeInsetsTween;
Function _EdgeInsetsTween__$(m.Scope scope$) => ({
      EdgeInsets? begin,
      EdgeInsets? end,
    }) {
      return EdgeInsetsTween(
        begin: begin,
        end: end,
      );
    };
Function _EdgeInsetsTween_lerp$(
  m.Scope scope$,
  EdgeInsetsTween target$,
) =>
    target$.lerp;
Function EdgeInsetsGeometryTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as EdgeInsetsGeometryTween;
Function EdgeInsetsGeometryTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is EdgeInsetsGeometryTween;
Function _EdgeInsetsGeometryTween__$(m.Scope scope$) => ({
      EdgeInsetsGeometry? begin,
      EdgeInsetsGeometry? end,
    }) {
      return EdgeInsetsGeometryTween(
        begin: begin,
        end: end,
      );
    };
Function _EdgeInsetsGeometryTween_lerp$(
  m.Scope scope$,
  EdgeInsetsGeometryTween target$,
) =>
    target$.lerp;
Function BorderRadiusTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BorderRadiusTween;
Function BorderRadiusTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BorderRadiusTween;
Function _BorderRadiusTween__$(m.Scope scope$) => ({
      BorderRadius? begin,
      BorderRadius? end,
    }) {
      return BorderRadiusTween(
        begin: begin,
        end: end,
      );
    };
Function _BorderRadiusTween_lerp$(
  m.Scope scope$,
  BorderRadiusTween target$,
) =>
    target$.lerp;
Function BorderTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as BorderTween;
Function BorderTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is BorderTween;
Function _BorderTween__$(m.Scope scope$) => ({
      Border? begin,
      Border? end,
    }) {
      return BorderTween(
        begin: begin,
        end: end,
      );
    };
Function _BorderTween_lerp$(
  m.Scope scope$,
  BorderTween target$,
) =>
    target$.lerp;
Function Matrix4Tween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Matrix4Tween;
Function Matrix4Tween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Matrix4Tween;
Function _Matrix4Tween__$(m.Scope scope$) => ({
      Matrix4? begin,
      Matrix4? end,
    }) {
      return Matrix4Tween(
        begin: begin,
        end: end,
      );
    };
Function _Matrix4Tween_lerp$(
  m.Scope scope$,
  Matrix4Tween target$,
) =>
    target$.lerp;
Function TextStyleTween_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TextStyleTween;
Function TextStyleTween_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TextStyleTween;
Function _TextStyleTween__$(m.Scope scope$) => ({
      TextStyle? begin,
      TextStyle? end,
    }) {
      return TextStyleTween(
        begin: begin,
        end: end,
      );
    };
Function _TextStyleTween_lerp$(
  m.Scope scope$,
  TextStyleTween target$,
) =>
    target$.lerp;
Function ImplicitlyAnimatedWidget_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImplicitlyAnimatedWidget;
Function ImplicitlyAnimatedWidget_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImplicitlyAnimatedWidget;
Function _ImplicitlyAnimatedWidget_curve$(
  m.Scope scope$,
  ImplicitlyAnimatedWidget target$,
) =>
    () {
      return target$.curve;
    };
Function _ImplicitlyAnimatedWidget_duration$(
  m.Scope scope$,
  ImplicitlyAnimatedWidget target$,
) =>
    () {
      return target$.duration;
    };
Function _ImplicitlyAnimatedWidget_onEnd$(
  m.Scope scope$,
  ImplicitlyAnimatedWidget target$,
) =>
    () {
      return target$.onEnd;
    };
Function _ImplicitlyAnimatedWidget_createState$(
  m.Scope scope$,
  ImplicitlyAnimatedWidget target$,
) =>
    target$.createState;
Function _ImplicitlyAnimatedWidget_debugFillProperties$(
  m.Scope scope$,
  ImplicitlyAnimatedWidget target$,
) =>
    target$.debugFillProperties;
Function ImplicitlyAnimatedWidgetState_as$<T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImplicitlyAnimatedWidgetState<T>;
Function ImplicitlyAnimatedWidgetState_is$<T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImplicitlyAnimatedWidgetState<T>;
Function _ImplicitlyAnimatedWidgetState_controller$<
        T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState<T> target$,
) =>
    () {
      return target$.controller;
    };
Function _ImplicitlyAnimatedWidgetState_animation$<
        T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState<T> target$,
) =>
    () {
      return target$.animation;
    };
Function _ImplicitlyAnimatedWidgetState_initState$<
        T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState<T> target$,
) =>
    target$.initState;
Function _ImplicitlyAnimatedWidgetState_didUpdateWidget$<
        T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState<T> target$,
) =>
    target$.didUpdateWidget;
Function
    _ImplicitlyAnimatedWidgetState_dispose$<T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState<T> target$,
) =>
        target$.dispose;
Function _ImplicitlyAnimatedWidgetState_forEachTween$(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState target$,
) =>
    <T extends ImplicitlyAnimatedWidget>(m.FunctionPointer visitor) {
      Tween<dynamic>? visitorProxy(
        Tween<dynamic>? visitor_tween$,
        dynamic visitor_targetValue$,
        Tween<dynamic> Function(dynamic) visitor_constructor$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            visitor,
            [
              visitor_tween$,
              visitor_targetValue$,
              visitor_constructor$,
            ],
            {},
          );
      target$.forEachTween(visitorProxy);
    };
Function _ImplicitlyAnimatedWidgetState_didUpdateTweens$<
        T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  ImplicitlyAnimatedWidgetState<T> target$,
) =>
    target$.didUpdateTweens;
Function AnimatedWidgetBaseState_as$<T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedWidgetBaseState<T>;
Function AnimatedWidgetBaseState_is$<T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedWidgetBaseState<T>;
Function
    _AnimatedWidgetBaseState_initState$<T extends ImplicitlyAnimatedWidget>(
  m.Scope scope$,
  AnimatedWidgetBaseState<T> target$,
) =>
        target$.initState;
Function AnimatedContainer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedContainer;
Function AnimatedContainer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedContainer;
Function _AnimatedContainer_child$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedContainer_alignment$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.alignment;
    };
Function _AnimatedContainer_padding$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.padding;
    };
Function _AnimatedContainer_decoration$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.decoration;
    };
Function _AnimatedContainer_foregroundDecoration$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.foregroundDecoration;
    };
Function _AnimatedContainer_constraints$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.constraints;
    };
Function _AnimatedContainer_margin$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.margin;
    };
Function _AnimatedContainer_transform$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.transform;
    };
Function _AnimatedContainer_transformAlignment$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.transformAlignment;
    };
Function _AnimatedContainer_clipBehavior$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _AnimatedContainer__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      EdgeInsetsGeometry? padding,
      Color? color,
      Decoration? decoration,
      Decoration? foregroundDecoration,
      double? width,
      double? height,
      BoxConstraints? constraints,
      EdgeInsetsGeometry? margin,
      Matrix4? transform,
      AlignmentGeometry? transformAlignment,
      Widget? child,
      Clip? clipBehavior,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedContainer(
        alignment: alignment,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        color: color,
        constraints: constraints,
        curve: curve ?? Curves.linear,
        decoration: decoration,
        duration: duration,
        foregroundDecoration: foregroundDecoration,
        height: height,
        key: key,
        margin: margin,
        onEnd: onEnd == null ? null : onEndProxy,
        padding: padding,
        transform: transform,
        transformAlignment: transformAlignment,
        width: width,
      );
    };
Function _AnimatedContainer_createState$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    target$.createState;
Function _AnimatedContainer_debugFillProperties$(
  m.Scope scope$,
  AnimatedContainer target$,
) =>
    target$.debugFillProperties;
Function AnimatedPadding_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedPadding;
Function AnimatedPadding_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedPadding;
Function _AnimatedPadding_padding$(
  m.Scope scope$,
  AnimatedPadding target$,
) =>
    () {
      return target$.padding;
    };
Function _AnimatedPadding_child$(
  m.Scope scope$,
  AnimatedPadding target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedPadding__$(m.Scope scope$) => ({
      Key? key,
      required EdgeInsetsGeometry padding,
      Widget? child,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedPadding(
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        padding: padding,
      );
    };
Function _AnimatedPadding_createState$(
  m.Scope scope$,
  AnimatedPadding target$,
) =>
    target$.createState;
Function _AnimatedPadding_debugFillProperties$(
  m.Scope scope$,
  AnimatedPadding target$,
) =>
    target$.debugFillProperties;
Function AnimatedAlign_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedAlign;
Function AnimatedAlign_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedAlign;
Function _AnimatedAlign_alignment$(
  m.Scope scope$,
  AnimatedAlign target$,
) =>
    () {
      return target$.alignment;
    };
Function _AnimatedAlign_child$(
  m.Scope scope$,
  AnimatedAlign target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedAlign_heightFactor$(
  m.Scope scope$,
  AnimatedAlign target$,
) =>
    () {
      return target$.heightFactor;
    };
Function _AnimatedAlign_widthFactor$(
  m.Scope scope$,
  AnimatedAlign target$,
) =>
    () {
      return target$.widthFactor;
    };
Function _AnimatedAlign__$(m.Scope scope$) => ({
      Key? key,
      required AlignmentGeometry alignment,
      Widget? child,
      double? heightFactor,
      double? widthFactor,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedAlign(
        alignment: alignment,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        heightFactor: heightFactor,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        widthFactor: widthFactor,
      );
    };
Function _AnimatedAlign_createState$(
  m.Scope scope$,
  AnimatedAlign target$,
) =>
    target$.createState;
Function _AnimatedAlign_debugFillProperties$(
  m.Scope scope$,
  AnimatedAlign target$,
) =>
    target$.debugFillProperties;
Function AnimatedPositioned_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedPositioned;
Function AnimatedPositioned_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedPositioned;
Function _AnimatedPositioned_child$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedPositioned_left$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.left;
    };
Function _AnimatedPositioned_top$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.top;
    };
Function _AnimatedPositioned_right$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.right;
    };
Function _AnimatedPositioned_bottom$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.bottom;
    };
Function _AnimatedPositioned_width$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.width;
    };
Function _AnimatedPositioned_height$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    () {
      return target$.height;
    };
Function _AnimatedPositioned__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      double? left,
      double? top,
      double? right,
      double? bottom,
      double? width,
      double? height,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedPositioned(
        bottom: bottom,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        height: height,
        key: key,
        left: left,
        onEnd: onEnd == null ? null : onEndProxy,
        right: right,
        top: top,
        width: width,
      );
    };
Function _AnimatedPositioned_fromRect_$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      required Rect rect,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedPositioned.fromRect(
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        rect: rect,
      );
    };
Function _AnimatedPositioned_createState$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    target$.createState;
Function _AnimatedPositioned_debugFillProperties$(
  m.Scope scope$,
  AnimatedPositioned target$,
) =>
    target$.debugFillProperties;
Function AnimatedPositionedDirectional_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedPositionedDirectional;
Function AnimatedPositionedDirectional_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedPositionedDirectional;
Function _AnimatedPositionedDirectional_child$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedPositionedDirectional_start$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.start;
    };
Function _AnimatedPositionedDirectional_top$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.top;
    };
Function _AnimatedPositionedDirectional_end$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.end;
    };
Function _AnimatedPositionedDirectional_bottom$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.bottom;
    };
Function _AnimatedPositionedDirectional_width$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.width;
    };
Function _AnimatedPositionedDirectional_height$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    () {
      return target$.height;
    };
Function _AnimatedPositionedDirectional__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      double? start,
      double? top,
      double? end,
      double? bottom,
      double? width,
      double? height,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedPositionedDirectional(
        bottom: bottom,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        end: end,
        height: height,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        start: start,
        top: top,
        width: width,
      );
    };
Function _AnimatedPositionedDirectional_createState$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    target$.createState;
Function _AnimatedPositionedDirectional_debugFillProperties$(
  m.Scope scope$,
  AnimatedPositionedDirectional target$,
) =>
    target$.debugFillProperties;
Function AnimatedScale_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedScale;
Function AnimatedScale_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedScale;
Function _AnimatedScale_child$(
  m.Scope scope$,
  AnimatedScale target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedScale_scale$(
  m.Scope scope$,
  AnimatedScale target$,
) =>
    () {
      return target$.scale;
    };
Function _AnimatedScale_alignment$(
  m.Scope scope$,
  AnimatedScale target$,
) =>
    () {
      return target$.alignment;
    };
Function _AnimatedScale_filterQuality$(
  m.Scope scope$,
  AnimatedScale target$,
) =>
    () {
      return target$.filterQuality;
    };
Function _AnimatedScale__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      required double scale,
      Alignment? alignment,
      FilterQuality? filterQuality,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedScale(
        alignment: alignment ?? Alignment.center,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        filterQuality: filterQuality,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        scale: scale,
      );
    };
Function _AnimatedScale_createState$(
  m.Scope scope$,
  AnimatedScale target$,
) =>
    target$.createState;
Function _AnimatedScale_debugFillProperties$(
  m.Scope scope$,
  AnimatedScale target$,
) =>
    target$.debugFillProperties;
Function AnimatedRotation_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedRotation;
Function AnimatedRotation_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedRotation;
Function _AnimatedRotation_child$(
  m.Scope scope$,
  AnimatedRotation target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedRotation_turns$(
  m.Scope scope$,
  AnimatedRotation target$,
) =>
    () {
      return target$.turns;
    };
Function _AnimatedRotation_alignment$(
  m.Scope scope$,
  AnimatedRotation target$,
) =>
    () {
      return target$.alignment;
    };
Function _AnimatedRotation_filterQuality$(
  m.Scope scope$,
  AnimatedRotation target$,
) =>
    () {
      return target$.filterQuality;
    };
Function _AnimatedRotation__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      required double turns,
      Alignment? alignment,
      FilterQuality? filterQuality,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedRotation(
        alignment: alignment ?? Alignment.center,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        filterQuality: filterQuality,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        turns: turns,
      );
    };
Function _AnimatedRotation_createState$(
  m.Scope scope$,
  AnimatedRotation target$,
) =>
    target$.createState;
Function _AnimatedRotation_debugFillProperties$(
  m.Scope scope$,
  AnimatedRotation target$,
) =>
    target$.debugFillProperties;
Function AnimatedSlide_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedSlide;
Function AnimatedSlide_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedSlide;
Function _AnimatedSlide_child$(
  m.Scope scope$,
  AnimatedSlide target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedSlide_offset$(
  m.Scope scope$,
  AnimatedSlide target$,
) =>
    () {
      return target$.offset;
    };
Function _AnimatedSlide__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      required Offset offset,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedSlide(
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        key: key,
        offset: offset,
        onEnd: onEnd == null ? null : onEndProxy,
      );
    };
Function _AnimatedSlide_createState$(
  m.Scope scope$,
  AnimatedSlide target$,
) =>
    target$.createState;
Function _AnimatedSlide_debugFillProperties$(
  m.Scope scope$,
  AnimatedSlide target$,
) =>
    target$.debugFillProperties;
Function AnimatedOpacity_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedOpacity;
Function AnimatedOpacity_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedOpacity;
Function _AnimatedOpacity_child$(
  m.Scope scope$,
  AnimatedOpacity target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedOpacity_opacity$(
  m.Scope scope$,
  AnimatedOpacity target$,
) =>
    () {
      return target$.opacity;
    };
Function _AnimatedOpacity_alwaysIncludeSemantics$(
  m.Scope scope$,
  AnimatedOpacity target$,
) =>
    () {
      return target$.alwaysIncludeSemantics;
    };
Function _AnimatedOpacity__$(m.Scope scope$) => ({
      Key? key,
      Widget? child,
      required double opacity,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
      bool? alwaysIncludeSemantics,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedOpacity(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        opacity: opacity,
      );
    };
Function _AnimatedOpacity_createState$(
  m.Scope scope$,
  AnimatedOpacity target$,
) =>
    target$.createState;
Function _AnimatedOpacity_debugFillProperties$(
  m.Scope scope$,
  AnimatedOpacity target$,
) =>
    target$.debugFillProperties;
Function SliverAnimatedOpacity_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SliverAnimatedOpacity;
Function SliverAnimatedOpacity_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SliverAnimatedOpacity;
Function _SliverAnimatedOpacity_sliver$(
  m.Scope scope$,
  SliverAnimatedOpacity target$,
) =>
    () {
      return target$.sliver;
    };
Function _SliverAnimatedOpacity_opacity$(
  m.Scope scope$,
  SliverAnimatedOpacity target$,
) =>
    () {
      return target$.opacity;
    };
Function _SliverAnimatedOpacity_alwaysIncludeSemantics$(
  m.Scope scope$,
  SliverAnimatedOpacity target$,
) =>
    () {
      return target$.alwaysIncludeSemantics;
    };
Function _SliverAnimatedOpacity__$(m.Scope scope$) => ({
      Key? key,
      Widget? sliver,
      required double opacity,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
      bool? alwaysIncludeSemantics,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return SliverAnimatedOpacity(
        alwaysIncludeSemantics: alwaysIncludeSemantics ?? false,
        curve: curve ?? Curves.linear,
        duration: duration,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        opacity: opacity,
        sliver: sliver,
      );
    };
Function _SliverAnimatedOpacity_createState$(
  m.Scope scope$,
  SliverAnimatedOpacity target$,
) =>
    target$.createState;
Function _SliverAnimatedOpacity_debugFillProperties$(
  m.Scope scope$,
  SliverAnimatedOpacity target$,
) =>
    target$.debugFillProperties;
Function AnimatedDefaultTextStyle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedDefaultTextStyle;
Function AnimatedDefaultTextStyle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedDefaultTextStyle;
Function _AnimatedDefaultTextStyle_child$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedDefaultTextStyle_style$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.style;
    };
Function _AnimatedDefaultTextStyle_textAlign$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.textAlign;
    };
Function _AnimatedDefaultTextStyle_softWrap$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.softWrap;
    };
Function _AnimatedDefaultTextStyle_overflow$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.overflow;
    };
Function _AnimatedDefaultTextStyle_maxLines$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.maxLines;
    };
Function _AnimatedDefaultTextStyle_textWidthBasis$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.textWidthBasis;
    };
Function _AnimatedDefaultTextStyle_textHeightBehavior$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    () {
      return target$.textHeightBehavior;
    };
Function _AnimatedDefaultTextStyle__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      required TextStyle style,
      TextAlign? textAlign,
      bool? softWrap,
      TextOverflow? overflow,
      int? maxLines,
      TextWidthBasis? textWidthBasis,
      TextHeightBehavior? textHeightBehavior,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedDefaultTextStyle(
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        key: key,
        maxLines: maxLines,
        onEnd: onEnd == null ? null : onEndProxy,
        overflow: overflow ?? TextOverflow.clip,
        softWrap: softWrap ?? true,
        style: style,
        textAlign: textAlign,
        textHeightBehavior: textHeightBehavior,
        textWidthBasis: textWidthBasis ?? TextWidthBasis.parent,
      );
    };
Function _AnimatedDefaultTextStyle_createState$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    target$.createState;
Function _AnimatedDefaultTextStyle_debugFillProperties$(
  m.Scope scope$,
  AnimatedDefaultTextStyle target$,
) =>
    target$.debugFillProperties;
Function AnimatedPhysicalModel_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedPhysicalModel;
Function AnimatedPhysicalModel_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedPhysicalModel;
Function _AnimatedPhysicalModel_child$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedPhysicalModel_shape$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.shape;
    };
Function _AnimatedPhysicalModel_clipBehavior$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.clipBehavior;
    };
Function _AnimatedPhysicalModel_borderRadius$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.borderRadius;
    };
Function _AnimatedPhysicalModel_elevation$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.elevation;
    };
Function _AnimatedPhysicalModel_color$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.color;
    };
Function _AnimatedPhysicalModel_animateColor$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.animateColor;
    };
Function _AnimatedPhysicalModel_shadowColor$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.shadowColor;
    };
Function _AnimatedPhysicalModel_animateShadowColor$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    () {
      return target$.animateShadowColor;
    };
Function _AnimatedPhysicalModel__$(m.Scope scope$) => ({
      Key? key,
      required Widget child,
      required BoxShape shape,
      Clip? clipBehavior,
      BorderRadius? borderRadius,
      required double elevation,
      required Color color,
      bool? animateColor,
      required Color shadowColor,
      bool? animateShadowColor,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedPhysicalModel(
        animateColor: animateColor ?? true,
        animateShadowColor: animateShadowColor ?? true,
        borderRadius: borderRadius ?? BorderRadius.zero,
        child: child,
        clipBehavior: clipBehavior ?? Clip.none,
        color: color,
        curve: curve ?? Curves.linear,
        duration: duration,
        elevation: elevation,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        shadowColor: shadowColor,
        shape: shape,
      );
    };
Function _AnimatedPhysicalModel_createState$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    target$.createState;
Function _AnimatedPhysicalModel_debugFillProperties$(
  m.Scope scope$,
  AnimatedPhysicalModel target$,
) =>
    target$.debugFillProperties;
Function AnimatedFractionallySizedBox_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AnimatedFractionallySizedBox;
Function AnimatedFractionallySizedBox_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AnimatedFractionallySizedBox;
Function _AnimatedFractionallySizedBox_child$(
  m.Scope scope$,
  AnimatedFractionallySizedBox target$,
) =>
    () {
      return target$.child;
    };
Function _AnimatedFractionallySizedBox_heightFactor$(
  m.Scope scope$,
  AnimatedFractionallySizedBox target$,
) =>
    () {
      return target$.heightFactor;
    };
Function _AnimatedFractionallySizedBox_widthFactor$(
  m.Scope scope$,
  AnimatedFractionallySizedBox target$,
) =>
    () {
      return target$.widthFactor;
    };
Function _AnimatedFractionallySizedBox_alignment$(
  m.Scope scope$,
  AnimatedFractionallySizedBox target$,
) =>
    () {
      return target$.alignment;
    };
Function _AnimatedFractionallySizedBox__$(m.Scope scope$) => ({
      Key? key,
      AlignmentGeometry? alignment,
      Widget? child,
      double? heightFactor,
      double? widthFactor,
      Curve? curve,
      required Duration duration,
      m.FunctionPointer? onEnd,
    }) {
      void onEndProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onEnd!,
            [],
            {},
          );
      return AnimatedFractionallySizedBox(
        alignment: alignment ?? Alignment.center,
        child: child,
        curve: curve ?? Curves.linear,
        duration: duration,
        heightFactor: heightFactor,
        key: key,
        onEnd: onEnd == null ? null : onEndProxy,
        widthFactor: widthFactor,
      );
    };
Function _AnimatedFractionallySizedBox_createState$(
  m.Scope scope$,
  AnimatedFractionallySizedBox target$,
) =>
    target$.createState;
Function _AnimatedFractionallySizedBox_debugFillProperties$(
  m.Scope scope$,
  AnimatedFractionallySizedBox target$,
) =>
    target$.debugFillProperties;
