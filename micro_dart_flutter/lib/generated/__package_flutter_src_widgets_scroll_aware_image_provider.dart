// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/scroll_aware_image_provider.dart';
import 'dart:ui';
import 'dart:typed_data';
import 'dart:async';
import 'package:flutter/painting.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/src/widgets/disposable_build_context.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/scrollable.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/scroll_aware_image_provider.dart',
  {'ScrollAwareImageProvider.': _ScrollAwareImageProvider__$},
  {},
  {
    'ScrollAwareImageProvider': m.ClassMirror(
      'ScrollAwareImageProvider',
      {
        '#as': ScrollAwareImageProvider_as$,
        '#is': ScrollAwareImageProvider_is$,
        'context': _ScrollAwareImageProvider_context$,
        'imageProvider': _ScrollAwareImageProvider_imageProvider$,
        'resolveStreamForKey': _ScrollAwareImageProvider_resolveStreamForKey$,
        'load': _ScrollAwareImageProvider_load$,
        'loadBuffer': _ScrollAwareImageProvider_loadBuffer$,
        'loadImage': _ScrollAwareImageProvider_loadImage$,
        'obtainKey': _ScrollAwareImageProvider_obtainKey$,
      },
      {},
    )
  },
);
Function ScrollAwareImageProvider_as$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ScrollAwareImageProvider<T>;
Function ScrollAwareImageProvider_is$<T extends Object>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ScrollAwareImageProvider<T>;
Function _ScrollAwareImageProvider_context$<T extends Object>(
  m.Scope scope$,
  ScrollAwareImageProvider<T> target$,
) =>
    () {
      return target$.context;
    };
Function _ScrollAwareImageProvider_imageProvider$<T extends Object>(
  m.Scope scope$,
  ScrollAwareImageProvider<T> target$,
) =>
    () {
      return target$.imageProvider;
    };
Function _ScrollAwareImageProvider__$(m.Scope scope$) => <T extends Object>({
      required DisposableBuildContext<State<StatefulWidget>> context,
      required ImageProvider<T> imageProvider,
    }) {
      return ScrollAwareImageProvider<T>(
        context: context,
        imageProvider: imageProvider,
      );
    };
Function _ScrollAwareImageProvider_resolveStreamForKey$(
  m.Scope scope$,
  ScrollAwareImageProvider target$,
) =>
    <T extends Object>(
      ImageConfiguration configuration,
      ImageStream stream,
      dynamic key,
      m.FunctionPointer handleError,
    ) {
      void handleErrorProxy(
        Object handleError_exception$,
        StackTrace? handleError_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleError,
            [
              handleError_exception$,
              handleError_stackTrace$,
            ],
            {},
          );
      target$.resolveStreamForKey(
        configuration,
        stream,
        key,
        handleErrorProxy,
      );
    };
Function _ScrollAwareImageProvider_load$(
  m.Scope scope$,
  ScrollAwareImageProvider target$,
) =>
    <T extends Object>(
      dynamic key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        Uint8List decode_buffer$, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            decode,
            [decode_buffer$],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target$.load(
        key,
        decodeProxy,
      );
    };
Function _ScrollAwareImageProvider_loadBuffer$(
  m.Scope scope$,
  ScrollAwareImageProvider target$,
) =>
    <T extends Object>(
      dynamic key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer$, {
        bool? allowUpscaling,
        int? cacheHeight,
        int? cacheWidth,
      }) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            decode,
            [decode_buffer$],
            {
              'allowUpscaling': allowUpscaling,
              'cacheHeight': cacheHeight,
              'cacheWidth': cacheWidth,
            },
          );
      return target$.loadBuffer(
        key,
        decodeProxy,
      );
    };
Function _ScrollAwareImageProvider_loadImage$(
  m.Scope scope$,
  ScrollAwareImageProvider target$,
) =>
    <T extends Object>(
      dynamic key,
      m.FunctionPointer decode,
    ) {
      Future<Codec> decodeProxy(
        ImmutableBuffer decode_buffer$, {
        TargetImageSize Function(int, int)? getTargetSize,
      }) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            decode,
            [decode_buffer$],
            {'getTargetSize': getTargetSize},
          );
      return target$.loadImage(
        key,
        decodeProxy,
      );
    };
Function _ScrollAwareImageProvider_obtainKey$<T extends Object>(
  m.Scope scope$,
  ScrollAwareImageProvider<T> target$,
) =>
    target$.obtainKey;
