// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/image_stream.dart';
import 'dart:async';
import 'dart:ui' show Codec, FrameInfo, Image;
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/image_stream.dart',
  {},
  {},
  {
    'ImageInfo': m.ClassMirror(
      'ImageInfo',
      {
        'image': _ImageInfo_image$,
        'scale': _ImageInfo_scale$,
        'debugLabel': _ImageInfo_debugLabel$,
        'sizeBytes': _ImageInfo_sizeBytes$,
        'hashCode': _ImageInfo_hashCode$,
        'clone': _ImageInfo_clone$,
        'isCloneOf': _ImageInfo_isCloneOf$,
        'dispose': _ImageInfo_dispose$,
        'toString': _ImageInfo_toString$,
      },
      {},
    ),
    'ImageStreamListener': m.ClassMirror(
      'ImageStreamListener',
      {
        'onImage': _ImageStreamListener_onImage$,
        'onChunk': _ImageStreamListener_onChunk$,
        'onError': _ImageStreamListener_onError$,
        'hashCode': _ImageStreamListener_hashCode$,
      },
      {},
    ),
    'ImageChunkEvent': m.ClassMirror(
      'ImageChunkEvent',
      {
        'cumulativeBytesLoaded': _ImageChunkEvent_cumulativeBytesLoaded$,
        'expectedTotalBytes': _ImageChunkEvent_expectedTotalBytes$,
        'debugFillProperties': _ImageChunkEvent_debugFillProperties$,
      },
      {},
    ),
    'ImageStream': m.ClassMirror(
      'ImageStream',
      {
        'completer': _ImageStream_completer$,
        'key': _ImageStream_key$,
        'setCompleter': _ImageStream_setCompleter$,
        'addListener': _ImageStream_addListener$,
        'removeListener': _ImageStream_removeListener$,
        'debugFillProperties': _ImageStream_debugFillProperties$,
      },
      {},
    ),
    'ImageStreamCompleterHandle': m.ClassMirror(
      'ImageStreamCompleterHandle',
      {'dispose': _ImageStreamCompleterHandle_dispose$},
      {},
    ),
    'ImageStreamCompleter': m.ClassMirror(
      'ImageStreamCompleter',
      {
        'debugLabel': _ImageStreamCompleter_debugLabel$,
        'hasListeners': _ImageStreamCompleter_hasListeners$,
        'addListener': _ImageStreamCompleter_addListener$,
        'keepAlive': _ImageStreamCompleter_keepAlive$,
        'removeListener': _ImageStreamCompleter_removeListener$,
        'setImage': _ImageStreamCompleter_setImage$,
        'reportImageChunkEvent': _ImageStreamCompleter_reportImageChunkEvent$,
        'debugFillProperties': _ImageStreamCompleter_debugFillProperties$,
      },
      {'debugLabel': _ImageStreamCompleter_debugLabel_set$},
    ),
    'OneFrameImageStreamCompleter': m.ClassMirror(
      'OneFrameImageStreamCompleter',
      {},
      {},
    ),
    'MultiFrameImageStreamCompleter': m.ClassMirror(
      'MultiFrameImageStreamCompleter',
      {
        'addListener': _MultiFrameImageStreamCompleter_addListener$,
        'removeListener': _MultiFrameImageStreamCompleter_removeListener$,
      },
      {},
    ),
  },
);
Image _ImageInfo_image$(ImageInfo target) {
  return target.image;
}

double _ImageInfo_scale$(ImageInfo target) {
  return target.scale;
}

String? _ImageInfo_debugLabel$(ImageInfo target) {
  return target.debugLabel;
}

int _ImageInfo_sizeBytes$(ImageInfo target) {
  return target.sizeBytes;
}

int _ImageInfo_hashCode$(ImageInfo target) {
  return target.hashCode;
}

Function _ImageInfo_clone$(
  m.Scope scope,
  ImageInfo target,
) =>
    target.clone;
Function _ImageInfo_isCloneOf$(
  m.Scope scope,
  ImageInfo target,
) =>
    target.isCloneOf;
Function _ImageInfo_dispose$(
  m.Scope scope,
  ImageInfo target,
) =>
    target.dispose;
Function _ImageInfo_toString$(
  m.Scope scope,
  ImageInfo target,
) =>
    target.toString;
void Function(ImageInfo, bool) _ImageStreamListener_onImage$(
    ImageStreamListener target) {
  return target.onImage;
}

void Function(ImageChunkEvent)? _ImageStreamListener_onChunk$(
    ImageStreamListener target) {
  return target.onChunk;
}

void Function(Object, StackTrace?)? _ImageStreamListener_onError$(
    ImageStreamListener target) {
  return target.onError;
}

int _ImageStreamListener_hashCode$(ImageStreamListener target) {
  return target.hashCode;
}

int _ImageChunkEvent_cumulativeBytesLoaded$(ImageChunkEvent target) {
  return target.cumulativeBytesLoaded;
}

int? _ImageChunkEvent_expectedTotalBytes$(ImageChunkEvent target) {
  return target.expectedTotalBytes;
}

Function _ImageChunkEvent_debugFillProperties$(
  m.Scope scope,
  ImageChunkEvent target,
) =>
    target.debugFillProperties;
ImageStreamCompleter? _ImageStream_completer$(ImageStream target) {
  return target.completer;
}

Object _ImageStream_key$(ImageStream target) {
  return target.key;
}

Function _ImageStream_setCompleter$(
  m.Scope scope,
  ImageStream target,
) =>
    target.setCompleter;
Function _ImageStream_addListener$(
  m.Scope scope,
  ImageStream target,
) =>
    target.addListener;
Function _ImageStream_removeListener$(
  m.Scope scope,
  ImageStream target,
) =>
    target.removeListener;
Function _ImageStream_debugFillProperties$(
  m.Scope scope,
  ImageStream target,
) =>
    target.debugFillProperties;
Function _ImageStreamCompleterHandle_dispose$(
  m.Scope scope,
  ImageStreamCompleterHandle target,
) =>
    target.dispose;
String? _ImageStreamCompleter_debugLabel$(ImageStreamCompleter target) {
  return target.debugLabel;
}

void _ImageStreamCompleter_debugLabel_set$(
  ImageStreamCompleter target,
  String? other,
) {
  target.debugLabel = other;
}

bool _ImageStreamCompleter_hasListeners$(ImageStreamCompleter target) {
  return target.hasListeners;
}

Function _ImageStreamCompleter_addListener$(
  m.Scope scope,
  ImageStreamCompleter target,
) =>
    target.addListener;
Function _ImageStreamCompleter_keepAlive$(
  m.Scope scope,
  ImageStreamCompleter target,
) =>
    target.keepAlive;
Function _ImageStreamCompleter_removeListener$(
  m.Scope scope,
  ImageStreamCompleter target,
) =>
    target.removeListener;
Function _ImageStreamCompleter_setImage$(
  m.Scope scope,
  ImageStreamCompleter target,
) =>
    target.setImage;
Function _ImageStreamCompleter_reportImageChunkEvent$(
  m.Scope scope,
  ImageStreamCompleter target,
) =>
    target.reportImageChunkEvent;
Function _ImageStreamCompleter_debugFillProperties$(
  m.Scope scope,
  ImageStreamCompleter target,
) =>
    target.debugFillProperties;
Function _MultiFrameImageStreamCompleter_addListener$(
  m.Scope scope,
  MultiFrameImageStreamCompleter target,
) =>
    target.addListener;
Function _MultiFrameImageStreamCompleter_removeListener$(
  m.Scope scope,
  MultiFrameImageStreamCompleter target,
) =>
    target.removeListener;
