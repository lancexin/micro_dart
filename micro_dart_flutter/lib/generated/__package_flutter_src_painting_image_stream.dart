// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/image_stream.dart';
import 'dart:async';
import 'dart:ui' show Codec, FrameInfo, Image;
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/image_stream.dart',
  {
    'ImageInfo.': _ImageInfo__$,
    'ImageStreamListener.': _ImageStreamListener__$,
    'ImageChunkEvent.': _ImageChunkEvent__$,
    'ImageStream.': _ImageStream__$,
    'ImageStreamCompleter.addOnLastListenerRemovedCallback':
        _ImageStreamCompleter_addOnLastListenerRemovedCallback$,
    'ImageStreamCompleter.removeOnLastListenerRemovedCallback':
        _ImageStreamCompleter_removeOnLastListenerRemovedCallback$,
    'ImageStreamCompleter.reportError': _ImageStreamCompleter_reportError$,
    'OneFrameImageStreamCompleter.': _OneFrameImageStreamCompleter__$,
    'MultiFrameImageStreamCompleter.': _MultiFrameImageStreamCompleter__$,
  },
  {},
  {
    'ImageInfo': m.ClassMirror(
      'ImageInfo',
      {
        '#as': ImageInfo_as$,
        '#is': ImageInfo_is$,
        'image': _ImageInfo_image$,
        'scale': _ImageInfo_scale$,
        'debugLabel': _ImageInfo_debugLabel$,
        'sizeBytes': _ImageInfo_sizeBytes$,
        'hashCode': _ImageInfo_hashCode$,
        'clone': _ImageInfo_clone$,
        'isCloneOf': _ImageInfo_isCloneOf$,
        'dispose': _ImageInfo_dispose$,
        'toString': _ImageInfo_toString$,
        '==': _ImageInfo_eq$$,
      },
      {},
    ),
    'ImageStreamListener': m.ClassMirror(
      'ImageStreamListener',
      {
        '#as': ImageStreamListener_as$,
        '#is': ImageStreamListener_is$,
        'onImage': _ImageStreamListener_onImage$,
        'onChunk': _ImageStreamListener_onChunk$,
        'onError': _ImageStreamListener_onError$,
        'hashCode': _ImageStreamListener_hashCode$,
        '==': _ImageStreamListener_eq$$,
      },
      {},
    ),
    'ImageChunkEvent': m.ClassMirror(
      'ImageChunkEvent',
      {
        '#as': ImageChunkEvent_as$,
        '#is': ImageChunkEvent_is$,
        'cumulativeBytesLoaded': _ImageChunkEvent_cumulativeBytesLoaded$,
        'expectedTotalBytes': _ImageChunkEvent_expectedTotalBytes$,
        'debugFillProperties': _ImageChunkEvent_debugFillProperties$,
      },
      {},
    ),
    'ImageStream': m.ClassMirror(
      'ImageStream',
      {
        '#as': ImageStream_as$,
        '#is': ImageStream_is$,
        'completer': _ImageStream_completer$,
        'key': _ImageStream_key$,
        'setCompleter': _ImageStream_setCompleter$,
        'addListener': _ImageStream_addListener$,
        'removeListener': _ImageStream_removeListener$,
        'debugFillProperties': _ImageStream_debugFillProperties$,
      },
      {},
    ),
    'ImageStreamCompleterHandle': m.ClassMirror(
      'ImageStreamCompleterHandle',
      {
        '#as': ImageStreamCompleterHandle_as$,
        '#is': ImageStreamCompleterHandle_is$,
        'dispose': _ImageStreamCompleterHandle_dispose$,
      },
      {},
    ),
    'ImageStreamCompleter': m.ClassMirror(
      'ImageStreamCompleter',
      {
        '#as': ImageStreamCompleter_as$,
        '#is': ImageStreamCompleter_is$,
        'debugLabel': _ImageStreamCompleter_debugLabel$,
        'hasListeners': _ImageStreamCompleter_hasListeners$,
        'addListener': _ImageStreamCompleter_addListener$,
        'keepAlive': _ImageStreamCompleter_keepAlive$,
        'removeListener': _ImageStreamCompleter_removeListener$,
        'setImage': _ImageStreamCompleter_setImage$,
        'reportImageChunkEvent': _ImageStreamCompleter_reportImageChunkEvent$,
        'debugFillProperties': _ImageStreamCompleter_debugFillProperties$,
      },
      {'debugLabel': _ImageStreamCompleter_debugLabel_set$},
    ),
    'OneFrameImageStreamCompleter': m.ClassMirror(
      'OneFrameImageStreamCompleter',
      {
        '#as': OneFrameImageStreamCompleter_as$,
        '#is': OneFrameImageStreamCompleter_is$,
      },
      {},
    ),
    'MultiFrameImageStreamCompleter': m.ClassMirror(
      'MultiFrameImageStreamCompleter',
      {
        '#as': MultiFrameImageStreamCompleter_as$,
        '#is': MultiFrameImageStreamCompleter_is$,
        'addListener': _MultiFrameImageStreamCompleter_addListener$,
        'removeListener': _MultiFrameImageStreamCompleter_removeListener$,
      },
      {},
    ),
  },
);
Function ImageInfo_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImageInfo;
Function ImageInfo_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImageInfo;
Function _ImageInfo_image$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    () {
      return target$.image;
    };
Function _ImageInfo_scale$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    () {
      return target$.scale;
    };
Function _ImageInfo_debugLabel$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    () {
      return target$.debugLabel;
    };
Function _ImageInfo_sizeBytes$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    () {
      return target$.sizeBytes;
    };
Function _ImageInfo_hashCode$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    () {
      return target$.hashCode;
    };
Function _ImageInfo__$(m.Scope scope$) => ({
      required Image image,
      double? scale,
      String? debugLabel,
    }) {
      return ImageInfo(
        debugLabel: debugLabel,
        image: image,
        scale: scale ?? 1.0,
      );
    };
Function _ImageInfo_clone$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    target$.clone;
Function _ImageInfo_isCloneOf$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    target$.isCloneOf;
Function _ImageInfo_dispose$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    target$.dispose;
Function _ImageInfo_toString$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    target$.toString;
Function _ImageInfo_eq$$(
  m.Scope scope$,
  ImageInfo target$,
) =>
    (Object other$) => target$ == other$;
Function ImageStreamListener_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImageStreamListener;
Function ImageStreamListener_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImageStreamListener;
Function _ImageStreamListener_onImage$(
  m.Scope scope$,
  ImageStreamListener target$,
) =>
    () {
      return target$.onImage;
    };
Function _ImageStreamListener_onChunk$(
  m.Scope scope$,
  ImageStreamListener target$,
) =>
    () {
      return target$.onChunk;
    };
Function _ImageStreamListener_onError$(
  m.Scope scope$,
  ImageStreamListener target$,
) =>
    () {
      return target$.onError;
    };
Function _ImageStreamListener_hashCode$(
  m.Scope scope$,
  ImageStreamListener target$,
) =>
    () {
      return target$.hashCode;
    };
Function _ImageStreamListener__$(m.Scope scope$) => (
      m.FunctionPointer onImage, {
      m.FunctionPointer? onChunk,
      m.FunctionPointer? onError,
    }) {
      void onImageProxy(
        ImageInfo onImage_image$,
        bool onImage_synchronousCall$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onImage,
            [
              onImage_image$,
              onImage_synchronousCall$,
            ],
            {},
          );
      void onChunkProxy(ImageChunkEvent onChunk_event$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChunk!,
            [onChunk_event$],
            {},
          );
      void onErrorProxy(
        Object onError_exception$,
        StackTrace? onError_stackTrace$,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onError!,
            [
              onError_exception$,
              onError_stackTrace$,
            ],
            {},
          );
      return ImageStreamListener(
        onImageProxy,
        onChunk: onChunk == null ? null : onChunkProxy,
        onError: onError == null ? null : onErrorProxy,
      );
    };
Function _ImageStreamListener_eq$$(
  m.Scope scope$,
  ImageStreamListener target$,
) =>
    (Object other$) => target$ == other$;
Function ImageChunkEvent_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImageChunkEvent;
Function ImageChunkEvent_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImageChunkEvent;
Function _ImageChunkEvent_cumulativeBytesLoaded$(
  m.Scope scope$,
  ImageChunkEvent target$,
) =>
    () {
      return target$.cumulativeBytesLoaded;
    };
Function _ImageChunkEvent_expectedTotalBytes$(
  m.Scope scope$,
  ImageChunkEvent target$,
) =>
    () {
      return target$.expectedTotalBytes;
    };
Function _ImageChunkEvent__$(m.Scope scope$) => ({
      required int cumulativeBytesLoaded,
      required int? expectedTotalBytes,
    }) {
      return ImageChunkEvent(
        cumulativeBytesLoaded: cumulativeBytesLoaded,
        expectedTotalBytes: expectedTotalBytes,
      );
    };
Function _ImageChunkEvent_debugFillProperties$(
  m.Scope scope$,
  ImageChunkEvent target$,
) =>
    target$.debugFillProperties;
Function ImageStream_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImageStream;
Function ImageStream_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImageStream;
Function _ImageStream_completer$(
  m.Scope scope$,
  ImageStream target$,
) =>
    () {
      return target$.completer;
    };
Function _ImageStream_key$(
  m.Scope scope$,
  ImageStream target$,
) =>
    () {
      return target$.key;
    };
Function _ImageStream__$(m.Scope scope$) => () {
      return ImageStream();
    };
Function _ImageStream_setCompleter$(
  m.Scope scope$,
  ImageStream target$,
) =>
    target$.setCompleter;
Function _ImageStream_addListener$(
  m.Scope scope$,
  ImageStream target$,
) =>
    target$.addListener;
Function _ImageStream_removeListener$(
  m.Scope scope$,
  ImageStream target$,
) =>
    target$.removeListener;
Function _ImageStream_debugFillProperties$(
  m.Scope scope$,
  ImageStream target$,
) =>
    target$.debugFillProperties;
Function ImageStreamCompleterHandle_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImageStreamCompleterHandle;
Function ImageStreamCompleterHandle_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImageStreamCompleterHandle;
Function _ImageStreamCompleterHandle_dispose$(
  m.Scope scope$,
  ImageStreamCompleterHandle target$,
) =>
    target$.dispose;
Function ImageStreamCompleter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ImageStreamCompleter;
Function ImageStreamCompleter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ImageStreamCompleter;
Function _ImageStreamCompleter_debugLabel$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    () {
      return target$.debugLabel;
    };
void _ImageStreamCompleter_debugLabel_set$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    (dynamic other$) {
      target$.debugLabel = other$;
    };
Function _ImageStreamCompleter_hasListeners$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    () {
      return target$.hasListeners;
    };
Function _ImageStreamCompleter_addListener$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    target$.addListener;
Function _ImageStreamCompleter_keepAlive$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    target$.keepAlive;
Function _ImageStreamCompleter_removeListener$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    target$.removeListener;
Function _ImageStreamCompleter_addOnLastListenerRemovedCallback$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      target$.addOnLastListenerRemovedCallback(callbackProxy);
    };
Function _ImageStreamCompleter_removeOnLastListenerRemovedCallback$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      target$.removeOnLastListenerRemovedCallback(callbackProxy);
    };
Function _ImageStreamCompleter_setImage$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    target$.setImage;
Function _ImageStreamCompleter_reportError$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    ({
      DiagnosticsNode? context,
      required Object exception,
      StackTrace? stack,
      m.FunctionPointer? informationCollector,
      bool? silent,
    }) {
      Iterable<DiagnosticsNode> informationCollectorProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            informationCollector!,
            [],
            {},
          );
      target$.reportError(
        context: context,
        exception: exception,
        informationCollector:
            informationCollector == null ? null : informationCollectorProxy,
        silent: silent ?? false,
        stack: stack,
      );
    };
Function _ImageStreamCompleter_reportImageChunkEvent$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    target$.reportImageChunkEvent;
Function _ImageStreamCompleter_debugFillProperties$(
  m.Scope scope$,
  ImageStreamCompleter target$,
) =>
    target$.debugFillProperties;
Function OneFrameImageStreamCompleter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as OneFrameImageStreamCompleter;
Function OneFrameImageStreamCompleter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is OneFrameImageStreamCompleter;
Function _OneFrameImageStreamCompleter__$(m.Scope scope$) => (
      Future<ImageInfo> image, {
      m.FunctionPointer? informationCollector,
    }) {
      Iterable<DiagnosticsNode> informationCollectorProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            informationCollector!,
            [],
            {},
          );
      return OneFrameImageStreamCompleter(
        image,
        informationCollector:
            informationCollector == null ? null : informationCollectorProxy,
      );
    };
Function MultiFrameImageStreamCompleter_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MultiFrameImageStreamCompleter;
Function MultiFrameImageStreamCompleter_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MultiFrameImageStreamCompleter;
Function _MultiFrameImageStreamCompleter__$(m.Scope scope$) => ({
      required Future<Codec> codec,
      required double scale,
      String? debugLabel,
      Stream<ImageChunkEvent>? chunkEvents,
      m.FunctionPointer? informationCollector,
    }) {
      Iterable<DiagnosticsNode> informationCollectorProxy() =>
          scope$.engine.callFunctionPointer(
            scope$,
            informationCollector!,
            [],
            {},
          );
      return MultiFrameImageStreamCompleter(
        chunkEvents: chunkEvents,
        codec: codec,
        debugLabel: debugLabel,
        informationCollector:
            informationCollector == null ? null : informationCollectorProxy,
        scale: scale,
      );
    };
Function _MultiFrameImageStreamCompleter_addListener$(
  m.Scope scope$,
  MultiFrameImageStreamCompleter target$,
) =>
    target$.addListener;
Function _MultiFrameImageStreamCompleter_removeListener$(
  m.Scope scope$,
  MultiFrameImageStreamCompleter target$,
) =>
    target$.removeListener;
