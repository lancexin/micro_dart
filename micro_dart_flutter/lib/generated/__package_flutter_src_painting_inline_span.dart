// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/painting/inline_span.dart';
import 'dart:ui' show ParagraphBuilder, StringAttribute;
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/text_span.dart';
import 'package:flutter/src/painting/text_style.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/painting/inline_span.dart',
  {
    'InlineSpanSemanticsInformation.placeholder':
        _InlineSpanSemanticsInformation_placeholder$,
    'InlineSpan.visitChildren': _InlineSpan_visitChildren$,
    'combineSemanticsInfo': _combineSemanticsInfo$,
  },
  {},
  {
    'Accumulator': m.ClassMirror(
      'Accumulator',
      {
        '#as': Accumulator_as$,
        '#is': Accumulator_is$,
        'value': _Accumulator_value$,
        'increment': _Accumulator_increment$,
      },
      {},
    ),
    'InlineSpanSemanticsInformation': m.ClassMirror(
      'InlineSpanSemanticsInformation',
      {
        '#as': InlineSpanSemanticsInformation_as$,
        '#is': InlineSpanSemanticsInformation_is$,
        'text': _InlineSpanSemanticsInformation_text$,
        'semanticsLabel': _InlineSpanSemanticsInformation_semanticsLabel$,
        'recognizer': _InlineSpanSemanticsInformation_recognizer$,
        'isPlaceholder': _InlineSpanSemanticsInformation_isPlaceholder$,
        'requiresOwnNode': _InlineSpanSemanticsInformation_requiresOwnNode$,
        'stringAttributes': _InlineSpanSemanticsInformation_stringAttributes$,
        'hashCode': _InlineSpanSemanticsInformation_hashCode$,
        '==': _InlineSpanSemanticsInformation_eq$$,
        'toString': _InlineSpanSemanticsInformation_toString$,
      },
      {},
    ),
    'InlineSpan': m.ClassMirror(
      'InlineSpan',
      {
        '#as': InlineSpan_as$,
        '#is': InlineSpan_is$,
        'style': _InlineSpan_style$,
        'hashCode': _InlineSpan_hashCode$,
        'build': _InlineSpan_build$,
        'getSpanForPosition': _InlineSpan_getSpanForPosition$,
        'getSpanForPositionVisitor': _InlineSpan_getSpanForPositionVisitor$,
        'toPlainText': _InlineSpan_toPlainText$,
        'getSemanticsInformation': _InlineSpan_getSemanticsInformation$,
        'computeSemanticsInformation': _InlineSpan_computeSemanticsInformation$,
        'computeToPlainText': _InlineSpan_computeToPlainText$,
        'codeUnitAt': _InlineSpan_codeUnitAt$,
        'codeUnitAtVisitor': _InlineSpan_codeUnitAtVisitor$,
        'debugAssertIsValid': _InlineSpan_debugAssertIsValid$,
        'compareTo': _InlineSpan_compareTo$,
        '==': _InlineSpan_eq$$,
        'debugFillProperties': _InlineSpan_debugFillProperties$,
      },
      {},
    ),
  },
);
Function Accumulator_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as Accumulator;
Function Accumulator_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is Accumulator;
int _Accumulator_value$(Accumulator target) {
  return target.value;
}

Function _Accumulator_increment$(
  m.Scope scope,
  Accumulator target,
) =>
    target.increment;
Function InlineSpanSemanticsInformation_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as InlineSpanSemanticsInformation;
Function InlineSpanSemanticsInformation_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is InlineSpanSemanticsInformation;
InlineSpanSemanticsInformation _InlineSpanSemanticsInformation_placeholder$() {
  return InlineSpanSemanticsInformation.placeholder;
}

String _InlineSpanSemanticsInformation_text$(
    InlineSpanSemanticsInformation target) {
  return target.text;
}

String? _InlineSpanSemanticsInformation_semanticsLabel$(
    InlineSpanSemanticsInformation target) {
  return target.semanticsLabel;
}

GestureRecognizer? _InlineSpanSemanticsInformation_recognizer$(
    InlineSpanSemanticsInformation target) {
  return target.recognizer;
}

bool _InlineSpanSemanticsInformation_isPlaceholder$(
    InlineSpanSemanticsInformation target) {
  return target.isPlaceholder;
}

bool _InlineSpanSemanticsInformation_requiresOwnNode$(
    InlineSpanSemanticsInformation target) {
  return target.requiresOwnNode;
}

List<StringAttribute> _InlineSpanSemanticsInformation_stringAttributes$(
    InlineSpanSemanticsInformation target) {
  return target.stringAttributes;
}

int _InlineSpanSemanticsInformation_hashCode$(
    InlineSpanSemanticsInformation target) {
  return target.hashCode;
}

Function _InlineSpanSemanticsInformation_eq$$(
  m.Scope scope,
  InlineSpanSemanticsInformation target,
) =>
    (Object other) => target == other;
Function _InlineSpanSemanticsInformation_toString$(
  m.Scope scope,
  InlineSpanSemanticsInformation target,
) =>
    target.toString;
Function InlineSpan_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as InlineSpan;
Function InlineSpan_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is InlineSpan;
TextStyle? _InlineSpan_style$(InlineSpan target) {
  return target.style;
}

int _InlineSpan_hashCode$(InlineSpan target) {
  return target.hashCode;
}

Function _InlineSpan_build$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.build;
Function _InlineSpan_visitChildren$(
  m.Scope scope,
  InlineSpan target,
) =>
    (m.FunctionPointer visitor) {
      bool visitorProxy(InlineSpan visitor_span) =>
          scope.engine.callFunctionPointer(
            scope,
            visitor,
            [visitor_span],
            {},
          );
      return target.visitChildren(visitorProxy);
    };
Function _InlineSpan_getSpanForPosition$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.getSpanForPosition;
Function _InlineSpan_getSpanForPositionVisitor$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.getSpanForPositionVisitor;
Function _InlineSpan_toPlainText$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.toPlainText;
Function _InlineSpan_getSemanticsInformation$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.getSemanticsInformation;
Function _InlineSpan_computeSemanticsInformation$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.computeSemanticsInformation;
Function _InlineSpan_computeToPlainText$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.computeToPlainText;
Function _InlineSpan_codeUnitAt$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.codeUnitAt;
Function _InlineSpan_codeUnitAtVisitor$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.codeUnitAtVisitor;
Function _InlineSpan_debugAssertIsValid$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.debugAssertIsValid;
Function _InlineSpan_compareTo$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.compareTo;
Function _InlineSpan_eq$$(
  m.Scope scope,
  InlineSpan target,
) =>
    (Object other) => target == other;
Function _InlineSpan_debugFillProperties$(
  m.Scope scope,
  InlineSpan target,
) =>
    target.debugFillProperties;
Function _combineSemanticsInfo$(m.Scope scope) => combineSemanticsInfo;
