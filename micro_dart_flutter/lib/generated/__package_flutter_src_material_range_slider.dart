// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/material/range_slider.dart';
import 'dart:async';
import 'dart:math';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart' show timeDilation;
import 'package:flutter/widgets.dart';
import 'package:flutter/src/material/constants.dart';
import 'package:flutter/src/material/debug.dart';
import 'package:flutter/src/material/material_state.dart';
import 'package:flutter/src/material/slider_theme.dart';
import 'package:flutter/src/material/theme.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/material/range_slider.dart',
  {'RangeSlider.': _RangeSlider__$},
  {},
  {
    'RangeSlider': m.ClassMirror(
      'RangeSlider',
      {
        '#as': RangeSlider_as$,
        '#is': RangeSlider_is$,
        'values': _RangeSlider_values$,
        'onChanged': _RangeSlider_onChanged$,
        'onChangeStart': _RangeSlider_onChangeStart$,
        'onChangeEnd': _RangeSlider_onChangeEnd$,
        'min': _RangeSlider_min$,
        'max': _RangeSlider_max$,
        'divisions': _RangeSlider_divisions$,
        'labels': _RangeSlider_labels$,
        'activeColor': _RangeSlider_activeColor$,
        'inactiveColor': _RangeSlider_inactiveColor$,
        'overlayColor': _RangeSlider_overlayColor$,
        'mouseCursor': _RangeSlider_mouseCursor$,
        'semanticFormatterCallback': _RangeSlider_semanticFormatterCallback$,
        'createState': _RangeSlider_createState$,
        'debugFillProperties': _RangeSlider_debugFillProperties$,
      },
      {},
    )
  },
);
Function RangeSlider_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as RangeSlider;
Function RangeSlider_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is RangeSlider;
Function _RangeSlider_values$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.values;
    };
Function _RangeSlider_onChanged$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.onChanged;
    };
Function _RangeSlider_onChangeStart$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.onChangeStart;
    };
Function _RangeSlider_onChangeEnd$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.onChangeEnd;
    };
Function _RangeSlider_min$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.min;
    };
Function _RangeSlider_max$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.max;
    };
Function _RangeSlider_divisions$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.divisions;
    };
Function _RangeSlider_labels$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.labels;
    };
Function _RangeSlider_activeColor$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.activeColor;
    };
Function _RangeSlider_inactiveColor$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.inactiveColor;
    };
Function _RangeSlider_overlayColor$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.overlayColor;
    };
Function _RangeSlider_mouseCursor$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.mouseCursor;
    };
Function _RangeSlider_semanticFormatterCallback$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    () {
      return target$.semanticFormatterCallback;
    };
Function _RangeSlider__$(m.Scope scope$) => ({
      Key? key,
      required RangeValues values,
      required m.FunctionPointer? onChanged,
      m.FunctionPointer? onChangeStart,
      m.FunctionPointer? onChangeEnd,
      double? min,
      double? max,
      int? divisions,
      RangeLabels? labels,
      Color? activeColor,
      Color? inactiveColor,
      MaterialStateProperty<Color>? overlayColor,
      MaterialStateProperty<MouseCursor>? mouseCursor,
      m.FunctionPointer? semanticFormatterCallback,
    }) {
      void onChangeEndProxy(RangeValues onChangeEnd_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChangeEnd!,
            [onChangeEnd_value$],
            {},
          );
      void onChangeStartProxy(RangeValues onChangeStart_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChangeStart!,
            [onChangeStart_value$],
            {},
          );
      void onChangedProxy(RangeValues onChanged_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onChanged!,
            [onChanged_value$],
            {},
          );
      String semanticFormatterCallbackProxy(
              double semanticFormatterCallback_value$) =>
          scope$.engine.callFunctionPointer(
            scope$,
            semanticFormatterCallback!,
            [semanticFormatterCallback_value$],
            {},
          );
      return RangeSlider(
        activeColor: activeColor,
        divisions: divisions,
        inactiveColor: inactiveColor,
        key: key,
        labels: labels,
        max: max ?? 1.0,
        min: min ?? 0.0,
        mouseCursor: mouseCursor,
        onChangeEnd: onChangeEnd == null ? null : onChangeEndProxy,
        onChangeStart: onChangeStart == null ? null : onChangeStartProxy,
        onChanged: onChanged == null ? null : onChangedProxy,
        overlayColor: overlayColor,
        semanticFormatterCallback: semanticFormatterCallback == null
            ? null
            : semanticFormatterCallbackProxy,
        values: values,
      );
    };
Function _RangeSlider_createState$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    target$.createState;
Function _RangeSlider_debugFillProperties$(
  m.Scope scope$,
  RangeSlider target$,
) =>
    target$.debugFillProperties;
