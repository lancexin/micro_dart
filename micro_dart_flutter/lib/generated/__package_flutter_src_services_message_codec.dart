// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/services/message_codec.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/services/platform_channel.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/services/message_codec.dart',
  {
    'MethodCall.': _MethodCall__$,
    'PlatformException.': _PlatformException__$,
    'MissingPluginException.': _MissingPluginException__$,
  },
  {},
  {
    'MessageCodec': m.ClassMirror(
      'MessageCodec',
      {
        '#as': MessageCodec_as$,
        '#is': MessageCodec_is$,
        'encodeMessage': _MessageCodec_encodeMessage$,
        'decodeMessage': _MessageCodec_decodeMessage$,
      },
      {},
    ),
    'MethodCall': m.ClassMirror(
      'MethodCall',
      {
        '#as': MethodCall_as$,
        '#is': MethodCall_is$,
        'method': _MethodCall_method$,
        'arguments': _MethodCall_arguments$,
        'toString': _MethodCall_toString$,
      },
      {},
    ),
    'MethodCodec': m.ClassMirror(
      'MethodCodec',
      {
        '#as': MethodCodec_as$,
        '#is': MethodCodec_is$,
        'encodeMethodCall': _MethodCodec_encodeMethodCall$,
        'decodeMethodCall': _MethodCodec_decodeMethodCall$,
        'decodeEnvelope': _MethodCodec_decodeEnvelope$,
        'encodeSuccessEnvelope': _MethodCodec_encodeSuccessEnvelope$,
        'encodeErrorEnvelope': _MethodCodec_encodeErrorEnvelope$,
      },
      {},
    ),
    'PlatformException': m.ClassMirror(
      'PlatformException',
      {
        '#as': PlatformException_as$,
        '#is': PlatformException_is$,
        'code': _PlatformException_code$,
        'message': _PlatformException_message$,
        'details': _PlatformException_details$,
        'stacktrace': _PlatformException_stacktrace$,
        'toString': _PlatformException_toString$,
      },
      {},
    ),
    'MissingPluginException': m.ClassMirror(
      'MissingPluginException',
      {
        '#as': MissingPluginException_as$,
        '#is': MissingPluginException_is$,
        'message': _MissingPluginException_message$,
        'toString': _MissingPluginException_toString$,
      },
      {},
    ),
  },
);
Function MessageCodec_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MessageCodec<T>;
Function MessageCodec_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MessageCodec<T>;
Function _MessageCodec_encodeMessage$<T>(
  m.Scope scope$,
  MessageCodec<T> target$,
) =>
    target$.encodeMessage;
Function _MessageCodec_decodeMessage$<T>(
  m.Scope scope$,
  MessageCodec<T> target$,
) =>
    target$.decodeMessage;
Function MethodCall_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MethodCall;
Function MethodCall_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MethodCall;
Function _MethodCall_method$(
  m.Scope scope$,
  MethodCall target$,
) =>
    () {
      return target$.method;
    };
Function _MethodCall_arguments$(
  m.Scope scope$,
  MethodCall target$,
) =>
    () {
      return target$.arguments;
    };
Function _MethodCall__$(m.Scope scope$) => (
      String method, [
      dynamic? arguments,
    ]) {
      if (arguments == null) {
        return MethodCall(method);
      }
      return MethodCall(
        method,
        arguments!,
      );
    };
Function _MethodCall_toString$(
  m.Scope scope$,
  MethodCall target$,
) =>
    target$.toString;
Function MethodCodec_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MethodCodec;
Function MethodCodec_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MethodCodec;
Function _MethodCodec_encodeMethodCall$(
  m.Scope scope$,
  MethodCodec target$,
) =>
    target$.encodeMethodCall;
Function _MethodCodec_decodeMethodCall$(
  m.Scope scope$,
  MethodCodec target$,
) =>
    target$.decodeMethodCall;
Function _MethodCodec_decodeEnvelope$(
  m.Scope scope$,
  MethodCodec target$,
) =>
    target$.decodeEnvelope;
Function _MethodCodec_encodeSuccessEnvelope$(
  m.Scope scope$,
  MethodCodec target$,
) =>
    target$.encodeSuccessEnvelope;
Function _MethodCodec_encodeErrorEnvelope$(
  m.Scope scope$,
  MethodCodec target$,
) =>
    target$.encodeErrorEnvelope;
Function PlatformException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as PlatformException;
Function PlatformException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is PlatformException;
Function _PlatformException_code$(
  m.Scope scope$,
  PlatformException target$,
) =>
    () {
      return target$.code;
    };
Function _PlatformException_message$(
  m.Scope scope$,
  PlatformException target$,
) =>
    () {
      return target$.message;
    };
Function _PlatformException_details$(
  m.Scope scope$,
  PlatformException target$,
) =>
    () {
      return target$.details;
    };
Function _PlatformException_stacktrace$(
  m.Scope scope$,
  PlatformException target$,
) =>
    () {
      return target$.stacktrace;
    };
Function _PlatformException__$(m.Scope scope$) => ({
      required String code,
      String? message,
      dynamic? details,
      String? stacktrace,
    }) {
      return PlatformException(
        code: code,
        details: details,
        message: message,
        stacktrace: stacktrace,
      );
    };
Function _PlatformException_toString$(
  m.Scope scope$,
  PlatformException target$,
) =>
    target$.toString;
Function MissingPluginException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MissingPluginException;
Function MissingPluginException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MissingPluginException;
Function _MissingPluginException_message$(
  m.Scope scope$,
  MissingPluginException target$,
) =>
    () {
      return target$.message;
    };
Function _MissingPluginException__$(m.Scope scope$) => ([String? message]) {
      if (message == null) {
        return MissingPluginException();
      }
      return MissingPluginException(message!);
    };
Function _MissingPluginException_toString$(
  m.Scope scope$,
  MissingPluginException target$,
) =>
    target$.toString;
