// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'package:flutter/src/widgets/routes.dart';
import 'dart:async';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/widgets/actions.dart';
import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/widgets/display_feature_sub_screen.dart';
import 'package:flutter/src/widgets/focus_manager.dart';
import 'package:flutter/src/widgets/focus_scope.dart';
import 'package:flutter/src/widgets/focus_traversal.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/modal_barrier.dart';
import 'package:flutter/src/widgets/navigator.dart';
import 'package:flutter/src/widgets/overlay.dart';
import 'package:flutter/src/widgets/page_storage.dart';
import 'package:flutter/src/widgets/primary_scroll_controller.dart';
import 'package:flutter/src/widgets/restoration.dart';
import 'package:flutter/src/widgets/scroll_controller.dart';
import 'package:flutter/src/widgets/transitions.dart';

const libraryMirror = m.LibraryMirror(
  'package:flutter/src/widgets/routes.dart',
  {
    'ModalRoute.of': _ModalRoute_of$,
    'ModalRoute.setState': _ModalRoute_setState$,
    'ModalRoute.withName': _ModalRoute_withName$,
    'ModalRoute.addScopedWillPopCallback':
        _ModalRoute_addScopedWillPopCallback$,
    'ModalRoute.removeScopedWillPopCallback':
        _ModalRoute_removeScopedWillPopCallback$,
    'showGeneralDialog': _showGeneralDialog$,
  },
  {},
  {
    'OverlayRoute': m.ClassMirror(
      'OverlayRoute',
      {
        '#as': OverlayRoute_as$,
        '#is': OverlayRoute_is$,
        'overlayEntries': _OverlayRoute_overlayEntries$,
        'finishedWhenPopped': _OverlayRoute_finishedWhenPopped$,
        'createOverlayEntries': _OverlayRoute_createOverlayEntries$,
        'install': _OverlayRoute_install$,
        'didPop': _OverlayRoute_didPop$,
        'dispose': _OverlayRoute_dispose$,
      },
      {},
    ),
    'TransitionRoute': m.ClassMirror(
      'TransitionRoute',
      {
        '#as': TransitionRoute_as$,
        '#is': TransitionRoute_is$,
        'willDisposeAnimationController':
            _TransitionRoute_willDisposeAnimationController$,
        'completed': _TransitionRoute_completed$,
        'transitionDuration': _TransitionRoute_transitionDuration$,
        'reverseTransitionDuration':
            _TransitionRoute_reverseTransitionDuration$,
        'opaque': _TransitionRoute_opaque$,
        'allowSnapshotting': _TransitionRoute_allowSnapshotting$,
        'finishedWhenPopped': _TransitionRoute_finishedWhenPopped$,
        'animation': _TransitionRoute_animation$,
        'controller': _TransitionRoute_controller$,
        'secondaryAnimation': _TransitionRoute_secondaryAnimation$,
        'debugLabel': _TransitionRoute_debugLabel$,
        'createAnimationController':
            _TransitionRoute_createAnimationController$,
        'createAnimation': _TransitionRoute_createAnimation$,
        'install': _TransitionRoute_install$,
        'didPush': _TransitionRoute_didPush$,
        'didAdd': _TransitionRoute_didAdd$,
        'didReplace': _TransitionRoute_didReplace$,
        'didPop': _TransitionRoute_didPop$,
        'didPopNext': _TransitionRoute_didPopNext$,
        'didChangeNext': _TransitionRoute_didChangeNext$,
        'canTransitionTo': _TransitionRoute_canTransitionTo$,
        'canTransitionFrom': _TransitionRoute_canTransitionFrom$,
        'dispose': _TransitionRoute_dispose$,
        'toString': _TransitionRoute_toString$,
      },
      {
        'willDisposeAnimationController':
            _TransitionRoute_willDisposeAnimationController_set$
      },
    ),
    'LocalHistoryEntry': m.ClassMirror(
      'LocalHistoryEntry',
      {
        '#as': LocalHistoryEntry_as$,
        '#is': LocalHistoryEntry_is$,
        'onRemove': _LocalHistoryEntry_onRemove$,
        'impliesAppBarDismissal': _LocalHistoryEntry_impliesAppBarDismissal$,
        'remove': _LocalHistoryEntry_remove$,
      },
      {},
    ),
    'ModalRoute': m.ClassMirror(
      'ModalRoute',
      {
        '#as': ModalRoute_as$,
        '#is': ModalRoute_is$,
        'filter': _ModalRoute_filter$,
        'traversalEdgeBehavior': _ModalRoute_traversalEdgeBehavior$,
        'barrierDismissible': _ModalRoute_barrierDismissible$,
        'semanticsDismissible': _ModalRoute_semanticsDismissible$,
        'barrierColor': _ModalRoute_barrierColor$,
        'barrierLabel': _ModalRoute_barrierLabel$,
        'barrierCurve': _ModalRoute_barrierCurve$,
        'maintainState': _ModalRoute_maintainState$,
        'offstage': _ModalRoute_offstage$,
        'subtreeContext': _ModalRoute_subtreeContext$,
        'animation': _ModalRoute_animation$,
        'secondaryAnimation': _ModalRoute_secondaryAnimation$,
        'hasScopedWillPopCallback': _ModalRoute_hasScopedWillPopCallback$,
        'canPop': _ModalRoute_canPop$,
        'impliesAppBarDismissal': _ModalRoute_impliesAppBarDismissal$,
        'buildPage': _ModalRoute_buildPage$,
        'buildTransitions': _ModalRoute_buildTransitions$,
        'install': _ModalRoute_install$,
        'didPush': _ModalRoute_didPush$,
        'didAdd': _ModalRoute_didAdd$,
        'willPop': _ModalRoute_willPop$,
        'didChangePrevious': _ModalRoute_didChangePrevious$,
        'changedInternalState': _ModalRoute_changedInternalState$,
        'changedExternalState': _ModalRoute_changedExternalState$,
        'buildModalBarrier': _ModalRoute_buildModalBarrier$,
        'createOverlayEntries': _ModalRoute_createOverlayEntries$,
        'toString': _ModalRoute_toString$,
      },
      {'offstage': _ModalRoute_offstage_set$},
    ),
    'PopupRoute': m.ClassMirror(
      'PopupRoute',
      {
        '#as': PopupRoute_as$,
        '#is': PopupRoute_is$,
        'opaque': _PopupRoute_opaque$,
        'maintainState': _PopupRoute_maintainState$,
        'allowSnapshotting': _PopupRoute_allowSnapshotting$,
      },
      {},
    ),
    'RouteObserver': m.ClassMirror(
      'RouteObserver',
      {
        '#as': RouteObserver_as$,
        '#is': RouteObserver_is$,
        'debugObservingRoute': _RouteObserver_debugObservingRoute$,
        'subscribe': _RouteObserver_subscribe$,
        'unsubscribe': _RouteObserver_unsubscribe$,
        'didPop': _RouteObserver_didPop$,
        'didPush': _RouteObserver_didPush$,
      },
      {},
    ),
    'RouteAware': m.ClassMirror(
      'RouteAware',
      {
        '#as': RouteAware_as$,
        '#is': RouteAware_is$,
        'didPopNext': _RouteAware_didPopNext$,
        'didPush': _RouteAware_didPush$,
        'didPop': _RouteAware_didPop$,
        'didPushNext': _RouteAware_didPushNext$,
      },
      {},
    ),
    'RawDialogRoute': m.ClassMirror(
      'RawDialogRoute',
      {
        '#as': RawDialogRoute_as$,
        '#is': RawDialogRoute_is$,
        'anchorPoint': _RawDialogRoute_anchorPoint$,
        'barrierDismissible': _RawDialogRoute_barrierDismissible$,
        'barrierLabel': _RawDialogRoute_barrierLabel$,
        'barrierColor': _RawDialogRoute_barrierColor$,
        'transitionDuration': _RawDialogRoute_transitionDuration$,
        'buildPage': _RawDialogRoute_buildPage$,
        'buildTransitions': _RawDialogRoute_buildTransitions$,
      },
      {},
    ),
  },
);
Function OverlayRoute_as$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as OverlayRoute<T>;
Function OverlayRoute_is$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is OverlayRoute<T>;
List<OverlayEntry> _OverlayRoute_overlayEntries$<T>(OverlayRoute<T> target) {
  return target.overlayEntries;
}

bool _OverlayRoute_finishedWhenPopped$<T>(OverlayRoute<T> target) {
  return target.finishedWhenPopped;
}

Function _OverlayRoute_createOverlayEntries$<T>(
  m.Scope scope,
  OverlayRoute<T> target,
) =>
    target.createOverlayEntries;
Function _OverlayRoute_install$<T>(
  m.Scope scope,
  OverlayRoute<T> target,
) =>
    target.install;
Function _OverlayRoute_didPop$<T>(
  m.Scope scope,
  OverlayRoute<T> target,
) =>
    target.didPop;
Function _OverlayRoute_dispose$<T>(
  m.Scope scope,
  OverlayRoute<T> target,
) =>
    target.dispose;
Function TransitionRoute_as$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as TransitionRoute<T>;
Function TransitionRoute_is$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is TransitionRoute<T>;
bool _TransitionRoute_willDisposeAnimationController$<T>(
    TransitionRoute<T> target) {
  return target.willDisposeAnimationController;
}

void _TransitionRoute_willDisposeAnimationController_set$<T>(
  TransitionRoute<T> target,
  bool other,
) {
  target.willDisposeAnimationController = other;
}

Future<T?> _TransitionRoute_completed$<T>(TransitionRoute<T> target) {
  return target.completed;
}

Duration _TransitionRoute_transitionDuration$<T>(TransitionRoute<T> target) {
  return target.transitionDuration;
}

Duration _TransitionRoute_reverseTransitionDuration$<T>(
    TransitionRoute<T> target) {
  return target.reverseTransitionDuration;
}

bool _TransitionRoute_opaque$<T>(TransitionRoute<T> target) {
  return target.opaque;
}

bool _TransitionRoute_allowSnapshotting$<T>(TransitionRoute<T> target) {
  return target.allowSnapshotting;
}

bool _TransitionRoute_finishedWhenPopped$<T>(TransitionRoute<T> target) {
  return target.finishedWhenPopped;
}

Animation<double>? _TransitionRoute_animation$<T>(TransitionRoute<T> target) {
  return target.animation;
}

AnimationController? _TransitionRoute_controller$<T>(
    TransitionRoute<T> target) {
  return target.controller;
}

Animation<double>? _TransitionRoute_secondaryAnimation$<T>(
    TransitionRoute<T> target) {
  return target.secondaryAnimation;
}

String _TransitionRoute_debugLabel$<T>(TransitionRoute<T> target) {
  return target.debugLabel;
}

Function _TransitionRoute_createAnimationController$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.createAnimationController;
Function _TransitionRoute_createAnimation$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.createAnimation;
Function _TransitionRoute_install$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.install;
Function _TransitionRoute_didPush$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.didPush;
Function _TransitionRoute_didAdd$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.didAdd;
Function _TransitionRoute_didReplace$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.didReplace;
Function _TransitionRoute_didPop$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.didPop;
Function _TransitionRoute_didPopNext$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.didPopNext;
Function _TransitionRoute_didChangeNext$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.didChangeNext;
Function _TransitionRoute_canTransitionTo$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.canTransitionTo;
Function _TransitionRoute_canTransitionFrom$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.canTransitionFrom;
Function _TransitionRoute_dispose$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.dispose;
Function _TransitionRoute_toString$<T>(
  m.Scope scope,
  TransitionRoute<T> target,
) =>
    target.toString;
Function LocalHistoryEntry_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as LocalHistoryEntry;
Function LocalHistoryEntry_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is LocalHistoryEntry;
void Function()? _LocalHistoryEntry_onRemove$(LocalHistoryEntry target) {
  return target.onRemove;
}

bool _LocalHistoryEntry_impliesAppBarDismissal$(LocalHistoryEntry target) {
  return target.impliesAppBarDismissal;
}

Function _LocalHistoryEntry_remove$(
  m.Scope scope,
  LocalHistoryEntry target,
) =>
    target.remove;
Function ModalRoute_as$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as ModalRoute<T>;
Function ModalRoute_is$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is ModalRoute<T>;
ImageFilter? _ModalRoute_filter$<T>(ModalRoute<T> target) {
  return target.filter;
}

TraversalEdgeBehavior? _ModalRoute_traversalEdgeBehavior$<T>(
    ModalRoute<T> target) {
  return target.traversalEdgeBehavior;
}

bool _ModalRoute_barrierDismissible$<T>(ModalRoute<T> target) {
  return target.barrierDismissible;
}

bool _ModalRoute_semanticsDismissible$<T>(ModalRoute<T> target) {
  return target.semanticsDismissible;
}

Color? _ModalRoute_barrierColor$<T>(ModalRoute<T> target) {
  return target.barrierColor;
}

String? _ModalRoute_barrierLabel$<T>(ModalRoute<T> target) {
  return target.barrierLabel;
}

Curve _ModalRoute_barrierCurve$<T>(ModalRoute<T> target) {
  return target.barrierCurve;
}

bool _ModalRoute_maintainState$<T>(ModalRoute<T> target) {
  return target.maintainState;
}

bool _ModalRoute_offstage$<T>(ModalRoute<T> target) {
  return target.offstage;
}

void _ModalRoute_offstage_set$<T>(
  ModalRoute<T> target,
  bool other,
) {
  target.offstage = other;
}

BuildContext? _ModalRoute_subtreeContext$<T>(ModalRoute<T> target) {
  return target.subtreeContext;
}

Animation<double>? _ModalRoute_animation$<T>(ModalRoute<T> target) {
  return target.animation;
}

Animation<double>? _ModalRoute_secondaryAnimation$<T>(ModalRoute<T> target) {
  return target.secondaryAnimation;
}

bool _ModalRoute_hasScopedWillPopCallback$<T>(ModalRoute<T> target) {
  return target.hasScopedWillPopCallback;
}

bool _ModalRoute_canPop$<T>(ModalRoute<T> target) {
  return target.canPop;
}

bool _ModalRoute_impliesAppBarDismissal$<T>(ModalRoute<T> target) {
  return target.impliesAppBarDismissal;
}

Function _ModalRoute_of$<T extends Object?>(m.Scope scope) => ModalRoute.of<T>;
Function _ModalRoute_setState$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    (m.FunctionPointer fn) {
      void fnProxy() => scope.engine.callFunctionPointer(
            scope,
            fn,
            [],
            {},
          );
      target.setState(fnProxy);
    };
Function _ModalRoute_withName$(m.Scope scope) => ModalRoute.withName;
Function _ModalRoute_buildPage$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.buildPage;
Function _ModalRoute_buildTransitions$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.buildTransitions;
Function _ModalRoute_install$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.install;
Function _ModalRoute_didPush$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.didPush;
Function _ModalRoute_didAdd$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.didAdd;
Function _ModalRoute_willPop$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.willPop;
Function _ModalRoute_addScopedWillPopCallback$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    (m.FunctionPointer callback) {
      Future<bool> callbackProxy() async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            callback,
            [],
            {},
          );
      target.addScopedWillPopCallback(callbackProxy);
    };
Function _ModalRoute_removeScopedWillPopCallback$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    (m.FunctionPointer callback) {
      Future<bool> callbackProxy() async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            callback,
            [],
            {},
          );
      target.removeScopedWillPopCallback(callbackProxy);
    };
Function _ModalRoute_didChangePrevious$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.didChangePrevious;
Function _ModalRoute_changedInternalState$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.changedInternalState;
Function _ModalRoute_changedExternalState$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.changedExternalState;
Function _ModalRoute_buildModalBarrier$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.buildModalBarrier;
Function _ModalRoute_createOverlayEntries$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.createOverlayEntries;
Function _ModalRoute_toString$<T>(
  m.Scope scope,
  ModalRoute<T> target,
) =>
    target.toString;
Function PopupRoute_as$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as PopupRoute<T>;
Function PopupRoute_is$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is PopupRoute<T>;
bool _PopupRoute_opaque$<T>(PopupRoute<T> target) {
  return target.opaque;
}

bool _PopupRoute_maintainState$<T>(PopupRoute<T> target) {
  return target.maintainState;
}

bool _PopupRoute_allowSnapshotting$<T>(PopupRoute<T> target) {
  return target.allowSnapshotting;
}

Function RouteObserver_as$<R extends Route<dynamic>>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as RouteObserver<R>;
Function RouteObserver_is$<R extends Route<dynamic>>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is RouteObserver<R>;
Function _RouteObserver_debugObservingRoute$<R extends Route<dynamic>>(
  m.Scope scope,
  RouteObserver<R> target,
) =>
    target.debugObservingRoute;
Function _RouteObserver_subscribe$<R extends Route<dynamic>>(
  m.Scope scope,
  RouteObserver<R> target,
) =>
    target.subscribe;
Function _RouteObserver_unsubscribe$<R extends Route<dynamic>>(
  m.Scope scope,
  RouteObserver<R> target,
) =>
    target.unsubscribe;
Function _RouteObserver_didPop$<R extends Route<dynamic>>(
  m.Scope scope,
  RouteObserver<R> target,
) =>
    target.didPop;
Function _RouteObserver_didPush$<R extends Route<dynamic>>(
  m.Scope scope,
  RouteObserver<R> target,
) =>
    target.didPush;
Function RouteAware_as$(
  m.Scope scope,
  dynamic target,
) =>
    () => target as RouteAware;
Function RouteAware_is$(
  m.Scope scope,
  dynamic target,
) =>
    () => target is RouteAware;
Function _RouteAware_didPopNext$(
  m.Scope scope,
  RouteAware target,
) =>
    target.didPopNext;
Function _RouteAware_didPush$(
  m.Scope scope,
  RouteAware target,
) =>
    target.didPush;
Function _RouteAware_didPop$(
  m.Scope scope,
  RouteAware target,
) =>
    target.didPop;
Function _RouteAware_didPushNext$(
  m.Scope scope,
  RouteAware target,
) =>
    target.didPushNext;
Function RawDialogRoute_as$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target as RawDialogRoute<T>;
Function RawDialogRoute_is$<T>(
  m.Scope scope,
  dynamic target,
) =>
    () => target is RawDialogRoute<T>;
Offset? _RawDialogRoute_anchorPoint$<T>(RawDialogRoute<T> target) {
  return target.anchorPoint;
}

bool _RawDialogRoute_barrierDismissible$<T>(RawDialogRoute<T> target) {
  return target.barrierDismissible;
}

String? _RawDialogRoute_barrierLabel$<T>(RawDialogRoute<T> target) {
  return target.barrierLabel;
}

Color? _RawDialogRoute_barrierColor$<T>(RawDialogRoute<T> target) {
  return target.barrierColor;
}

Duration _RawDialogRoute_transitionDuration$<T>(RawDialogRoute<T> target) {
  return target.transitionDuration;
}

Function _RawDialogRoute_buildPage$<T>(
  m.Scope scope,
  RawDialogRoute<T> target,
) =>
    target.buildPage;
Function _RawDialogRoute_buildTransitions$<T>(
  m.Scope scope,
  RawDialogRoute<T> target,
) =>
    target.buildTransitions;
Function _showGeneralDialog$(m.Scope scope) => <T extends Object?>({
      Offset? anchorPoint,
      Color? barrierColor,
      bool? barrierDismissible,
      String? barrierLabel,
      required BuildContext context,
      required m.FunctionPointer pageBuilder,
      RouteSettings? routeSettings,
      m.FunctionPointer? transitionBuilder,
      Duration? transitionDuration,
      bool? useRootNavigator,
    }) {
      Widget pageBuilderProxy(
        BuildContext pageBuilder_context,
        Animation<double> pageBuilder_animation,
        Animation<double> pageBuilder_secondaryAnimation,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            pageBuilder,
            [
              pageBuilder_context,
              pageBuilder_animation,
              pageBuilder_secondaryAnimation,
            ],
            {},
          );
      Widget transitionBuilderProxy(
        BuildContext transitionBuilder_context,
        Animation<double> transitionBuilder_animation,
        Animation<double> transitionBuilder_secondaryAnimation,
        Widget transitionBuilder_child,
      ) =>
          scope.engine.callFunctionPointer(
            scope,
            transitionBuilder!,
            [
              transitionBuilder_context,
              transitionBuilder_animation,
              transitionBuilder_secondaryAnimation,
              transitionBuilder_child,
            ],
            {},
          );
      return showGeneralDialog<T>(
        anchorPoint: anchorPoint,
        barrierColor:
            barrierColor == null ? const Color(0x80000000) : barrierColor,
        barrierDismissible:
            barrierDismissible == null ? false : barrierDismissible,
        barrierLabel: barrierLabel,
        context: context,
        pageBuilder: pageBuilderProxy,
        routeSettings: routeSettings,
        transitionBuilder:
            transitionBuilder == null ? null : transitionBuilderProxy,
        transitionDuration: transitionDuration == null
            ? const Duration(milliseconds: 200)
            : transitionDuration,
        useRootNavigator: useRootNavigator == null ? true : useRootNavigator,
      );
    };
