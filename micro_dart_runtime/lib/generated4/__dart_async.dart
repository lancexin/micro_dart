// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:async';
import 'dart:collection' show HashMap;

const libraryMirror = m.LibraryMirror(
  'dart:async',
  {
    'AsyncError.defaultStackTrace': _AsyncError_defaultStackTrace$,
    'Future.wait': _Future_wait$,
    'Future.any': _Future_any$,
    'Future.forEach': _Future_forEach$,
    'Future.doWhile': _Future_doWhile$,
    'Future.then': _Future_then$,
    'Future.catchError': _Future_catchError$,
    'Future.whenComplete': _Future_whenComplete$,
    'Future.timeout': _Future_timeout$,
    'unawaited': _unawaited$,
    'scheduleMicrotask': _scheduleMicrotask$,
    'Stream.castFrom': _Stream_castFrom$,
    'Stream.asBroadcastStream': _Stream_asBroadcastStream$,
    'Stream.listen': _Stream_listen$,
    'Stream.where': _Stream_where$,
    'Stream.map': _Stream_map$,
    'Stream.asyncMap': _Stream_asyncMap$,
    'Stream.asyncExpand': _Stream_asyncExpand$,
    'Stream.handleError': _Stream_handleError$,
    'Stream.expand': _Stream_expand$,
    'Stream.reduce': _Stream_reduce$,
    'Stream.fold': _Stream_fold$,
    'Stream.forEach': _Stream_forEach$,
    'Stream.every': _Stream_every$,
    'Stream.any': _Stream_any$,
    'Stream.takeWhile': _Stream_takeWhile$,
    'Stream.skipWhile': _Stream_skipWhile$,
    'Stream.distinct': _Stream_distinct$,
    'Stream.firstWhere': _Stream_firstWhere$,
    'Stream.lastWhere': _Stream_lastWhere$,
    'Stream.singleWhere': _Stream_singleWhere$,
    'Stream.timeout': _Stream_timeout$,
    'StreamSubscription.onData': _StreamSubscription_onData$,
    'StreamSubscription.onDone': _StreamSubscription_onDone$,
    'StreamView.asBroadcastStream': _StreamView_asBroadcastStream$,
    'StreamView.listen': _StreamView_listen$,
    'StreamTransformer.castFrom': _StreamTransformer_castFrom$,
    'Timer.run': _Timer_run$,
    'ZoneDelegate.run': _ZoneDelegate_run$,
    'ZoneDelegate.runUnary': _ZoneDelegate_runUnary$,
    'ZoneDelegate.runBinary': _ZoneDelegate_runBinary$,
    'ZoneDelegate.registerCallback': _ZoneDelegate_registerCallback$,
    'ZoneDelegate.registerUnaryCallback': _ZoneDelegate_registerUnaryCallback$,
    'ZoneDelegate.registerBinaryCallback':
        _ZoneDelegate_registerBinaryCallback$,
    'ZoneDelegate.scheduleMicrotask': _ZoneDelegate_scheduleMicrotask$,
    'ZoneDelegate.createTimer': _ZoneDelegate_createTimer$,
    'ZoneDelegate.createPeriodicTimer': _ZoneDelegate_createPeriodicTimer$,
    'Zone.root': _Zone_root$,
    'Zone.current': _Zone_current$,
    'Zone.run': _Zone_run$,
    'Zone.runUnary': _Zone_runUnary$,
    'Zone.runBinary': _Zone_runBinary$,
    'Zone.runGuarded': _Zone_runGuarded$,
    'Zone.runUnaryGuarded': _Zone_runUnaryGuarded$,
    'Zone.runBinaryGuarded': _Zone_runBinaryGuarded$,
    'Zone.registerCallback': _Zone_registerCallback$,
    'Zone.registerUnaryCallback': _Zone_registerUnaryCallback$,
    'Zone.registerBinaryCallback': _Zone_registerBinaryCallback$,
    'Zone.bindCallback': _Zone_bindCallback$,
    'Zone.bindUnaryCallback': _Zone_bindUnaryCallback$,
    'Zone.bindBinaryCallback': _Zone_bindBinaryCallback$,
    'Zone.bindCallbackGuarded': _Zone_bindCallbackGuarded$,
    'Zone.bindUnaryCallbackGuarded': _Zone_bindUnaryCallbackGuarded$,
    'Zone.bindBinaryCallbackGuarded': _Zone_bindBinaryCallbackGuarded$,
    'Zone.scheduleMicrotask': _Zone_scheduleMicrotask$,
    'Zone.createTimer': _Zone_createTimer$,
    'Zone.createPeriodicTimer': _Zone_createPeriodicTimer$,
    'runZoned': _runZoned$,
    'runZonedGuarded': _runZonedGuarded$,
  },
  {},
  {
    'AsyncError': m.ClassMirror(
      'AsyncError',
      {'': _AsyncError__$},
      {
        '#as': AsyncError_as$,
        '#is': AsyncError_is$,
        'error': _AsyncError_error$,
        'stackTrace': _AsyncError_stackTrace$,
        'toString': _AsyncError_toString$,
      },
      {},
    ),
    'DeferredLoadException': m.ClassMirror(
      'DeferredLoadException',
      {'': _DeferredLoadException__$},
      {
        '#as': DeferredLoadException_as$,
        '#is': DeferredLoadException_is$,
        'toString': _DeferredLoadException_toString$,
      },
      {},
    ),
    'FutureOr': m.ClassMirror(
      'FutureOr',
      {},
      {
        '#as': FutureOr_as$,
        '#is': FutureOr_is$,
      },
      {},
    ),
    'Future': m.ClassMirror(
      'Future',
      {
        '': _Future__$,
        'microtask': _Future_microtask_$,
        'sync': _Future_sync_$,
        'value': _Future_value_$,
        'error': _Future_error_$,
        'delayed': _Future_delayed_$,
      },
      {
        '#as': Future_as$,
        '#is': Future_is$,
        'asStream': _Future_asStream$,
      },
      {},
    ),
    'TimeoutException': m.ClassMirror(
      'TimeoutException',
      {'': _TimeoutException__$},
      {
        '#as': TimeoutException_as$,
        '#is': TimeoutException_is$,
        'message': _TimeoutException_message$,
        'duration': _TimeoutException_duration$,
        'toString': _TimeoutException_toString$,
      },
      {},
    ),
    'Completer': m.ClassMirror(
      'Completer',
      {
        '': _Completer__$,
        'sync': _Completer_sync_$,
      },
      {
        '#as': Completer_as$,
        '#is': Completer_is$,
        'future': _Completer_future$,
        'isCompleted': _Completer_isCompleted$,
        'complete': _Completer_complete$,
        'completeError': _Completer_completeError$,
      },
      {},
    ),
    'ParallelWaitError': m.ClassMirror(
      'ParallelWaitError',
      {'': _ParallelWaitError__$},
      {
        '#as': ParallelWaitError_as$,
        '#is': ParallelWaitError_is$,
        'values': _ParallelWaitError_values$,
        'errors': _ParallelWaitError_errors$,
        'toString': _ParallelWaitError_toString$,
      },
      {},
    ),
    'Stream': m.ClassMirror(
      'Stream',
      {
        'empty': _Stream_empty_$,
        'value': _Stream_value_$,
        'error': _Stream_error_$,
        'fromFuture': _Stream_fromFuture_$,
        'fromFutures': _Stream_fromFutures_$,
        'fromIterable': _Stream_fromIterable_$,
        'multi': _Stream_multi_$,
        'periodic': _Stream_periodic_$,
        'eventTransformed': _Stream_eventTransformed_$,
      },
      {
        '#as': Stream_as$,
        '#is': Stream_is$,
        'isBroadcast': _Stream_isBroadcast$,
        'length': _Stream_length$,
        'isEmpty': _Stream_isEmpty$,
        'first': _Stream_first$,
        'last': _Stream_last$,
        'single': _Stream_single$,
        'pipe': _Stream_pipe$,
        'transform': _Stream_transform$,
        'join': _Stream_join$,
        'contains': _Stream_contains$,
        'cast': _Stream_cast$,
        'toList': _Stream_toList$,
        'toSet': _Stream_toSet$,
        'drain': _Stream_drain$,
        'take': _Stream_take$,
        'skip': _Stream_skip$,
        'elementAt': _Stream_elementAt$,
      },
      {},
    ),
    'StreamSubscription': m.ClassMirror(
      'StreamSubscription',
      {},
      {
        '#as': StreamSubscription_as$,
        '#is': StreamSubscription_is$,
        'isPaused': _StreamSubscription_isPaused$,
        'cancel': _StreamSubscription_cancel$,
        'onError': _StreamSubscription_onError$,
        'pause': _StreamSubscription_pause$,
        'resume': _StreamSubscription_resume$,
        'asFuture': _StreamSubscription_asFuture$,
      },
      {},
    ),
    'EventSink': m.ClassMirror(
      'EventSink',
      {},
      {
        '#as': EventSink_as$,
        '#is': EventSink_is$,
        'add': _EventSink_add$,
        'addError': _EventSink_addError$,
        'close': _EventSink_close$,
      },
      {},
    ),
    'StreamView': m.ClassMirror(
      'StreamView',
      {'': _StreamView__$},
      {
        '#as': StreamView_as$,
        '#is': StreamView_is$,
        'isBroadcast': _StreamView_isBroadcast$,
      },
      {},
    ),
    'StreamConsumer': m.ClassMirror(
      'StreamConsumer',
      {},
      {
        '#as': StreamConsumer_as$,
        '#is': StreamConsumer_is$,
        'addStream': _StreamConsumer_addStream$,
        'close': _StreamConsumer_close$,
      },
      {},
    ),
    'StreamSink': m.ClassMirror(
      'StreamSink',
      {},
      {
        '#as': StreamSink_as$,
        '#is': StreamSink_is$,
        'done': _StreamSink_done$,
        'close': _StreamSink_close$,
      },
      {},
    ),
    'StreamTransformer': m.ClassMirror(
      'StreamTransformer',
      {
        '': _StreamTransformer__$,
        'fromHandlers': _StreamTransformer_fromHandlers_$,
        'fromBind': _StreamTransformer_fromBind_$,
      },
      {
        '#as': StreamTransformer_as$,
        '#is': StreamTransformer_is$,
        'bind': _StreamTransformer_bind$,
        'cast': _StreamTransformer_cast$,
      },
      {},
    ),
    'StreamTransformerBase': m.ClassMirror(
      'StreamTransformerBase',
      {},
      {
        '#as': StreamTransformerBase_as$,
        '#is': StreamTransformerBase_is$,
        'cast': _StreamTransformerBase_cast$,
      },
      {},
    ),
    'StreamIterator': m.ClassMirror(
      'StreamIterator',
      {'': _StreamIterator__$},
      {
        '#as': StreamIterator_as$,
        '#is': StreamIterator_is$,
        'current': _StreamIterator_current$,
        'moveNext': _StreamIterator_moveNext$,
        'cancel': _StreamIterator_cancel$,
      },
      {},
    ),
    'MultiStreamController': m.ClassMirror(
      'MultiStreamController',
      {},
      {
        '#as': MultiStreamController_as$,
        '#is': MultiStreamController_is$,
        'addSync': _MultiStreamController_addSync$,
        'addErrorSync': _MultiStreamController_addErrorSync$,
        'closeSync': _MultiStreamController_closeSync$,
      },
      {},
    ),
    'StreamController': m.ClassMirror(
      'StreamController',
      {
        '': _StreamController__$,
        'broadcast': _StreamController_broadcast_$,
      },
      {
        '#as': StreamController_as$,
        '#is': StreamController_is$,
        'onListen': _StreamController_onListen$,
        'onPause': _StreamController_onPause$,
        'onResume': _StreamController_onResume$,
        'onCancel': _StreamController_onCancel$,
        'stream': _StreamController_stream$,
        'sink': _StreamController_sink$,
        'isClosed': _StreamController_isClosed$,
        'isPaused': _StreamController_isPaused$,
        'hasListener': _StreamController_hasListener$,
        'done': _StreamController_done$,
        'add': _StreamController_add$,
        'addError': _StreamController_addError$,
        'close': _StreamController_close$,
        'addStream': _StreamController_addStream$,
      },
      {
        'onListen': _StreamController_onListen_set$,
        'onPause': _StreamController_onPause_set$,
        'onResume': _StreamController_onResume_set$,
        'onCancel': _StreamController_onCancel_set$,
      },
    ),
    'SynchronousStreamController': m.ClassMirror(
      'SynchronousStreamController',
      {},
      {
        '#as': SynchronousStreamController_as$,
        '#is': SynchronousStreamController_is$,
        'add': _SynchronousStreamController_add$,
        'addError': _SynchronousStreamController_addError$,
        'close': _SynchronousStreamController_close$,
      },
      {},
    ),
    'Timer': m.ClassMirror(
      'Timer',
      {
        '': _Timer__$,
        'periodic': _Timer_periodic_$,
      },
      {
        '#as': Timer_as$,
        '#is': Timer_is$,
        'tick': _Timer_tick$,
        'isActive': _Timer_isActive$,
        'cancel': _Timer_cancel$,
      },
      {},
    ),
    'ZoneSpecification': m.ClassMirror(
      'ZoneSpecification',
      {
        '': _ZoneSpecification__$,
        'from': _ZoneSpecification_from_$,
      },
      {
        '#as': ZoneSpecification_as$,
        '#is': ZoneSpecification_is$,
        'handleUncaughtError': _ZoneSpecification_handleUncaughtError$,
        'run': _ZoneSpecification_run$,
        'runUnary': _ZoneSpecification_runUnary$,
        'runBinary': _ZoneSpecification_runBinary$,
        'registerCallback': _ZoneSpecification_registerCallback$,
        'registerUnaryCallback': _ZoneSpecification_registerUnaryCallback$,
        'registerBinaryCallback': _ZoneSpecification_registerBinaryCallback$,
        'errorCallback': _ZoneSpecification_errorCallback$,
        'scheduleMicrotask': _ZoneSpecification_scheduleMicrotask$,
        'createTimer': _ZoneSpecification_createTimer$,
        'createPeriodicTimer': _ZoneSpecification_createPeriodicTimer$,
        'print': _ZoneSpecification_print$,
        'fork': _ZoneSpecification_fork$,
      },
      {},
    ),
    'ZoneDelegate': m.ClassMirror(
      'ZoneDelegate',
      {},
      {
        '#as': ZoneDelegate_as$,
        '#is': ZoneDelegate_is$,
        'handleUncaughtError': _ZoneDelegate_handleUncaughtError$,
        'errorCallback': _ZoneDelegate_errorCallback$,
        'print': _ZoneDelegate_print$,
        'fork': _ZoneDelegate_fork$,
      },
      {},
    ),
    'Zone': m.ClassMirror(
      'Zone',
      {},
      {
        '#as': Zone_as$,
        '#is': Zone_is$,
        'parent': _Zone_parent$,
        'errorZone': _Zone_errorZone$,
        'handleUncaughtError': _Zone_handleUncaughtError$,
        'inSameErrorZone': _Zone_inSameErrorZone$,
        'fork': _Zone_fork$,
        'errorCallback': _Zone_errorCallback$,
        'print': _Zone_print$,
        '[]': _Zone_$index$$,
      },
      {},
    ),
  },
);
Function AsyncError_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as AsyncError;
Function AsyncError_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is AsyncError;
Object _AsyncError_error$(AsyncError target$) {
  return target$.error;
}

StackTrace _AsyncError_stackTrace$(AsyncError target$) {
  return target$.stackTrace;
}

Function _AsyncError__$(m.Scope scope$) => (
      Object error,
      StackTrace? stackTrace,
    ) {
      return AsyncError(
        error,
        stackTrace,
      );
    };
Function _AsyncError_defaultStackTrace$(m.Scope scope$) =>
    AsyncError.defaultStackTrace;
Function _AsyncError_toString$(
  m.Scope scope$,
  AsyncError target$,
) =>
    target$.toString;
Function DeferredLoadException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as DeferredLoadException;
Function DeferredLoadException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is DeferredLoadException;
Function _DeferredLoadException__$(m.Scope scope$) => (String message) {
      return DeferredLoadException(message);
    };
Function _DeferredLoadException_toString$(
  m.Scope scope$,
  DeferredLoadException target$,
) =>
    target$.toString;
Function FutureOr_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as FutureOr<T>;
Function FutureOr_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is FutureOr<T>;
Function Future_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Future<T>;
Function Future_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Future<T>;
Function _Future__$(m.Scope scope$) => (m.FunctionPointer computation) {
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation,
            [],
            {},
          );
      return Future(computationProxy);
    };
Function _Future_microtask_$(m.Scope scope$) =>
    (m.FunctionPointer computation) {
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation,
            [],
            {},
          );
      return Future.microtask(computationProxy);
    };
Function _Future_sync_$(m.Scope scope$) => (m.FunctionPointer computation) {
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation,
            [],
            {},
          );
      return Future.sync(computationProxy);
    };
Function _Future_value_$(m.Scope scope$) => Future.value;
Function _Future_error_$(m.Scope scope$) => Future.error;
Function _Future_delayed_$(m.Scope scope$) => (
      Duration duration, [
      m.FunctionPointer? computation,
    ]) {
      if (computation == null) {
        return Future.delayed(duration);
      }
      FutureOr computationProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            computation!,
            [],
            {},
          );
      return Future.delayed(
        duration,
        computation == null ? null : computationProxy,
      );
    };
Function _Future_wait$(m.Scope scope$) => (
      Iterable futures, {
      bool? eagerError,
      m.FunctionPointer? cleanUp,
    }) {
      void cleanUpProxy(dynamic successValue) =>
          scope$.engine.callFunctionPointer(
            scope$,
            cleanUp!,
            [successValue],
            {},
          );
      return Future.wait(
        Iterable.castFrom(futures),
        cleanUp: cleanUp == null ? null : cleanUpProxy,
        eagerError: eagerError ?? false,
      );
    };
Function _Future_any$<T>(m.Scope scope$) => Future.any<T>;
Function _Future_forEach$(m.Scope scope$) => (
      Iterable elements,
      m.FunctionPointer action,
    ) {
      FutureOr<dynamic> actionProxy(dynamic element) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [element],
            {},
          );
      return Future.forEach(
        Iterable.castFrom(elements),
        actionProxy,
      );
    };
Function _Future_doWhile$(m.Scope scope$) => (m.FunctionPointer action) {
      FutureOr<bool> actionProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [],
            {},
          );
      return Future.doWhile(actionProxy);
    };
Function _Future_then$(
  m.Scope scope$,
  Future target$,
) =>
    (
      m.FunctionPointer onValue, {
      Function? onError,
    }) {
      FutureOr onValueProxy(dynamic value) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onValue,
            [value],
            {},
          );
      return target$.then(
        onValueProxy,
        onError: onError,
      );
    };
Function _Future_catchError$(
  m.Scope scope$,
  Future target$,
) =>
    (
      Function onError, {
      m.FunctionPointer? test,
    }) {
      bool testProxy(Object error) => scope$.engine.callFunctionPointer(
            scope$,
            test!,
            [error],
            {},
          );
      return target$.catchError(
        onError,
        test: test == null ? null : testProxy,
      );
    };
Function _Future_whenComplete$(
  m.Scope scope$,
  Future target$,
) =>
    (m.FunctionPointer action) {
      FutureOr<void> actionProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            action,
            [],
            {},
          );
      return target$.whenComplete(actionProxy);
    };
Function _Future_asStream$<T>(
  m.Scope scope$,
  Future<T> target$,
) =>
    target$.asStream;
Function _Future_timeout$(
  m.Scope scope$,
  Future target$,
) =>
    (
      Duration timeLimit, {
      m.FunctionPointer? onTimeout,
    }) {
      FutureOr onTimeoutProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onTimeout!,
            [],
            {},
          );
      return target$.timeout(
        timeLimit,
        onTimeout: onTimeout == null ? null : onTimeoutProxy,
      );
    };
Function TimeoutException_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as TimeoutException;
Function TimeoutException_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is TimeoutException;
String? _TimeoutException_message$(TimeoutException target$) {
  return target$.message;
}

Duration? _TimeoutException_duration$(TimeoutException target$) {
  return target$.duration;
}

Function _TimeoutException__$(m.Scope scope$) => (
      String? message, [
      Duration? duration,
    ]) {
      if (duration == null) {
        return TimeoutException(message);
      }
      return TimeoutException(
        message,
        duration!,
      );
    };
Function _TimeoutException_toString$(
  m.Scope scope$,
  TimeoutException target$,
) =>
    target$.toString;
Function Completer_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Completer<T>;
Function Completer_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Completer<T>;
Future<T> _Completer_future$<T>(Completer<T> target$) {
  return target$.future;
}

bool _Completer_isCompleted$<T>(Completer<T> target$) {
  return target$.isCompleted;
}

Function _Completer__$(m.Scope scope$) => () {
      return Completer();
    };
Function _Completer_sync_$(m.Scope scope$) => Completer.sync;
Function _Completer_complete$<T>(
  m.Scope scope$,
  Completer<T> target$,
) =>
    target$.complete;
Function _Completer_completeError$<T>(
  m.Scope scope$,
  Completer<T> target$,
) =>
    target$.completeError;
Function _unawaited$(m.Scope scope$) => unawaited;
Function ParallelWaitError_as$<V, E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ParallelWaitError<V, E>;
Function ParallelWaitError_is$<V, E>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ParallelWaitError<V, E>;
V _ParallelWaitError_values$<V, E>(ParallelWaitError<V, E> target$) {
  return target$.values;
}

E _ParallelWaitError_errors$<V, E>(ParallelWaitError<V, E> target$) {
  return target$.errors;
}

Function _ParallelWaitError__$(m.Scope scope$) => (
      dynamic values,
      dynamic errors,
    ) {
      return ParallelWaitError(
        values,
        errors,
      );
    };
Function _ParallelWaitError_toString$<V, E>(
  m.Scope scope$,
  ParallelWaitError<V, E> target$,
) =>
    target$.toString;
Function _scheduleMicrotask$(m.Scope scope$) => (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      scheduleMicrotask(callbackProxy);
    };
Function Stream_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Stream<T>;
Function Stream_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Stream<T>;
bool _Stream_isBroadcast$<T>(Stream<T> target$) {
  return target$.isBroadcast;
}

Future<int> _Stream_length$<T>(Stream<T> target$) {
  return target$.length;
}

Future<bool> _Stream_isEmpty$<T>(Stream<T> target$) {
  return target$.isEmpty;
}

Future<T> _Stream_first$<T>(Stream<T> target$) {
  return target$.first;
}

Future<T> _Stream_last$<T>(Stream<T> target$) {
  return target$.last;
}

Future<T> _Stream_single$<T>(Stream<T> target$) {
  return target$.single;
}

Function _Stream_empty_$(m.Scope scope$) => Stream.empty;
Function _Stream_value_$(m.Scope scope$) => Stream.value;
Function _Stream_error_$(m.Scope scope$) => Stream.error;
Function _Stream_fromFuture_$(m.Scope scope$) => Stream.fromFuture;
Function _Stream_fromFutures_$(m.Scope scope$) => Stream.fromFutures;
Function _Stream_fromIterable_$(m.Scope scope$) => Stream.fromIterable;
Function _Stream_multi_$(m.Scope scope$) => (
      m.FunctionPointer onListen, {
      bool? isBroadcast,
    }) {
      void onListenProxy(MultiStreamController $p0) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen,
            [$p0],
            {},
          );
      return Stream.multi(
        onListenProxy,
        isBroadcast: isBroadcast ?? false,
      );
    };
Function _Stream_periodic_$(m.Scope scope$) => (
      Duration period, [
      m.FunctionPointer? computation,
    ]) {
      if (computation == null) {
        return Stream.periodic(period);
      }
      dynamic computationProxy(int computationCount) =>
          scope$.engine.callFunctionPointer(
            scope$,
            computation!,
            [computationCount],
            {},
          );
      return Stream.periodic(
        period,
        computation == null ? null : computationProxy,
      );
    };
Function _Stream_eventTransformed_$(m.Scope scope$) => (
      Stream<dynamic> source,
      m.FunctionPointer mapSink,
    ) {
      EventSink<dynamic> mapSinkProxy(EventSink sink) =>
          scope$.engine.callFunctionPointer(
            scope$,
            mapSink,
            [sink],
            {},
          );
      return Stream.eventTransformed(
        source,
        mapSinkProxy,
      );
    };
Function _Stream_castFrom$<S, T>(m.Scope scope$) => Stream.castFrom<S, T>;
Function _Stream_asBroadcastStream$(
  m.Scope scope$,
  Stream target$,
) =>
    ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onCancel,
    }) {
      void onCancelProxy(StreamSubscription subscription) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onCancel!,
            [subscription],
            {},
          );
      void onListenProxy(StreamSubscription subscription) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [subscription],
            {},
          );
      return target$.asBroadcastStream(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
      );
    };
Function _Stream_listen$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer? onData, {
      Function? onError,
      m.FunctionPointer? onDone,
      bool? cancelOnError,
    }) {
      void onDataProxy(dynamic event) => scope$.engine.callFunctionPointer(
            scope$,
            onData!,
            [event],
            {},
          );
      void onDoneProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDone!,
            [],
            {},
          );
      return target$.listen(
        onData == null ? null : onDataProxy,
        cancelOnError: cancelOnError,
        onDone: onDone == null ? null : onDoneProxy,
        onError: onError,
      );
    };
Function _Stream_where$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic event) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [event],
            {},
          );
      return target$.where(testProxy);
    };
Function _Stream_map$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      dynamic convertProxy(dynamic event) => scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [event],
            {},
          );
      return target$.map(convertProxy);
    };
Function _Stream_asyncMap$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      FutureOr convertProxy(dynamic event) async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            convert,
            [event],
            {},
          );
      return target$.asyncMap(convertProxy);
    };
Function _Stream_asyncExpand$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      Stream? convertProxy(dynamic event) => scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [event],
            {},
          );
      return target$.asyncExpand(convertProxy);
    };
Function _Stream_handleError$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      Function onError, {
      m.FunctionPointer? test,
    }) {
      bool testProxy(dynamic error) => scope$.engine.callFunctionPointer(
            scope$,
            test!,
            [error],
            {},
          );
      return target$.handleError(
        onError,
        test: test == null ? null : testProxy,
      );
    };
Function _Stream_expand$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer convert) {
      Iterable convertProxy(dynamic element) =>
          scope$.engine.callFunctionPointer(
            scope$,
            convert,
            [element],
            {},
          );
      return target$.expand(convertProxy);
    };
Function _Stream_pipe$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.pipe;
Function _Stream_transform$<T, S>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.transform<S>;
Function _Stream_reduce$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer combine) {
      dynamic combineProxy(
        dynamic previous,
        dynamic element,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              previous,
              element,
            ],
            {},
          );
      return target$.reduce(combineProxy);
    };
Function _Stream_fold$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      dynamic initialValue,
      m.FunctionPointer combine,
    ) {
      dynamic combineProxy(
        dynamic previous,
        dynamic element,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            combine,
            [
              previous,
              element,
            ],
            {},
          );
      return target$.fold(
        initialValue,
        combineProxy,
      );
    };
Function _Stream_join$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.join;
Function _Stream_contains$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.contains;
Function _Stream_forEach$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            action,
            [element],
            {},
          );
      return target$.forEach(actionProxy);
    };
Function _Stream_every$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      return target$.every(testProxy);
    };
Function _Stream_any$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      return target$.any(testProxy);
    };
Function _Stream_cast$<T, R>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.cast<R>;
Function _Stream_toList$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.toList;
Function _Stream_toSet$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.toSet;
Function _Stream_drain$<T, E>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.drain<E>;
Function _Stream_take$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.take;
Function _Stream_takeWhile$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      return target$.takeWhile(testProxy);
    };
Function _Stream_skip$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.skip;
Function _Stream_skipWhile$(
  m.Scope scope$,
  Stream target$,
) =>
    (m.FunctionPointer test) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      return target$.skipWhile(testProxy);
    };
Function _Stream_distinct$(
  m.Scope scope$,
  Stream target$,
) =>
    ([m.FunctionPointer? equals]) {
      if (equals == null) {
        return target$.distinct();
      }
      bool equalsProxy(
        dynamic previous,
        dynamic next,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            equals!,
            [
              previous,
              next,
            ],
            {},
          );
      return target$.distinct(equals == null ? null : equalsProxy);
    };
Function _Stream_firstWhere$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.firstWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Stream_lastWhere$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.lastWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Stream_singleWhere$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      m.FunctionPointer test, {
      m.FunctionPointer? orElse,
    }) {
      bool testProxy(dynamic element) => scope$.engine.callFunctionPointer(
            scope$,
            test,
            [element],
            {},
          );
      dynamic orElseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            orElse!,
            [],
            {},
          );
      return target$.singleWhere(
        testProxy,
        orElse: orElse == null ? null : orElseProxy,
      );
    };
Function _Stream_elementAt$<T>(
  m.Scope scope$,
  Stream<T> target$,
) =>
    target$.elementAt;
Function _Stream_timeout$(
  m.Scope scope$,
  Stream target$,
) =>
    (
      Duration timeLimit, {
      m.FunctionPointer? onTimeout,
    }) {
      void onTimeoutProxy(EventSink sink) => scope$.engine.callFunctionPointer(
            scope$,
            onTimeout!,
            [sink],
            {},
          );
      return target$.timeout(
        timeLimit,
        onTimeout: onTimeout == null ? null : onTimeoutProxy,
      );
    };
Function StreamSubscription_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamSubscription<T>;
Function StreamSubscription_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamSubscription<T>;
bool _StreamSubscription_isPaused$<T>(StreamSubscription<T> target$) {
  return target$.isPaused;
}

Function _StreamSubscription_cancel$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.cancel;
Function _StreamSubscription_onData$(
  m.Scope scope$,
  StreamSubscription target$,
) =>
    (m.FunctionPointer? handleData) {
      void handleDataProxy(dynamic data) => scope$.engine.callFunctionPointer(
            scope$,
            handleData!,
            [data],
            {},
          );
      target$.onData(handleData == null ? null : handleDataProxy);
    };
Function _StreamSubscription_onError$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.onError;
Function _StreamSubscription_onDone$(
  m.Scope scope$,
  StreamSubscription target$,
) =>
    (m.FunctionPointer? handleDone) {
      void handleDoneProxy() => scope$.engine.callFunctionPointer(
            scope$,
            handleDone!,
            [],
            {},
          );
      target$.onDone(handleDone == null ? null : handleDoneProxy);
    };
Function _StreamSubscription_pause$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.pause;
Function _StreamSubscription_resume$<T>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.resume;
Function _StreamSubscription_asFuture$<T, E>(
  m.Scope scope$,
  StreamSubscription<T> target$,
) =>
    target$.asFuture<E>;
Function EventSink_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as EventSink<T>;
Function EventSink_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is EventSink<T>;
Function _EventSink_add$<T>(
  m.Scope scope$,
  EventSink<T> target$,
) =>
    target$.add;
Function _EventSink_addError$<T>(
  m.Scope scope$,
  EventSink<T> target$,
) =>
    target$.addError;
Function _EventSink_close$<T>(
  m.Scope scope$,
  EventSink<T> target$,
) =>
    target$.close;
Function StreamView_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamView<T>;
Function StreamView_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamView<T>;
bool _StreamView_isBroadcast$<T>(StreamView<T> target$) {
  return target$.isBroadcast;
}

Function _StreamView__$(m.Scope scope$) => (Stream stream) {
      return StreamView(stream);
    };
Function _StreamView_asBroadcastStream$(
  m.Scope scope$,
  StreamView target$,
) =>
    ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onCancel,
    }) {
      void onCancelProxy(StreamSubscription subscription) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onCancel!,
            [subscription],
            {},
          );
      void onListenProxy(StreamSubscription subscription) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [subscription],
            {},
          );
      return target$.asBroadcastStream(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
      );
    };
Function _StreamView_listen$(
  m.Scope scope$,
  StreamView target$,
) =>
    (
      m.FunctionPointer? onData, {
      Function? onError,
      m.FunctionPointer? onDone,
      bool? cancelOnError,
    }) {
      void onDataProxy(dynamic value) => scope$.engine.callFunctionPointer(
            scope$,
            onData!,
            [value],
            {},
          );
      void onDoneProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onDone!,
            [],
            {},
          );
      return target$.listen(
        onData == null ? null : onDataProxy,
        cancelOnError: cancelOnError,
        onDone: onDone == null ? null : onDoneProxy,
        onError: onError,
      );
    };
Function StreamConsumer_as$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamConsumer<S>;
Function StreamConsumer_is$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamConsumer<S>;
Function _StreamConsumer_addStream$<S>(
  m.Scope scope$,
  StreamConsumer<S> target$,
) =>
    target$.addStream;
Function _StreamConsumer_close$<S>(
  m.Scope scope$,
  StreamConsumer<S> target$,
) =>
    target$.close;
Function StreamSink_as$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamSink<S>;
Function StreamSink_is$<S>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamSink<S>;
Future<dynamic> _StreamSink_done$<S>(StreamSink<S> target$) {
  return target$.done;
}

Function _StreamSink_close$<S>(
  m.Scope scope$,
  StreamSink<S> target$,
) =>
    target$.close;
Function StreamTransformer_as$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamTransformer<S, T>;
Function StreamTransformer_is$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamTransformer<S, T>;
Function _StreamTransformer__$(m.Scope scope$) => (m.FunctionPointer onListen) {
      StreamSubscription onListenProxy(
        Stream stream,
        bool cancelOnError,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onListen,
            [
              stream,
              cancelOnError,
            ],
            {},
          );
      return StreamTransformer(onListenProxy);
    };
Function _StreamTransformer_fromHandlers_$(m.Scope scope$) => ({
      m.FunctionPointer? handleData,
      m.FunctionPointer? handleError,
      m.FunctionPointer? handleDone,
    }) {
      void handleDataProxy(
        dynamic data,
        EventSink sink,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleData!,
            [
              data,
              sink,
            ],
            {},
          );
      void handleDoneProxy(EventSink sink) => scope$.engine.callFunctionPointer(
            scope$,
            handleDone!,
            [sink],
            {},
          );
      void handleErrorProxy(
        Object error,
        StackTrace stackTrace,
        EventSink sink,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleError!,
            [
              error,
              stackTrace,
              sink,
            ],
            {},
          );
      return StreamTransformer.fromHandlers(
        handleData: handleData == null ? null : handleDataProxy,
        handleDone: handleDone == null ? null : handleDoneProxy,
        handleError: handleError == null ? null : handleErrorProxy,
      );
    };
Function _StreamTransformer_fromBind_$(m.Scope scope$) =>
    (m.FunctionPointer bind) {
      Stream bindProxy(Stream $p0) => scope$.engine.callFunctionPointer(
            scope$,
            bind,
            [$p0],
            {},
          );
      return StreamTransformer.fromBind(bindProxy);
    };
Function _StreamTransformer_castFrom$<SS, ST, TS, TT>(m.Scope scope$) =>
    StreamTransformer.castFrom<SS, ST, TS, TT>;
Function _StreamTransformer_bind$<S, T>(
  m.Scope scope$,
  StreamTransformer<S, T> target$,
) =>
    target$.bind;
Function _StreamTransformer_cast$<S, T, RS, RT>(
  m.Scope scope$,
  StreamTransformer<S, T> target$,
) =>
    target$.cast<RS, RT>;
Function StreamTransformerBase_as$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamTransformerBase<S, T>;
Function StreamTransformerBase_is$<S, T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamTransformerBase<S, T>;
Function _StreamTransformerBase_cast$<S, T, RS, RT>(
  m.Scope scope$,
  StreamTransformerBase<S, T> target$,
) =>
    target$.cast<RS, RT>;
Function StreamIterator_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamIterator<T>;
Function StreamIterator_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamIterator<T>;
T _StreamIterator_current$<T>(StreamIterator<T> target$) {
  return target$.current;
}

Function _StreamIterator__$(m.Scope scope$) => (Stream stream) {
      return StreamIterator(stream);
    };
Function _StreamIterator_moveNext$<T>(
  m.Scope scope$,
  StreamIterator<T> target$,
) =>
    target$.moveNext;
Function _StreamIterator_cancel$<T>(
  m.Scope scope$,
  StreamIterator<T> target$,
) =>
    target$.cancel;
Function MultiStreamController_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as MultiStreamController<T>;
Function MultiStreamController_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is MultiStreamController<T>;
Function _MultiStreamController_addSync$<T>(
  m.Scope scope$,
  MultiStreamController<T> target$,
) =>
    target$.addSync;
Function _MultiStreamController_addErrorSync$<T>(
  m.Scope scope$,
  MultiStreamController<T> target$,
) =>
    target$.addErrorSync;
Function _MultiStreamController_closeSync$<T>(
  m.Scope scope$,
  MultiStreamController<T> target$,
) =>
    target$.closeSync;
Function StreamController_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as StreamController<T>;
Function StreamController_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is StreamController<T>;
void Function()? _StreamController_onListen$<T>(StreamController<T> target$) {
  return target$.onListen;
}

Function _StreamController_onListen_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onListen) {
      void _onListenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onListen!,
            [],
            {},
          );
      target$.onListen = (_onListen == null ? null : _onListenProxy);
    };
void Function()? _StreamController_onPause$<T>(StreamController<T> target$) {
  return target$.onPause;
}

Function _StreamController_onPause_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onPause) {
      void _onPauseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onPause!,
            [],
            {},
          );
      target$.onPause = (_onPause == null ? null : _onPauseProxy);
    };
void Function()? _StreamController_onResume$<T>(StreamController<T> target$) {
  return target$.onResume;
}

Function _StreamController_onResume_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onResume) {
      void _onResumeProxy() => scope$.engine.callFunctionPointer(
            scope$,
            _onResume!,
            [],
            {},
          );
      target$.onResume = (_onResume == null ? null : _onResumeProxy);
    };
FutureOr<void> Function()? _StreamController_onCancel$<T>(
    StreamController<T> target$) {
  return target$.onCancel;
}

Function _StreamController_onCancel_set$(
  m.Scope scope$,
  StreamController target$,
) =>
    (m.FunctionPointer? _onCancel) {
      FutureOr<void> _onCancelProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            _onCancel!,
            [],
            {},
          );
      target$.onCancel = (_onCancel == null ? null : _onCancelProxy);
    };
Stream<T> _StreamController_stream$<T>(StreamController<T> target$) {
  return target$.stream;
}

StreamSink<T> _StreamController_sink$<T>(StreamController<T> target$) {
  return target$.sink;
}

bool _StreamController_isClosed$<T>(StreamController<T> target$) {
  return target$.isClosed;
}

bool _StreamController_isPaused$<T>(StreamController<T> target$) {
  return target$.isPaused;
}

bool _StreamController_hasListener$<T>(StreamController<T> target$) {
  return target$.hasListener;
}

Future<dynamic> _StreamController_done$<T>(StreamController<T> target$) {
  return target$.done;
}

Function _StreamController__$(m.Scope scope$) => ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onPause,
      m.FunctionPointer? onResume,
      m.FunctionPointer? onCancel,
      bool? sync,
    }) {
      FutureOr<void> onCancelProxy() async =>
          await scope$.engine.callFunctionPointerAsync(
            scope$,
            onCancel!,
            [],
            {},
          );
      void onListenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [],
            {},
          );
      void onPauseProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onPause!,
            [],
            {},
          );
      void onResumeProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onResume!,
            [],
            {},
          );
      return StreamController(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
        onPause: onPause == null ? null : onPauseProxy,
        onResume: onResume == null ? null : onResumeProxy,
        sync: sync ?? false,
      );
    };
Function _StreamController_broadcast_$(m.Scope scope$) => ({
      m.FunctionPointer? onListen,
      m.FunctionPointer? onCancel,
      bool? sync,
    }) {
      void onCancelProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onCancel!,
            [],
            {},
          );
      void onListenProxy() => scope$.engine.callFunctionPointer(
            scope$,
            onListen!,
            [],
            {},
          );
      return StreamController.broadcast(
        onCancel: onCancel == null ? null : onCancelProxy,
        onListen: onListen == null ? null : onListenProxy,
        sync: sync ?? false,
      );
    };
Function _StreamController_add$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.add;
Function _StreamController_addError$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.addError;
Function _StreamController_close$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.close;
Function _StreamController_addStream$<T>(
  m.Scope scope$,
  StreamController<T> target$,
) =>
    target$.addStream;
Function SynchronousStreamController_as$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as SynchronousStreamController<T>;
Function SynchronousStreamController_is$<T>(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is SynchronousStreamController<T>;
Function _SynchronousStreamController_add$<T>(
  m.Scope scope$,
  SynchronousStreamController<T> target$,
) =>
    target$.add;
Function _SynchronousStreamController_addError$<T>(
  m.Scope scope$,
  SynchronousStreamController<T> target$,
) =>
    target$.addError;
Function _SynchronousStreamController_close$<T>(
  m.Scope scope$,
  SynchronousStreamController<T> target$,
) =>
    target$.close;
Function Timer_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Timer;
Function Timer_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Timer;
int _Timer_tick$(Timer target$) {
  return target$.tick;
}

bool _Timer_isActive$(Timer target$) {
  return target$.isActive;
}

Function _Timer__$(m.Scope scope$) => (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return Timer(
        duration,
        callbackProxy,
      );
    };
Function _Timer_periodic_$(m.Scope scope$) => (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy(Timer timer) => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [timer],
            {},
          );
      return Timer.periodic(
        duration,
        callbackProxy,
      );
    };
Function _Timer_run$(m.Scope scope$) => (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      Timer.run(callbackProxy);
    };
Function _Timer_cancel$(
  m.Scope scope$,
  Timer target$,
) =>
    target$.cancel;
Function ZoneSpecification_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ZoneSpecification;
Function ZoneSpecification_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ZoneSpecification;
void Function(Zone, ZoneDelegate, Zone, Object, StackTrace)?
    _ZoneSpecification_handleUncaughtError$(ZoneSpecification target$) {
  return target$.handleUncaughtError;
}

R Function<R>(Zone, ZoneDelegate, Zone, R Function())? _ZoneSpecification_run$(
    ZoneSpecification target$) {
  return target$.run;
}

R Function<R, T>(Zone, ZoneDelegate, Zone, R Function(T), T)?
    _ZoneSpecification_runUnary$(ZoneSpecification target$) {
  return target$.runUnary;
}

R Function<R, T1, T2>(Zone, ZoneDelegate, Zone, R Function(T1, T2), T1, T2)?
    _ZoneSpecification_runBinary$(ZoneSpecification target$) {
  return target$.runBinary;
}

R Function() Function<R>(Zone, ZoneDelegate, Zone, R Function())?
    _ZoneSpecification_registerCallback$(ZoneSpecification target$) {
  return target$.registerCallback;
}

R Function(T) Function<R, T>(Zone, ZoneDelegate, Zone, R Function(T))?
    _ZoneSpecification_registerUnaryCallback$(ZoneSpecification target$) {
  return target$.registerUnaryCallback;
}

R Function(T1, T2) Function<R, T1, T2>(
        Zone, ZoneDelegate, Zone, R Function(T1, T2))?
    _ZoneSpecification_registerBinaryCallback$(ZoneSpecification target$) {
  return target$.registerBinaryCallback;
}

AsyncError? Function(Zone, ZoneDelegate, Zone, Object, StackTrace?)?
    _ZoneSpecification_errorCallback$(ZoneSpecification target$) {
  return target$.errorCallback;
}

void Function(Zone, ZoneDelegate, Zone, void Function())?
    _ZoneSpecification_scheduleMicrotask$(ZoneSpecification target$) {
  return target$.scheduleMicrotask;
}

Timer Function(Zone, ZoneDelegate, Zone, Duration, void Function())?
    _ZoneSpecification_createTimer$(ZoneSpecification target$) {
  return target$.createTimer;
}

Timer Function(Zone, ZoneDelegate, Zone, Duration, void Function(Timer))?
    _ZoneSpecification_createPeriodicTimer$(ZoneSpecification target$) {
  return target$.createPeriodicTimer;
}

void Function(Zone, ZoneDelegate, Zone, String)? _ZoneSpecification_print$(
    ZoneSpecification target$) {
  return target$.print;
}

Zone Function(
        Zone, ZoneDelegate, Zone, ZoneSpecification?, Map<Object?, Object?>?)?
    _ZoneSpecification_fork$(ZoneSpecification target$) {
  return target$.fork;
}

Function _ZoneSpecification__$(m.Scope scope$) => ({
      m.FunctionPointer? handleUncaughtError,
      m.FunctionPointer? run,
      m.FunctionPointer? runUnary,
      m.FunctionPointer? runBinary,
      m.FunctionPointer? registerCallback,
      m.FunctionPointer? registerUnaryCallback,
      m.FunctionPointer? registerBinaryCallback,
      m.FunctionPointer? errorCallback,
      m.FunctionPointer? scheduleMicrotask,
      m.FunctionPointer? createTimer,
      m.FunctionPointer? createPeriodicTimer,
      m.FunctionPointer? print,
      m.FunctionPointer? fork,
    }) {
      Timer createPeriodicTimerProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Duration period,
        void Function(Timer) f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createPeriodicTimer!,
            [
              self,
              parent,
              zone,
              period,
              f,
            ],
            {},
          );
      Timer createTimerProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Duration duration,
        void Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createTimer!,
            [
              self,
              parent,
              zone,
              duration,
              f,
            ],
            {},
          );
      AsyncError? errorCallbackProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Object error,
        StackTrace? stackTrace,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            errorCallback!,
            [
              self,
              parent,
              zone,
              error,
              stackTrace,
            ],
            {},
          );
      Zone forkProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        ZoneSpecification? specification,
        Map? zoneValues,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            fork!,
            [
              self,
              parent,
              zone,
              specification,
              zoneValues,
            ],
            {},
          );
      void handleUncaughtErrorProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Object error,
        StackTrace stackTrace,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleUncaughtError!,
            [
              self,
              parent,
              zone,
              error,
              stackTrace,
            ],
            {},
          );
      void printProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        String line,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            print!,
            [
              self,
              parent,
              zone,
              line,
            ],
            {},
          );
      R Function(T1, T2) registerBinaryCallbackProxy<R, T1, T2>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T1, T2) f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerBinaryCallback!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R Function() registerCallbackProxy<R>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerCallback!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R Function(T) registerUnaryCallbackProxy<R, T>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T) f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerUnaryCallback!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R runProxy<R>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            run!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R runBinaryProxy<R, T1, T2>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T1, T2) f,
        dynamic arg1,
        dynamic arg2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runBinary!,
            [
              self,
              parent,
              zone,
              f,
              arg1,
              arg2,
            ],
            {},
          );
      R runUnaryProxy<R, T>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T) f,
        dynamic arg,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runUnary!,
            [
              self,
              parent,
              zone,
              f,
              arg,
            ],
            {},
          );
      void scheduleMicrotaskProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        void Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            scheduleMicrotask!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      return ZoneSpecification(
        createPeriodicTimer:
            createPeriodicTimer == null ? null : createPeriodicTimerProxy,
        createTimer: createTimer == null ? null : createTimerProxy,
        errorCallback: errorCallback == null ? null : errorCallbackProxy,
        fork: fork == null ? null : forkProxy,
        handleUncaughtError:
            handleUncaughtError == null ? null : handleUncaughtErrorProxy,
        print: print == null ? null : printProxy,
        registerBinaryCallback:
            registerBinaryCallback == null ? null : registerBinaryCallbackProxy,
        registerCallback:
            registerCallback == null ? null : registerCallbackProxy,
        registerUnaryCallback:
            registerUnaryCallback == null ? null : registerUnaryCallbackProxy,
        run: run == null ? null : runProxy,
        runBinary: runBinary == null ? null : runBinaryProxy,
        runUnary: runUnary == null ? null : runUnaryProxy,
        scheduleMicrotask:
            scheduleMicrotask == null ? null : scheduleMicrotaskProxy,
      );
    };
Function _ZoneSpecification_from_$(m.Scope scope$) => (
      ZoneSpecification other, {
      m.FunctionPointer? handleUncaughtError,
      m.FunctionPointer? run,
      m.FunctionPointer? runUnary,
      m.FunctionPointer? runBinary,
      m.FunctionPointer? registerCallback,
      m.FunctionPointer? registerUnaryCallback,
      m.FunctionPointer? registerBinaryCallback,
      m.FunctionPointer? errorCallback,
      m.FunctionPointer? scheduleMicrotask,
      m.FunctionPointer? createTimer,
      m.FunctionPointer? createPeriodicTimer,
      m.FunctionPointer? print,
      m.FunctionPointer? fork,
    }) {
      Timer createPeriodicTimerProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Duration period,
        void Function(Timer) f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createPeriodicTimer!,
            [
              self,
              parent,
              zone,
              period,
              f,
            ],
            {},
          );
      Timer createTimerProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Duration duration,
        void Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            createTimer!,
            [
              self,
              parent,
              zone,
              duration,
              f,
            ],
            {},
          );
      AsyncError? errorCallbackProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Object error,
        StackTrace? stackTrace,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            errorCallback!,
            [
              self,
              parent,
              zone,
              error,
              stackTrace,
            ],
            {},
          );
      Zone forkProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        ZoneSpecification? specification,
        Map? zoneValues,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            fork!,
            [
              self,
              parent,
              zone,
              specification,
              zoneValues,
            ],
            {},
          );
      void handleUncaughtErrorProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        Object error,
        StackTrace stackTrace,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            handleUncaughtError!,
            [
              self,
              parent,
              zone,
              error,
              stackTrace,
            ],
            {},
          );
      void printProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        String line,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            print!,
            [
              self,
              parent,
              zone,
              line,
            ],
            {},
          );
      R Function(T1, T2) registerBinaryCallbackProxy<R, T1, T2>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T1, T2) f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerBinaryCallback!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R Function() registerCallbackProxy<R>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerCallback!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R Function(T) registerUnaryCallbackProxy<R, T>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T) f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            registerUnaryCallback!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R runProxy<R>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            run!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      R runBinaryProxy<R, T1, T2>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T1, T2) f,
        dynamic arg1,
        dynamic arg2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runBinary!,
            [
              self,
              parent,
              zone,
              f,
              arg1,
              arg2,
            ],
            {},
          );
      R runUnaryProxy<R, T>(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        R Function(T) f,
        dynamic arg,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            runUnary!,
            [
              self,
              parent,
              zone,
              f,
              arg,
            ],
            {},
          );
      void scheduleMicrotaskProxy(
        Zone self,
        ZoneDelegate parent,
        Zone zone,
        void Function() f,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            scheduleMicrotask!,
            [
              self,
              parent,
              zone,
              f,
            ],
            {},
          );
      return ZoneSpecification.from(
        other,
        createPeriodicTimer:
            createPeriodicTimer == null ? null : createPeriodicTimerProxy,
        createTimer: createTimer == null ? null : createTimerProxy,
        errorCallback: errorCallback == null ? null : errorCallbackProxy,
        fork: fork == null ? null : forkProxy,
        handleUncaughtError:
            handleUncaughtError == null ? null : handleUncaughtErrorProxy,
        print: print == null ? null : printProxy,
        registerBinaryCallback:
            registerBinaryCallback == null ? null : registerBinaryCallbackProxy,
        registerCallback:
            registerCallback == null ? null : registerCallbackProxy,
        registerUnaryCallback:
            registerUnaryCallback == null ? null : registerUnaryCallbackProxy,
        run: run == null ? null : runProxy,
        runBinary: runBinary == null ? null : runBinaryProxy,
        runUnary: runUnary == null ? null : runUnaryProxy,
        scheduleMicrotask:
            scheduleMicrotask == null ? null : scheduleMicrotaskProxy,
      );
    };
Function ZoneDelegate_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as ZoneDelegate;
Function ZoneDelegate_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is ZoneDelegate;
Function _ZoneDelegate_handleUncaughtError$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.handleUncaughtError;
Function _ZoneDelegate_run$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      return target$.run(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_runUnary$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
      dynamic arg,
    ) {
      dynamic fProxy(dynamic arg) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [arg],
            {},
          );
      return target$.runUnary(
        zone,
        fProxy,
        arg,
      );
    };
Function _ZoneDelegate_runBinary$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
      dynamic arg1,
      dynamic arg2,
    ) {
      dynamic fProxy(
        dynamic arg1,
        dynamic arg2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            f,
            [
              arg1,
              arg2,
            ],
            {},
          );
      return target$.runBinary(
        zone,
        fProxy,
        arg1,
        arg2,
      );
    };
Function _ZoneDelegate_registerCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      return target$.registerCallback(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_registerUnaryCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy(dynamic arg) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [arg],
            {},
          );
      return target$.registerUnaryCallback(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_registerBinaryCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      dynamic fProxy(
        dynamic arg1,
        dynamic arg2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            f,
            [
              arg1,
              arg2,
            ],
            {},
          );
      return target$.registerBinaryCallback(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_errorCallback$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.errorCallback;
Function _ZoneDelegate_scheduleMicrotask$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      m.FunctionPointer f,
    ) {
      void fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      target$.scheduleMicrotask(
        zone,
        fProxy,
      );
    };
Function _ZoneDelegate_createTimer$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      Duration duration,
      m.FunctionPointer f,
    ) {
      void fProxy() => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [],
            {},
          );
      return target$.createTimer(
        zone,
        duration,
        fProxy,
      );
    };
Function _ZoneDelegate_createPeriodicTimer$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    (
      Zone zone,
      Duration period,
      m.FunctionPointer f,
    ) {
      void fProxy(Timer timer) => scope$.engine.callFunctionPointer(
            scope$,
            f,
            [timer],
            {},
          );
      return target$.createPeriodicTimer(
        zone,
        period,
        fProxy,
      );
    };
Function _ZoneDelegate_print$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.print;
Function _ZoneDelegate_fork$(
  m.Scope scope$,
  ZoneDelegate target$,
) =>
    target$.fork;
Function Zone_as$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ as Zone;
Function Zone_is$(
  m.Scope scope$,
  dynamic target$,
) =>
    () => target$ is Zone;
Zone _Zone_root$() {
  return Zone.root;
}

Zone _Zone_current$() {
  return Zone.current;
}

Zone? _Zone_parent$(Zone target$) {
  return target$.parent;
}

Zone _Zone_errorZone$(Zone target$) {
  return target$.errorZone;
}

Function _Zone_handleUncaughtError$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.handleUncaughtError;
Function _Zone_inSameErrorZone$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.inSameErrorZone;
Function _Zone_fork$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.fork;
Function _Zone_run$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer action) {
      dynamic actionProxy() => scope$.engine.callFunctionPointer(
            scope$,
            action,
            [],
            {},
          );
      return target$.run(actionProxy);
    };
Function _Zone_runUnary$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument,
    ) {
      dynamic actionProxy(dynamic argument) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [argument],
            {},
          );
      return target$.runUnary(
        actionProxy,
        argument,
      );
    };
Function _Zone_runBinary$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument1,
      dynamic argument2,
    ) {
      dynamic actionProxy(
        dynamic argument1,
        dynamic argument2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              argument1,
              argument2,
            ],
            {},
          );
      return target$.runBinary(
        actionProxy,
        argument1,
        argument2,
      );
    };
Function _Zone_runGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer action) {
      void actionProxy() => scope$.engine.callFunctionPointer(
            scope$,
            action,
            [],
            {},
          );
      target$.runGuarded(actionProxy);
    };
Function _Zone_runUnaryGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument,
    ) {
      void actionProxy(dynamic argument) => scope$.engine.callFunctionPointer(
            scope$,
            action,
            [argument],
            {},
          );
      target$.runUnaryGuarded(
        actionProxy,
        argument,
      );
    };
Function _Zone_runBinaryGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      m.FunctionPointer action,
      dynamic argument1,
      dynamic argument2,
    ) {
      void actionProxy(
        dynamic argument1,
        dynamic argument2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            action,
            [
              argument1,
              argument2,
            ],
            {},
          );
      target$.runBinaryGuarded(
        actionProxy,
        argument1,
        argument2,
      );
    };
Function _Zone_registerCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.registerCallback(callbackProxy);
    };
Function _Zone_registerUnaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(dynamic arg) => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [arg],
            {},
          );
      return target$.registerUnaryCallback(callbackProxy);
    };
Function _Zone_registerBinaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(
        dynamic arg1,
        dynamic arg2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [
              arg1,
              arg2,
            ],
            {},
          );
      return target$.registerBinaryCallback(callbackProxy);
    };
Function _Zone_bindCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.bindCallback(callbackProxy);
    };
Function _Zone_bindUnaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(dynamic argument) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [argument],
            {},
          );
      return target$.bindUnaryCallback(callbackProxy);
    };
Function _Zone_bindBinaryCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      dynamic callbackProxy(
        dynamic argument1,
        dynamic argument2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [
              argument1,
              argument2,
            ],
            {},
          );
      return target$.bindBinaryCallback(callbackProxy);
    };
Function _Zone_bindCallbackGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.bindCallbackGuarded(callbackProxy);
    };
Function _Zone_bindUnaryCallbackGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy(dynamic argument) => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [argument],
            {},
          );
      return target$.bindUnaryCallbackGuarded(callbackProxy);
    };
Function _Zone_bindBinaryCallbackGuarded$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy(
        dynamic argument1,
        dynamic argument2,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [
              argument1,
              argument2,
            ],
            {},
          );
      return target$.bindBinaryCallbackGuarded(callbackProxy);
    };
Function _Zone_errorCallback$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.errorCallback;
Function _Zone_scheduleMicrotask$(
  m.Scope scope$,
  Zone target$,
) =>
    (m.FunctionPointer callback) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      target$.scheduleMicrotask(callbackProxy);
    };
Function _Zone_createTimer$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      Duration duration,
      m.FunctionPointer callback,
    ) {
      void callbackProxy() => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [],
            {},
          );
      return target$.createTimer(
        duration,
        callbackProxy,
      );
    };
Function _Zone_createPeriodicTimer$(
  m.Scope scope$,
  Zone target$,
) =>
    (
      Duration period,
      m.FunctionPointer callback,
    ) {
      void callbackProxy(Timer timer) => scope$.engine.callFunctionPointer(
            scope$,
            callback,
            [timer],
            {},
          );
      return target$.createPeriodicTimer(
        period,
        callbackProxy,
      );
    };
Function _Zone_print$(
  m.Scope scope$,
  Zone target$,
) =>
    target$.print;
Function _Zone_$index$$(
  m.Scope scope$,
  Zone target$,
) =>
    (Object? index) => target$[index];
Function _runZoned$(m.Scope scope$) => (
      m.FunctionPointer body, {
      Map? zoneValues,
      ZoneSpecification? zoneSpecification,
      Function? onError,
    }) {
      dynamic bodyProxy() => scope$.engine.callFunctionPointer(
            scope$,
            body,
            [],
            {},
          );
      return runZoned(
        bodyProxy,
        onError: onError,
        zoneSpecification: zoneSpecification,
        zoneValues: zoneValues == null ? null : Map.from(zoneValues),
      );
    };
Function _runZonedGuarded$(m.Scope scope$) => (
      m.FunctionPointer body,
      m.FunctionPointer onError, {
      Map? zoneValues,
      ZoneSpecification? zoneSpecification,
    }) {
      dynamic bodyProxy() => scope$.engine.callFunctionPointer(
            scope$,
            body,
            [],
            {},
          );
      void onErrorProxy(
        Object error,
        StackTrace stack,
      ) =>
          scope$.engine.callFunctionPointer(
            scope$,
            onError,
            [
              error,
              stack,
            ],
            {},
          );
      return runZonedGuarded(
        bodyProxy,
        onErrorProxy,
        zoneSpecification: zoneSpecification,
        zoneValues: zoneValues == null ? null : Map.from(zoneValues),
      );
    };
