// generated by micro_dart_generator
// ignore_for_file: non_constant_identifier_names

import 'package:micro_dart_runtime/micro_dart_runtime.dart' as m;
import 'dart:developer';
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:isolate' show Isolate, RawReceivePort, SendPort;

const libraryMirror = m.LibraryMirror(
  'dart:developer',
  {
    'reachabilityBarrier': _reachabilityBarrier$,
    'debugger': _debugger$,
    'inspect': _inspect$,
    'log': _log$,
    'extensionStreamHasListener': _extensionStreamHasListener$,
    'ServiceExtensionResponse.invalidParams':
        _ServiceExtensionResponse_invalidParams$,
    'ServiceExtensionResponse.extensionError':
        _ServiceExtensionResponse_extensionError$,
    'ServiceExtensionResponse.extensionErrorMax':
        _ServiceExtensionResponse_extensionErrorMax$,
    'ServiceExtensionResponse.extensionErrorMin':
        _ServiceExtensionResponse_extensionErrorMin$,
    'registerExtension': _registerExtension$,
    'postEvent': _postEvent$,
    'UserTag.maxUserTags': _UserTag_maxUserTags$,
    'UserTag.defaultTag': _UserTag_defaultTag$,
    'getCurrentTag': _getCurrentTag$,
    'Timeline.now': _Timeline_now$,
  },
  {},
  {},
);
int _reachabilityBarrier$() {
  return reachabilityBarrier;
}

Function _debugger$(m.Scope scope) => debugger;
Function _inspect$(m.Scope scope) => inspect;
Function _log$(m.Scope scope) => log;
bool _extensionStreamHasListener$() {
  return extensionStreamHasListener;
}

int _ServiceExtensionResponse_invalidParams$() {
  return ServiceExtensionResponse.invalidParams;
}

int _ServiceExtensionResponse_extensionError$() {
  return ServiceExtensionResponse.extensionError;
}

int _ServiceExtensionResponse_extensionErrorMax$() {
  return ServiceExtensionResponse.extensionErrorMax;
}

int _ServiceExtensionResponse_extensionErrorMin$() {
  return ServiceExtensionResponse.extensionErrorMin;
}

Function _registerExtension$(m.Scope scope) => (
      String method,
      m.FunctionPointer handler,
    ) {
      Future<ServiceExtensionResponse> handlerProxy(
        String method,
        Map<String, String> parameters,
      ) async =>
          await scope.engine.callFunctionPointerAsync(
            scope,
            handler,
            [
              method,
              parameters,
            ],
            {},
          );
      registerExtension(
        method,
        handlerProxy,
      );
    };
Function _postEvent$(m.Scope scope) => postEvent;
int _UserTag_maxUserTags$() {
  return UserTag.maxUserTags;
}

UserTag _UserTag_defaultTag$() {
  return UserTag.defaultTag;
}

Function _getCurrentTag$(m.Scope scope) => getCurrentTag;
int _Timeline_now$() {
  return Timeline.now;
}
